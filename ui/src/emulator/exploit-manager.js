const EXPLOIT_TYPES = {
	SHELL: 0,
	RANDOM_FOLDER: 1,
	CHANGE_PASSWORD: 2,
	COMPUTER: 3,
	FIREWALL_DISABLE: 4
};

const EXPLOIT_REQUIRED = {
	LIBRARY: 0,
	NUMBER_USERS_REGISTER: 1,
	ANY_ACTIVE_USER: 2,
	ROOT_ACTIVE_USER: 3,
	LOCAL_NETWORK: 4,
	PORT_FORWARD: 5,
	CONNECTION_GATEWAY: 6
};

const EXPLOIT_VULNERABILITY_TYPE = {
	BUFFER_OVERFLOW: 0
};

const Exploit = function(vulnerability) {
	const me = this;

	me.type = vulnerability.typeVulner;
	me.requiredActions = vulnerability.requiredActions;
	me.helperHackResult = vulnerability.helperHackResult;
	me.unsecValue = vulnerability.unsecValue;
	me.details = vulnerability.details;
	me.requiredLibraryVersion = vulnerability.reqLibVersion;
	me.isRemote = vulnerability.isRemote;
	me.requiredLibrary = vulnerability.requiredLib;
	me.metaxploitVersion = vulnerability.metaxploitVersion.version.join('.');

	return me;
};

Exploit.prototype.getRequiredActions = function() {
	return this.requiredActions;
};

Exploit.prototype.getHelperHackResult = function() {
	return this.helperHackResult;
};

Exploit.prototype.getDetails = function() {
	return this.details;
};

Exploit.prototype.getRequiredLibraryVersion = function() {
	return this.requiredLibraryVersion;
};

Exploit.prototype.getRequiredLibrary = function() {
	return this.requiredLibrary;
};

Exploit.prototype.getUnsecValue = function() {
	return this.unsecValue;
};

const parseLibraries = function(versionsControl) {
	return Object.entries(versionsControl).reduce((libraries, [name, data]) => {
		return {
			...libraries,
			[data.idLib]: {
				...data,
				name: name,
				version: data.version.version.join('.')
			}
		};
	}, {});
};

const ExploitManager = function(infoGen) {
	const me = this;
	
	me.libraries = parseLibraries(infoGen.versionsControl);
	me.exploits = infoGen.exploits;

	return me;
};

ExploitManager.prototype.getLibrary = function(libId) {
	const me = this;
	return me.libraries[libId];
};

ExploitManager.prototype.generateInfo = function(exploit) {
	const me = this;
	const text = [];

	text.push(`${exploit.getDetails()} <b>${exploit.getUnsecValue()}</b>. Buffer overflow`);

	const requirements = exploit.getRequiredActions().map((actionType) => {
		switch (actionType) {
			case EXPLOIT_REQUIRED.LIBRARY:
				const requiredLibVersion = exploit.getRequiredLibraryVersion();
				const requiredLib = me.getLibrary(exploit.getRequiredLibrary())?.name;
				return `* Using namespace <b>${requiredLibVersion}.so</b> compiled at version <b>${requiredLib}</b>.`;
			case EXPLOIT_REQUIRED.NUMBER_USERS_REGISTER:
				const userAmount = exploit.getHelperHackResult()?.numRegisterUsers;
				return `* Checking registered users equal to ${userAmount}.`;
			case EXPLOIT_REQUIRED.ANY_ACTIVE_USER:
				return '* Checking an active user.';
			case EXPLOIT_REQUIRED.ROOT_ACTIVE_USER:
				return '* Checking root active user.';
			case EXPLOIT_REQUIRED.LOCAL_NETWORK:
				return '* Checking existing connection in the local network.';
			case EXPLOIT_REQUIRED.PORT_FORWARD:
				const portForwardAmount = exploit.getHelperHackResult()?.numPortForward;
				return `* ${portForwardAmount} port forwarding configured from router to the target computer.`;
			case EXPLOIT_REQUIRED.CONNECTION_GATEWAY:
				const connectionGatewayAmount = exploit.getHelperHackResult()?.numConnGateway;
				return `* ${connectionGatewayAmount} computers using this router as gateway.`;
		}
	});

	return text.concat(requirements).join('\n');
};

module.exports = ExploitManager;