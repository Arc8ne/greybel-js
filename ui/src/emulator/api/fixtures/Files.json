[
    {
        "Content": "//command: ls\nValidateInput = function(input)\n\tif input == \"-la\" or input == \"-l\" or input == \"-a\" then return true\n\treturn false\nend function \n\nif params.len > 3 or (params.len == 1 and params[0].indexOf(\"-\") != null and not ValidateInput(params[0])) or (params.len == 2 and not ValidateInput(params[0])) or (params.len == 3 and (not ValidateInput(params[0]) or not ValidateInput(params[1]))) then\n\tprint(command_info(\"ls_usage\"))\n\t\nelse\n\tcomputer = get_shell.host_computer\n\tfolderPath = current_path\n\tif params and params[params.len - 1].indexOf(\"-\") == null then\n\t\tfolderPath = params[params.len - 1]\n\tend if\n\t\n\tfolder = computer.File(folderPath)\n\tif folder == null then\n\t\tprint(\"ls: No such file or directory\")\n\telse\n\t\tif not folder.has_permission(\"r\") then\n\t\t\tprint(\"ls: permission denied\")\n\n\t\telse\n\t\t\tshowHide = 0\n\t\t\tif params and params[0].indexOf(\"a\") != null then\n\t\t\t\tshowHide = 1\n\t\t\tend if\n\n\t\t\tshowDetails = 0\n\t\t\tif params and params[0].indexOf(\"l\") != null then\n\t\t\t\tshowDetails = 1\n\t\t\tend if\n\n\t\t\tsubFiles = folder.get_folders + folder.get_files\n\t\t\toutput = \"\"\n\t\t\tfor subFile in subFiles\n\t\t\t\tnameFile = subFile.name\n\t\t\t\tpermission = subFile.permissions\n\t\t\t\towner = subFile.owner\n\t\t\t\tsize = subFile.size\n\t\t\t\tgroup = subFile.group\n\n\t\t\t\tif showHide or nameFile.indexOf(\".\") != 0 then\n\t\t\t\t\tif showDetails then\n\t\t\t\t\t\toutput = output + \"\\n\" + permission + \" \" + owner + \" \" + group + \" \" + size + \" 00:00 \" + nameFile\n\t\t\t\t\telse\n\t\t\t\t\t\toutput = output + \"\\n\" + nameFile\n\t\t\t\t\tend if\n\t\t\t\tend if\n\t\t\tend for\n\t\t\t\n\t\t\tprint(format_columns(output))\n\n\t\tend if\n\tend if\nend if\n",
        "ID": "ed0acd5450d165069e7d770479616cde",
        "refCount": 1
    },
    {
        "Content": "//command: ps\nif params.len > 0 then exit(command_info(\"ps_usage\"))\noutput = get_shell.host_computer.show_procs\nprint(format_columns(output))",
        "ID": "1751806cd6bfca2ecd9023c3d1dd0891",
        "refCount": 1
    },
    {
        "Content": "//command: pwd\nprint(current_path)",
        "ID": "58cf621ce7a30741860fca1d956cff19",
        "refCount": 1
    },
    {
        "Content": "//command: ifconfig\nif params.len != 0 and (params.len != 4 or params[0] == \"-h\" or params[0] == \"--help\") then exit(command_info(\"ifconfig_usage\"))\ncomputer = get_shell.host_computer\nif (params.len == 0) then\n\trouter = get_router    \n\tif computer.is_network_active then\n\t    lip = computer.local_ip\n    \tpip = router.public_ip\n    \tgw = computer.network_gateway\n\t    if computer.active_net_card == \"WIFI\" then\t\t    \n\t\t    output = \"\\nConnected to Wi-Fi:\\nEssid: \" + router.essid_name + \"\\nBssid: \" + router.bssid_name\n\t\telse\n\t\t    output = \"\\nEthernet connection:\"    \n\t\tend if\n\telse\n\t\tlip = \"0.0.0.0\"\n\t\tpip = \"0.0.0.0\"\n\t\tgw = \"0.0.0.0\"\n\t\toutput = \"\\nNot connected to the network.\"\n\tend if\n\tprint( output + \"\\n----------------\\nPublic IP: \" + pip + \"\\nLocal IP: \" + lip + \"\\nGateway: \" + gw + \"\\n\")\nelse \n\tif params[2] != \"gateway\" then exit(command_info(\"ifconfig_usage\"))\n\tdevice = params[0]\n\taddress = params[1]\n\tgateway = params[3]\n\tif not is_valid_ip(address) then exit(\"ifconfig: invalid ip address\")\n\tif not is_valid_ip(gateway) then exit(\"ifconfig: invalid gateway\")\n\toutput = computer.connect_ethernet(device, address, gateway)\n\tif output.len > 0 then print(output)\nend if\n",
        "ID": "672f8bf6f07afa7715e50ac28f347ae0",
        "refCount": 1
    },
    {
        "Content": "//command: iwconfig\nif params.len != 4 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"iwconfig_usage\"))\t\ncomputer = get_shell.host_computer\ndevices = computer.network_devices\nif devices == null or devices.indexOf(params[0]) == null then exit(\"iwconfig: Network device not found\")\nbssid = params[1]\nessid = params[2]\npassword = params[3]\nstatus = computer.connect_wifi(params[0], bssid, essid, password)\nif typeof(status) == \"string\" then print(status)\n",
        "ID": "7f7eb1e105d4b50a28f95588115761ca",
        "refCount": 1
    },
    {
        "Content": "//command: iwlist\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"iwlist_usage\"))\t\ncomputer = get_shell.host_computer\ndevices = computer.network_devices\nif devices == null or devices.indexOf(params[0]) == null then exit(\"iwlist: Network device not found\")\nif params[0].indexOf(\"eth\") != null then exit(\"iwlist: ethernet cards not supported for this command\")\nnetworks = computer.wifi_networks(params[0])\nif networks == null then exit(command_info(\"iwlist_usage\"))\n\ninfo = \"BSSID PWR ESSID\"\nfor network in networks\n\tinfo = info + \"\\n\" + network\nend for\nprint(format_columns(info))",
        "ID": "80414e12564b13b687fce27310e687f2",
        "refCount": 1
    },
    {
        "Content": "//command: cat\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"cat_usage\"))\n\npathFile = params[0]\nfile = get_shell.host_computer.File(pathFile)\n\nif file == null then exit(\"cat: file not found: \"+pathFile)\nif file.is_binary then exit(\"cat: can't open \" + file.path + \". Binary file\")\t\nif not file.has_permission(\"r\") then exit(\"cat: permission denied\")\n\nprint(file.get_content)\n",
        "ID": "97f264a26a8c53dfaa815d85e6b107f4",
        "refCount": 1
    },
    {
        "Content": "//command: rm\nif params.len < 1 or params.len > 2 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"rm_usage\"))\n\npathFile = params[0]\nisRecursive = 0\nif params[0] == \"-r\" then\n\tif params.len == 1 then exit(command_info(\"rm_usage\"))\n\tisRecursive = 1\n\tpathFile = params[1]\nend if\nfile = get_shell.host_computer.File(pathFile)\n\t\nif file == null then exit(\"rm: file not found: \"+pathFile)\nif not file.has_permission(\"w\") then exit(\"rm: permission denied\")\n\nif file.is_folder == 1 and isRecursive == 0 then\n\tprint(\"rm: \" + file.name + \" is a directory\")\nelse\n\toutput = file.delete\n\tif output.len > 0 then print(output)\nend if\n",
        "ID": "ae76231aca63b510691e4d7b9ecbdf1f",
        "refCount": 1
    },
    {
        "Content": "//command: mv\nif params.len != 2 then\n\tprint(command_info(\"mv_usage\"))\nelse\n\torigFile = params[0]\n\tdestFolder = params[1]\n\n\tcomputer = get_shell.host_computer\n\tfile = computer.File(origFile)\n\tif file == null then\n\t\tprint(\"mv: can't find \" + origFile)\n\n\telse\n\t\tnewName = \"\"\n\t\tfolder = computer.File(destFolder)\n\t\tif folder == null then\n\t\t\t//Check if the user wants to put a new name.\n\t\t\tpathParent = parent_path(destFolder)\n\t\t\t\t\t\n\t\t\tif pathParent == destFolder then\t\t\t\n\t\t\t\tnewName = destFolder\n\t\t\t\tdestFolder = file.parent.path\t\t\n\t\t\t\tfile.move(destFolder, newName)\n\n\t\t\telse\n\n\t\t\t\tfolder = computer.File(pathParent)\n\t\t\t\tnewName = destFolder[destFolder.len - (destFolder.len - pathParent.len):]\t\t\t\n\t\t\t\tif newName[0] == \"/\" then\n\t\t\t\t\tnewName = newName[1:]\n\t\t\t\tend if\n\t\t\t\tif folder == null then\t\t\t\t\n\t\t\t\t\tprint(\"mv: can't copy file. \" + destFolder + \" doesn't exist.\")\n\t\t\t\tend if\t\t\t\n\t\t\tend if\n\t\t\n\t\tend if\n\n\t\tif folder != null then\n\t\t\t\n\t\t\t//Check if is trying to copy the file on itself. Ignored.\n\t\t\tif file.parent.path != folder.parent.path or file.name != folder.name then\n\n\t\t\t\tfinalDest = folder.path\n\t\t\t\t\n\t\t\t\tif(newName.len == 0) then\n\t\t\t\t\tnewName = file.name\n\t\t\t\tend if\n\n\t\t\t\tif not folder.is_folder then\t\t\t\n\t\t\t\t\tfinalDest = file.parent.path\n\t\t\t\t\tnewName = folder.name\n\t\t\t\tend if\n\n\t\t\t\tif file.parent.path == folder.parent.path and newName != file.name then\n\t\t\t\t\tfile.rename(newName)\n\t\t\t\telse\n\t\t\t\t\tfile.move(finalDest, newName)\n\t\t\t\tend if\n\t\t\tend if\n\t\tend if\n\tend if\nend if",
        "ID": "abd11ba56ada208334e4724511cdee7a",
        "refCount": 1
    },
    {
        "Content": "//command: cp\nif params.len != 2 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"cp_usage\"))\n\norigFile = params[0]\ndestFolder = params[1]\n\ncomputer = get_shell.host_computer\nfile = computer.File(origFile)\nif not file then exit(\"cp: can't find \" + origFile)\n\nnewName = \"\"\nfolder = computer.File(destFolder)\nif not folder then\n\t//Check if the user wants to put a new name.\n\tpathParent = parent_path(destFolder)\n\t\t\t\t\t\n\tif pathParent == destFolder then\t\t\t\n\t\tnewName = destFolder\n\t\tdestFolder = file.parent.path\t\t\n\t\toutput = file.copy(destFolder, newName)\n\t\tif output and output != 1 then print(output)\n\t\texit\n\tend if\t\n\n\tfolder = computer.File(pathParent)\n\tnewName = destFolder[destFolder.len - (destFolder.len - pathParent.len):]\t\t\t\n\tif newName[0] == \"/\" then\n\t\tnewName = newName[1:]\n\tend if\n\tif not folder then exit(\"cp: can't copy file. \" + destFolder + \" doesn't exist.\")\n\t\nend if\n\nif folder then\n\t\t\t\n\t//Check if is trying to copy the file on itself. Ignored.\n\tif file.parent.path != folder.parent.path or file.name != folder.name then\n\n\t\tfinalDest = folder.path\n\t\t\t\t\n\t\tif(newName.len == 0) then\n\t\t\tnewName = file.name\n\t\tend if\n\n\t\tif not folder.is_folder then\t\t\t\n\t\t\tfinalDest = file.parent.path\n\t\t\tnewName = folder.name\n\t\tend if\n\n\t\toutput = file.copy(finalDest, newName)\n\t\tif output and output != 1 then print(output)\n\n\tend if\nend if\n\n",
        "ID": "35f798b48a5dbfb139b3ce101416ae2f",
        "refCount": 1
    },
    {
        "Content": "//Command: ssh\nif params.len < 2 or params.len > 3 then exit(command_info(\"ssh_usage\"))\ncredentials = params[0].split(\"@\")\nuser = credentials[0]\npassword = credentials[1]\n\nport = 22\n// params is a list of strings, so you have to convert it to integer, which is what connect_service accepts.\nif params.len == 3 then port = params[2].to_int\nif typeof(port) != \"number\" then exit(\"Invalid port: \" + port)\nprint(\"Connecting...\")\n\nshell = get_shell.connect_service(params[1], port, user, password, \"ssh\")\nif shell then shell.start_terminal",
        "ID": "7df120e51845b3ba82b5adee2bdde550",
        "refCount": 1
    },
    {
        "Content": "//Command: ftp\nif params.len < 2 or params.len > 3 then exit(command_info(\"ftp_usage\"))\ncredentials = params[0].split(\"@\")\nuser = credentials[0]\npassword = credentials[1]\n\nport = 21\n// params is a list of strings, so you have to convert it to integer, which is what connect_service accepts.\nif params.len == 3 then port = params[2].to_int\nif typeof(port) != \"number\" then exit(\"Invalid port: \" + port)\nprint(\"Connecting...\")\n\nftp_shell = get_shell.connect_service(params[1], port, user, password, \"ftp\")\nif ftp_shell then ftp_shell.start_terminal",
        "ID": "346a6df1357d2a02b3bc4555fecceb5f",
        "refCount": 1
    },
    {
        "Content": "//command: mkdir\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then\n\tprint(command_info(\"mkdir_usage\"))\nelse\n\tcomputer = get_shell.host_computer\n\tpathFile = params[0]\n\tpathParent = parent_path(pathFile)\n\texistFile = computer.File(pathFile)\n\t\n\tif pathParent == pathFile then\n\t\tpathParent = current_path\n\tend if\n\n\tparent = computer.File(pathParent)\n\tif parent == null then\n\t\tprint(\"mkdir: \" + pathParent + \" not found\")\n\n\telse if existFile != null then\n\t\tprint(\"mkdir: \" + existFile.path + \" file exists\")\n\n\telse if not parent.has_permission(\"w\") then\n\t\tprint(\"mkdir: permission denied\")\n\n\telse\n\t\tarrayPath = pathFile.split(\"/\")\n\t\toutput = computer.create_folder(parent.path, arrayPath[arrayPath.len - 1])\n\t\tif output != null and output != 1 then\n\t\t\tprint(output)\n\t\tend if \n\n\tend if\nend if\n",
        "ID": "b59831a7e78f5b967af88346979e2ade",
        "refCount": 1
    },
    {
        "Content": "if params.len < 1 or not params[0].trim then exit(command_info(\"rmdir_usage\"))\npath = params[0].trim\nif params[0] == \"--help\" then exit(command_info(\"rmdir_usage\"))\nf = get_shell.host_computer.File(path)\nif typeof(f) != \"file\" then exit(\"rmdir: failed to remove '\" + path + \"': no such file or directory\")\nif f.is_folder == 0 then exit(\"Error: \" + f.name + \" is not a directory.\")\nif f.get_files.len >= 1 or f.get_folders.len >= 1 then exit(\"rmdir: failed to remove '\" + path + \"': directory not empty\")\nfd = f.delete\nif fd.trim.len == 0 then exit\nexit(\"rmdir: failed to remove '\" + path + \"': \" + fd.trim)",
        "ID": "179442a1ad63de6e1370f7ff07005286",
        "refCount": 1
    },
    {
        "Content": "//command: chmod\nif params.len < 2 or (params.len == 3 and params[0] != \"-R\") then exit(command_info(\"chmod_usage\"))\n\npermissions = params[0]\npathFile = params[1]\nisRecursive = 0\n\nif params.len == 3 then\n    permissions = params[1]\n\tpathFile = params[2]\n\tisRecursive = 1\nend if\n\nfile = get_shell.host_computer.File(pathFile)\nif file == null then exit(\"chmod: can't find \" + pathFile)\noutput = file.chmod(permissions, isRecursive)\nif output then print(output)\n\t\n\n",
        "ID": "67537931f80938fcdb507013bd3f1383",
        "refCount": 1
    },
    {
        "Content": "//command: whois\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then\n\tprint(command_info(\"whois_usage\"))\nelse\n\taddress = params[0]\n\tprint(whois(address))\nend if\n",
        "ID": "c13fa94cca11f402dfd2ce750305f509",
        "refCount": 1
    },
    {
        "Content": "//command: sudo\nif not params or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"sudo_usage\"))\nif params[0] == \"-u\" and params.len != 2 then exit(command_info(\"sudo_usage\"))\n\ninputPass = user_input(\"Password: \", true)\n\nif params[0] == \"-u\" then\n\tshell = get_shell(params[1], inputPass)\n\tif not shell then exit(\"sudo: incorrect username or password\")\nelse \n\tshell = get_shell(\"root\", inputPass)\n\tif not shell then exit(\"sudo: incorrect password\")\nend if\n\nif params[0] == \"-s\" or params[0] == \"-u\" then \n\tshell.start_terminal\nelse\n\tcomputer = shell.host_computer\n\targs = params[1:].join(\" \")\n\tif not params[0].indexOf(\"/\") then\n\t\tglobalPath = [current_path, \"/bin\", \"/usr/bin\"]\n\t\tfor path in globalPath\n\t\t\tprogram = computer.File(path + \"/\" + params[0])\n\t\t\tif program != null then exit(shell.launch(program.path, args))\n\t\tend for\n\telse\n\t\tprogram = computer.File(params[0])\n\t\tif not program then exit(params[0] + \" not found.\")\n\t\tshell.launch(program.path, args)\n\tend if\nend if",
        "ID": "b23b29675bc63c4615587d64cf2550fd",
        "refCount": 1
    },
    {
        "Content": "//command: useradd\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"useradd_usage\"))\n\ninputMsg = \"Setting password for user \" + params[0] +\".\\nNew password:\"\ninputPass = user_input(inputMsg, true)\n\noutput = get_shell.host_computer.create_user(params[0], inputPass)\nif output == true then exit(\"User created OK\")\nif output then exit(output)\nprint(\"Error: the user could not be created.\")",
        "ID": "cf2725ebfbb35385146859772f754162",
        "refCount": 1
    },
    {
        "Content": "//command: userdel\nif not params.len or (params.len == 1 and params[0] == \"-r\") or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"userdel_usage\"))\n\ndelete = 0\nif params[0] == \"-r\" then\n  delete = 1\n  params.pull\nend if\n\noutput = get_shell.host_computer.delete_user(params[0], delete)\nif output == true then exit(\"user \" + params[0] + \" deleted.\")\nif output then exit(output)\nprint(\"Error: user not deleted.\")",
        "ID": "b86c97aaf728036dd1a21e4bb9f7f5d3",
        "refCount": 1
    },
    {
        "Content": "//command: passwd\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"passwd_usage\"))\n\ninputMsg = \"Changing password for user \" + params[0] +\".\\nNew password:\"\ninputPass = user_input(inputMsg, true)\n\noutput = get_shell.host_computer.change_password(params[0], inputPass)\nif output == true then exit(\"password modified OK\")\nif output then exit(output)\nprint(\"Error: password not modified\")",
        "ID": "6125e2b97512bd546a609f1f3f9108bb",
        "refCount": 1
    },
    {
        "Content": "//command: nslookup\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then\n\tprint(command_info(\"nslookup_usage\"))\nelse\n\taddress = params[0]\n\tprint(\"Address: \"+nslookup(address));\nend if\n",
        "ID": "e866a98f6e14d82f849123e5541c9567",
        "refCount": 1
    },
    {
        "Content": "//command: build\nif params.len != 2 then\n\tprint(command_info(\"build_usage\"))\nelse\n\tpathSource = params[0]\n\tprogramPath = params[1]\n\n\tshell = get_shell\n\tcomputer = shell.host_computer\n\tfileSource = computer.File(pathSource)\n\tfolderDest = computer.File(programPath)\n\n\tif fileSource == null then exit(\"build: can't find \"+ pathSource)\n\tif folderDest == null then exit(\"build: can't find \" + programPath)\n\t\n\toutput = shell.build(fileSource.path, folderDest.path)\n\tif output.len == 0 then\n\t\tprint(\"build successful.\")\n\telse\n\t\tprint(output);\n\tend if\nend if\n",
        "ID": "acb3e5d64439c261bb430a04669df87b",
        "refCount": 1
    },
    {
        "Content": "//command: touch\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"touch_usage\"))\n\npathFile = params[0]\npathParent = parent_path(pathFile)\ncomputer = get_shell.host_computer\n\nif pathParent == pathFile then\n\tpathParent = current_path\nend if\n\nparent = computer.File(pathParent)\n\nif not parent then exit(\"touch: \" + pathParent + \" not found\")\nif not parent.has_permission(\"w\") then exit(\"touch: permission denied\")\n\narrayPath = pathFile.split(\"/\")\noutput = computer.touch(parent.path, arrayPath[arrayPath.len - 1])\nif output and output != 1 then print(output)\n",
        "ID": "05ed0134189131958c4cc5a9ce63196e",
        "refCount": 1
    },
    {
        "Content": "//command: chown\nif params.len < 2 or (params.len == 3 and params[0] != \"-R\") then exit(command_info(\"chown_usage\"))\n\nowner = params[0]\npathFile = params[1]\nisRecursive = 0\n\nif params.len == 3 then\n    owner = params[1]\n    pathFile = params[2]\n    isRecursive = 1\nend if\n\nfile = get_shell.host_computer.File(pathFile)\nif file == null then exit(\"chown: file not found: \"+pathFile)\noutput = file.set_owner(owner, isRecursive)\nif output then print(output)",
        "ID": "1d258720401d10592e813620be79911f",
        "refCount": 1
    },
    {
        "Content": "//command: chgrp\nif params.len < 2 or (params.len == 3 and params[0] != \"-R\") then exit(command_info(\"chgrp_usage\"))\n\ngroup = params[0]\npathFile = params[1]\nisRecursive = 0\n\nif params.len == 3 then\n    group = params[1]\n    pathFile = params[2]\n    isRecursive = 1\nend if\n\nfile = get_shell.host_computer.File(pathFile)\nif file == null then exit(\"chgrp: file not found: \"+pathFile)\noutput = file.set_group(group, isRecursive)\nif output then print(output)\n",
        "ID": "5de9448caff5ff5572a3290385aeef83",
        "refCount": 1
    },
    {
        "Content": "//command: groupadd\nif params.len != 2 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"groupadd_usage\"))\n\nuser = params[0]\ngroup = params[1]\n\noutput = get_shell.host_computer.create_group(user, group)\nif output == true then exit(\"Group \" + group + \" added to user \" + user)\nif output then exit(output)\nprint(\"Error: the group could not be created.\")",
        "ID": "371f28b724af9408d63001a64fd64be9",
        "refCount": 1
    },
    {
        "Content": "//command: groupdel\nif params.len != 2 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"groupdel_usage\"))\n\nuser = params[0]\ngroup = params[1]\n\noutput = get_shell.host_computer.delete_group(user, group)\nif output == true then exit(\"Group \" + group + \" deleted from user \" + user)\nif output then exit(output)\nprint(\"Error: the group could not be deleted.\")",
        "ID": "4ec59c97aaa495ffbc38176ba0858434",
        "refCount": 1
    },
    {
        "Content": "//command: groups\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"groups_usage\"))\nuser = params[0]\noutput = get_shell.host_computer.groups(user)\nif not output then exit(command_info(\"groups_usage\"))\nprint(output)",
        "ID": "f4ca78f5a3acba1da826c5169839f4c1",
        "refCount": 1
    },
    {
        "Content": "//command: kill\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"kill_usage\"))\nPID = params[0].to_int\nif typeof(PID) != \"number\" then exit(\"The PID must be a number\\n\" + command_info(\"kill_usage\"))\n\noutput = get_shell.host_computer.close_program(PID)\nif output == true then exit(\"Process \" + PID + \" closed\");\nif output then exit(output)\nprint(\"Process \" + PID + \" not found\")\n\n",
        "ID": "9c88d7bd22e7403aacd126b0d63f8966",
        "refCount": 1
    },
    {
        "Content": "//Command: ping\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"ping_usage\"))\nresult = get_shell.ping(params[0])\nif result then\n    if typeof(result) == \"string\" then\n        print(result) \n\telse\n\t    print(\"Ping successful\")\n\tend if\nelse\n\tprint(\"ip unreachable\");\nend if\n",
        "ID": "d6b38bb816d4619b5c919ff4cf348599",
        "refCount": 1
    },
    {
        "Content": "{\"listaZonaMem\":{\"0x791AAA98\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0,1,3],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"chortmsbintransf\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"testextlined\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0,1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/boot\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"returna\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x791AAA98\",\"timesPatched\":0,\"hide\":false},\"0x1701C0B3\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"indop\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2,0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"eapk\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,3],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"watch_sho\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,3],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/root\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"setactivefalss\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x1701C0B3\",\"timesPatched\":0,\"hide\":true},\"0x4EF6FE6F\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"constationarye\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"timekey\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2,1],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"upalpositionx\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/boot\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"eturna\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x4EF6FE6F\",\"timesPatched\":0,\"hide\":true},\"0x422B5E0A\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"eheightmid\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,3],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"yn_ltreel\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,0,2],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"isremoveat\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x422B5E0A\",\"timesPatched\":0,\"hide\":true},\"0x19BF9483\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3,1,0],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"oadsourceclicke\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"sultpareac\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x19BF9483\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":12}",
        "ID": "5aab0c29d51f591a03b893968b47d968",
        "refCount": 65
    },
    {
        "Content": "{\"listaZonaMem\":{\"0x32D3F891\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/etc\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"reetryparamargumeract\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[6],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/bin\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"tionnameter\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":4,\"randomPath\":\"/boot\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"++scan_tree\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":4,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"_alizelineypositionnametextuiteswi\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"totalwinde\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x32D3F891\",\"timesPatched\":0,\"hide\":false},\"0x3DEBABF3\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/lib\",\"user\":\"root\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"outoviewportiali\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":4,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"itextpend_bitsstopwatch_star\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"onfori\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x3DEBABF3\",\"timesPatched\":0,\"hide\":false}},\"version\":{\"version\":[1,0,0]},\"idLib\":8}",
        "ID": "5ded19383d6805e084af10b029a7b0c3",
        "refCount": 43
    },
    {
        "Content": "{\"listaZonaMem\":{\"0xF5A3DE6\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[1,2,0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"rulyb\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3,0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"toendif\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0,3,1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"atelineypositio\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[2,0],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/boot\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"temps\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0,1,2],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"end_bitsblcodesel\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0xF5A3DE6\",\"timesPatched\":0,\"hide\":false},\"0x2B6C1853\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[1,2,0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"cound\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,2],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"length\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/boot\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"rlengt\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x2B6C1853\",\"timesPatched\":0,\"hide\":true},\"0x7FE6B3EF\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"laddg\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3,0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"eletef\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"ontypel\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x7FE6B3EF\",\"timesPatched\":0,\"hide\":true},\"0x247868A3\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[1],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/sys\",\"user\":\"root\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"signa\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/root\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"movecttransformanchormoffs\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,2],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/lib\",\"user\":\"root\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"atus\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,3],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/root\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"sor-1\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"delc\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x247868A3\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":13}",
        "ID": "6d1ec277ade114dc6f2480066e3a1873",
        "refCount": 65
    },
    {
        "Content": "root:08fe2f395dcef58ac3bf8b934d13b81d\n",
        "ID": "43af42827aff497bda07511fd7fa719f",
        "refCount": 1
    },
    {
        "Content": "<!doctype html>\n<title>ROUTER</title>\n<style>\n  body { text-align: center; padding: 25px; }\n  h1 { font-size: 50px; }\n  body { font: 20px Helvetica, sans-serif; color: #333; }\n  article { display: block; text-align: left; width: 650px; margin: 0 auto; }\n  html{\n    background-color: whitesmoke;\n    height:100%;\n  }\n</style>\n<article>\n  <h1>Router configuration</h1>\n    <div>      \n    </div>\n  </article>",
        "ID": "196f679887c3a9e605d6629e2f2fc104",
        "refCount": 43
    },
    {
        "Content": "{\"listaZonaMem\":{\"0x7144C273\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[1],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/root\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"paramete\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[2,0,1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/boot\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"sourcelockdyn_dtreebi_butto\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[5,0],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/lib\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"endinsica\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x7144C273\",\"timesPatched\":0,\"hide\":false},\"0x32483564\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/home\",\"user\":\"root\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"lhightmidtree\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"_end_code\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[1,0,3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr\",\"user\":\"root\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"awake\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x32483564\",\"timesPatched\":0,\"hide\":false},\"0x2886C5E5\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0,1],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"n_lend_c\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0,3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"alresulttextsirectiv\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"trinse\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[2],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/etc\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"bl_treethiscompathbaseoncolor_butto\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"ieldi\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x2886C5E5\",\"timesPatched\":0,\"hide\":false},\"0x7025356F\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"throw\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[1,5,0],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/lib\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"tinenum\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x7025356F\",\"timesPatched\":0,\"hide\":false},\"0x3CA034C6\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3,0],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"selectsetactionnametel\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[5],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"breat\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[5,0],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/bin\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"code\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x3CA034C6\",\"timesPatched\":0,\"hide\":true},\"0x3A14C60C\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"valuesrep\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/sys\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"valizex\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"tslconnextctotal\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"selenb\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"itiony\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x3A14C60C\",\"timesPatched\":0,\"hide\":true},\"0x1367C4FB\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[5,2],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/home\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"opplaye\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[5],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"eadiv\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"constreet\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,2,5],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/sys\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"olor_titleteli\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"hiscoundoubledquot\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x1367C4FB\",\"timesPatched\":0,\"hide\":true},\"0x75613C03\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[1,2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"ne\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,5],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"inser\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"slickstartializedelc\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[5],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"movel_flush_\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[5],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"_headdpar\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x75613C03\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":2}",
        "ID": "9e52f01e4fe3d824a53856d3b9446459",
        "refCount": 56
    },
    {
        "Content": "{\"listaZonaMem\":{\"0x6B58DACB\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[5,1],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/home\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"espace\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[1,2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/bin\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"roybuttonimagecompatic_tree\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x6B58DACB\",\"timesPatched\":0,\"hide\":false},\"0x3952D85D\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[2,5],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/bin\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"srepz_\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/lib\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"nresult++\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x3952D85D\",\"timesPatched\":0,\"hide\":true},\"0x1C555C02\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/bin\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"uiteralse\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/root\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"dresultte\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x1C555C02\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":3}",
        "ID": "a57c7893824085bdc88ccb962130085f",
        "refCount": 11
    },
    {
        "Content": "{\"listaZonaMem\":{\"0x6202214E\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0,3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"turnal\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[1,0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"iscan_end\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"using\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/etc\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"unctionleven\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x6202214E\",\"timesPatched\":0,\"hide\":false},\"0x243488B2\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[2,1],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"essequaredp\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr/bin\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"stvalfunct\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,3],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"aterators\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x243488B2\",\"timesPatched\":0,\"hide\":true},\"0x507188DB\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"tactedcall0f\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,2,0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/boot\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"bitstrinformancessag\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x507188DB\",\"timesPatched\":0,\"hide\":true},\"0x1FDF345B\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"frequeuetobject\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3,0],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/root\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"closefaultaddundo\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x1FDF345B\",\"timesPatched\":0,\"hide\":true},\"0x59C728D9\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[2,5],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr/bin\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"square\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/etc\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"esultnam\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x59C728D9\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":6}",
        "ID": "45c0bc010ee2f88f1f0ac5e06de31a10",
        "refCount": 1
    },
    {
        "Content": "root:adfc2c84285880f6a5655f13c94ee491\n",
        "ID": "653fb119b8b083e8f42ff978f0b76448",
        "refCount": 1
    },
    {
        "Content": "root:10f694389ffe9c2d72279ff582b957c7\n",
        "ID": "aaeb7d2960b68c99cc788d9758bc46a5",
        "refCount": 1
    },
    {
        "Content": "root:e0353ab3cc6948fcbfe78dee0ff42a70\n",
        "ID": "4631be96a8ca0ef310b077924c59cd1f",
        "refCount": 1
    },
    {
        "Content": "{\"listaZonaMem\":{\"0x687B17E2\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0,5,2],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"ches++\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0,2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr/bin\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"getcolor_buffecttrank\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[5,2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"ishdonenum\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x687B17E2\",\"timesPatched\":0,\"hide\":false},\"0x247BEAE9\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"viewporttesetdatebuttonc\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/sys\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"ypeopequ\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"resultstorrunte\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[1,2],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"efaultstorschemechangeund\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x247BEAE9\",\"timesPatched\":0,\"hide\":false},\"0x3B8421DB\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0,1],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"root\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"thistval\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr/bin\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"becode\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/etc\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"end_bitsdyn_dtreelinentim\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x3B8421DB\",\"timesPatched\":0,\"hide\":true},\"0x499DBB95\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/bin\",\"user\":\"root\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"extefonternalcontextsl\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[5],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/usr/bin\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"else\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/lib\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"ast_flateg\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3,0],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"onclicitr\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,3,0],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/sys\",\"user\":\"root\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"narykeycopya\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x499DBB95\",\"timesPatched\":0,\"hide\":true},\"0xDAAC360\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[1,0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"strinserin\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/sys\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"sabledquotequeuetok\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/root\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"unitialightedou\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2,5],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/lib\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"titlengthcodec\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0xDAAC360\",\"timesPatched\":0,\"hide\":true},\"0x5ECF7628\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0,2],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/bin\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"sion++\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,3,0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/root\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"table\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[5,2],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/etc\",\"user\":\"root\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"rlaydelanchor\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,3,5],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"ding_di\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3,1,0],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"alues\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x5ECF7628\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":0}",
        "ID": "b76529c43d87623969b0800f1f90d5bc",
        "refCount": 9
    },
    {
        "Content": "root:d79852bc93b47031b176eb15068944f0\n",
        "ID": "2769177b44f7306ae6cae6d5d5af5f8f",
        "refCount": 1
    },
    {
        "Content": "root:46d0fe11c59376fab6b1c686d27c24ff\n",
        "ID": "e3445c853e24f0695192cb35e248080a",
        "refCount": 1
    },
    {
        "Content": "root:e464f52dcb978889c8a485db2b255f49\n",
        "ID": "13de068b6d0b62e28befe171a0c93327",
        "refCount": 1
    },
    {
        "Content": "{\"listaZonaMem\":{\"0xA7A9A69\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[5,0],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"_matc\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0,1,5],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"codeenoveat\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"eltextbuttonclickinvokethisc\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/home\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"treec2\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0,5,3],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"vasgroundostingsupdatepoint\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0xA7A9A69\",\"timesPatched\":0,\"hide\":false},\"0x7819D0B\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/lib\",\"user\":\"root\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"etreethistatic_lengthofa\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"interatemoutilcloselancesstact\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3,5],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"euetonback\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,2],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"opequar\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,1,3],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/root\",\"user\":\"root\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"dopos\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x7819D0B\",\"timesPatched\":0,\"hide\":true},\"0x669BC0BD\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/boot\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"last_litextu\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3,5],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"eonclosebackundoundth\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[5,3],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/lib\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"lenb\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,1,3],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"ettexti\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"elects\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x669BC0BD\",\"timesPatched\":0,\"hide\":true},\"0x660E2CC\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"asforwar\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2,1,5],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"match\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x660E2CC\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":1}",
        "ID": "9082e4eecf1503d6da217366cb6559ff",
        "refCount": 5
    },
    {
        "Content": "root:7b27118525bb52a63a3255169dc54cad\n",
        "ID": "464f0cc7d082ee3c7ca771d44258c36b",
        "refCount": 1
    },
    {
        "Content": "root:460b7a7925e87e4f36ca84bf8d01961e\n",
        "ID": "de19c2211a779238d9953f5386c3657e",
        "refCount": 1
    },
    {
        "Content": "root:15d866b722c8e9b997fd39aba35460f1\n",
        "ID": "a9590a83851ec98de5bdaaff0b6bf8b7",
        "refCount": 1
    },
    {
        "Content": "root:a0f99153fe6b106d02c7faece1f48f25\n",
        "ID": "3a6174f32c29601a8ea18fc6c18f39b1",
        "refCount": 1
    },
    {
        "Content": "root:632bc4e9109504f2b81c361a09233f6b\n",
        "ID": "595127686fef4bcd6e96d407e4113c4f",
        "refCount": 1
    },
    {
        "Content": "root:c6ca08ec26bb9ae886a2d83088d68a14\n",
        "ID": "1394a823e88be3ca0e6793fa98714032",
        "refCount": 1
    },
    {
        "Content": "root:e08a6fb875913aca03b7b357e099a35c\n",
        "ID": "fd721c12b6ed774189e6300c04fdb3f9",
        "refCount": 1
    },
    {
        "Content": "root:374cd5752c160011ee68a180b69d1f4d\n",
        "ID": "cee296fa176ea734a935ed9ef0ceeb34",
        "refCount": 1
    },
    {
        "Content": "root:6ef981a293d065e288f67ad3b20e8822\n",
        "ID": "16ec3209813f86656c6fc55bd5195bfc",
        "refCount": 1
    },
    {
        "Content": "root:13768a4fb49ae48e765dc223f7dc9f30\n",
        "ID": "dff0154dd7674991db9485e3f9323a88",
        "refCount": 1
    },
    {
        "Content": "root:5c3af579dd25a287d3436160047e67d7\n",
        "ID": "c29626d111f5e952f367939c659f4724",
        "refCount": 1
    },
    {
        "Content": "root:f0809e33521bc93c62c4e5c60788dba6\n",
        "ID": "c184f207beb47acd86c244349a85bd5a",
        "refCount": 1
    },
    {
        "Content": "root:7e171b6e59c8696e0d178b53120ce0a5\n",
        "ID": "5dd2a16e06258501a226aba2972f6aee",
        "refCount": 1
    },
    {
        "Content": "root:79b7cdcd14db14e9cb498f1793817d69\n",
        "ID": "3c9e4482388ab2329df39f0ea2732799",
        "refCount": 1
    },
    {
        "Content": "{\"listaZonaMem\":{\"0x69D883D\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[5,0,1],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/bin\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"lighlightmidthiscanvas\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0,3],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/sys\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"fig\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[2],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"cesdyn_tr\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[1],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"esingbuttonsertypebotto\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x69D883D\",\"timesPatched\":0,\"hide\":false},\"0x66F18624\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[1,5],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"need\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/boot\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"pres\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x66F18624\",\"timesPatched\":0,\"hide\":true},\"0x7C1766B7\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"oken\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/root\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"singsupda\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2,1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/home\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"hile\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x7C1766B7\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":4}",
        "ID": "a7fa01049ff48478bc021a57bf7a09e1",
        "refCount": 5
    },
    {
        "Content": "root:110450282d8e8466fab3f8555d7631a2\n",
        "ID": "9d896f78dbe68927b49bed6c38ea1593",
        "refCount": 1
    },
    {
        "Content": "root:182bfb98276d94e3d183b492ce6fdd60\n",
        "ID": "67420f8b7850b75f49e6725eb6b5fdc8",
        "refCount": 1
    },
    {
        "Content": "root:9fce637a0d7943cc94fce78366441db5\n",
        "ID": "350657910268527f7200753ff1120702",
        "refCount": 1
    },
    {
        "Content": "root:bc92c95bfe7b15607eac90330de98f61\n",
        "ID": "8e047b43042a9789704eb25dba8f9b29",
        "refCount": 1
    },
    {
        "Content": "root:ba8e3d4c873579cc5d0f40e320d780dc\n",
        "ID": "3b31bf34f964339a1eedddaf196c4990",
        "refCount": 1
    },
    {
        "Content": "root:72e31e669bedaf1220f4cc2ec6aab49a\n",
        "ID": "32df636db5b4f9ac8ae34324422d47cb",
        "refCount": 1
    },
    {
        "Content": "root:b506bd9be9a31fc04f68559f25c2a5a7\n",
        "ID": "e9cc88ca77766fc94de3f9a9de1eaf65",
        "refCount": 1
    },
    {
        "Content": "root:009939e3fba696cc940eb89798f0e942\n",
        "ID": "a13ed7915e46e3cdd42248cd4709068e",
        "refCount": 1
    },
    {
        "Content": "root:ccb0317a38a5d38b5ef8802f34f92505\n",
        "ID": "f9dff2acbfa6327b73d2c7cc5b4009cf",
        "refCount": 1
    },
    {
        "Content": "",
        "ID": "d41d8cd98f00b204e9800998ecf8427e",
        "refCount": 86
    },
    {
        "Content": "{\"listaZonaMem\":{\"0x3504A45\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/sys\",\"user\":\"root\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"kipwhile\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[1,0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/home\",\"user\":\"root\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"curremodelte\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0,3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"sultnamema\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[1,2],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"or_titleteformsionaryv\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"iewportmsbint\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x3504A45\",\"timesPatched\":0,\"hide\":false},\"0x49C132EF\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[2],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"reec2\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[2],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"textctored\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3,0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"opos++\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[1,0,2],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"retoke\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x49C132EF\",\"timesPatched\":0,\"hide\":false},\"0x36657FBB\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[1,0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"aplush\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0,1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/etc\",\"user\":\"root\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"olon\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x36657FBB\",\"timesPatched\":0,\"hide\":false},\"0x570AE7B1\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"ontextpu\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[0,1,2],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"part++\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x570AE7B1\",\"timesPatched\":0,\"hide\":false},\"0x18713042\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"closeevent_onl\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"intextvmyieldingb\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2,1,0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"inesizedeltextpos++\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x18713042\",\"timesPatched\":0,\"hide\":true},\"0x68F75CBA\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"hored\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"returnalcodecflush_sizela\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2,0],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr\",\"user\":\"root\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"ateractive\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x68F75CBA\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":11}",
        "ID": "f8f51b0d29513325fd17b082383bdc70",
        "refCount": 22
    },
    {
        "Content": "root:ca0e04a250933fed7a93a3bd5c32ebae\nayecue:ca0e04a250933fed7a93a3bd5c32ebae",
        "ID": "4825cff93449be44cd590c1f2cda07a0",
        "refCount": 1
    },
    {
        "Content": "{\"listaZonaMem\":{\"0x61ED787B\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[1,0,2],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/root\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"orewind\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[2,0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"ivarven\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"data\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[1,3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"text\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x61ED787B\",\"timesPatched\":0,\"hide\":false},\"0x656EFA6F\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[2,1],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/home\",\"user\":\"root\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"bofiters\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"revn\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,3],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/home\",\"user\":\"root\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"kdyn_ltr\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/root\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"eturna\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x656EFA6F\",\"timesPatched\":0,\"hide\":true},\"0x6D6DE813\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr\",\"user\":\"root\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"eatemplayedvaluesremov\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,2],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/sys\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"lizelineselhightmid\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/boot\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"vel_flushpa\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2,1,0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/etc\",\"user\":\"root\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"_lengt\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"donentdat\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x6D6DE813\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":10}",
        "ID": "674fafaca87dd48395a378cebe047693",
        "refCount": 5
    },
    {
        "Content": "//command: airmon\ncryptools = include_lib(\"/lib/crypto.so\")\nif not cryptools then exit(\"Error: Missing crypto library\")\nif params.len > 0 and (params.len != 2 or params[0] == \"-h\" or params[0] == \"--help\") then exit(command_info(\"airmon_usage\"))\n\ncomputer = get_shell.host_computer\nformatOutput = \"Interface Chipset Monitor_Mode\\n\"\nif params.len == 0 then\texit(format_columns(formatOutput + computer.network_devices))\noption = params[0]\ndevice = params[1]\nif option != \"start\" and option != \"stop\" then exit(command_info(\"airmon_usage\"))\n\noutput = cryptools.airmon(option, device)\nif not output then exit(\"airmon: \" + device + \" not found\")\nif typeof(output) == \"string\" then exit(output)\nprint(format_columns(formatOutput + computer.network_devices))",
        "ID": "a7bc2371def5619c36592bb852457119",
        "refCount": 1
    },
    {
        "Content": "//command: aireplay\ncryptools = include_lib(\"/lib/crypto.so\")\nif not cryptools then exit(\"Error: Missing crypto library\")\nif params.len != 4 or params[0] == \"-h\" or params[0] == \"--help\" or params[0] != \"-b\" or params[2] != \"-e\" then exit(command_info(\"aireplay_usage\"))\n\nbssid = params[1]\nessid = params[3]\nresult = cryptools.aireplay(bssid, essid)\nif typeof(result) == \"string\" then exit(result)\n",
        "ID": "8506a9075bd5e29033ab8006e6b1472e",
        "refCount": 1
    },
    {
        "Content": "//command: aircrack\ncryptools = include_lib(\"/lib/crypto.so\")\nif not cryptools then exit(\"Error: Missing crypto library\")\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"aircrack_usage\"))\n\npathFile = params[0]\nfile = get_shell.host_computer.File(pathFile)\nif file == null then exit(\"aircrack: file not found: \"+pathFile)\nif not file.is_binary then exit(\"aircrack: Can't process file. Not valid filecap.\")\t\t\nif not file.has_permission(\"r\") then exit(\"aircrack: permission denied\")\n\nkey = cryptools.aircrack(file.path)\nif key then \n\tprint(\"KEY FOUND! [\" + key + \"]\" )\nelse \n\tprint(\"aircrack: Unable to get the key\" )\nend if\n\n",
        "ID": "7c70661d0254754d679e9f0294efd1ca",
        "refCount": 1
    },
    {
        "Content": "root:d14af3958f6b521ded6a3ce12c0e4eea\n",
        "ID": "a83e37ae93a711a52941faff3240c4ca",
        "refCount": 1
    },
    {
        "Content": "root:0aa55dedf3f92c7eebfd0b241249093b\n",
        "ID": "ec44b60adf14e982c2be22c0a5e3decf",
        "refCount": 1
    },
    {
        "Content": "{\"power\":45,\"numAcks\":31739,\"bssid\":\"3E:69:4F:8A:72:23\",\"essid\":\"Urylandelu\",\"origPublicIp\":\"0.0.0.0\"}",
        "ID": "376099ae00f270242320a2806d4dfacd",
        "refCount": 2
    },
    {
        "Content": "notepadPath = \"/usr/bin/Nodepad.exe\"\nscriptsPath = \"/home/ayecue/scripts\"\nmyShell = get_shell\nscriptFile = Params[0]\nfinalPath = [scriptsPath, scriptFile].join(\"/\")\n\nprint(\"Opening \" + finalPath + \"...\")\nget_myShell.launch(notepadPath, finalPath)",
        "ID": "a02e8a81dddd7ab7a91361c43ca9a927",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"1-1-1990 22:27\",\"puerto\":0,\"file\":\"/usr/bin/openscript\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "0f43288998be2c25f02caff27ca6aabb",
        "refCount": 1
    },
    {
        "Content": "myShell = get_shell\nscriptsPath = \"/home/ayecue/scripts\"\nscriptFile = params[0]\nnotepadPath = \"/usr/bin/Nodepad.exe\"\n\nfinalPath = [scriptsPath, scriptFile + \".txt\"].join(\"/\")\n\nprint(\"Opening \" + finalPath + \"...\")\nget_myShell.launch(notepadPath, finalPath)",
        "ID": "4c6297c3db3ce038e6bd9d7b3d040f83",
        "refCount": 1
    },
    {
        "Content": "myShell = get_shell\nscriptsPath = \"/home/ayecue/scripts\"\nscriptFile = params[0]\nnotepadPath = \"/usr/bin/Nodepad.exe\"\n\nfinalPath = [scriptsPath, scriptFile + \".txt\"].join(\"/\")\n\nprint(\"Opening \" + finalPath + \"...\")\nmyShell.launch(notepadPath, finalPath)",
        "ID": "1672490f180a90beb11608318361b0e3",
        "refCount": 1
    },
    {
        "Content": "myShell = get_shell\nscriptsPath = \"/home/ayecue/scripts\"\nscriptFile = params[0]\nnotepadPath = \"/usr/bin/Notepad.exe\"\n\nfinalPath = [scriptsPath, scriptFile + \".txt\"].join(\"/\")\n\nprint(\"Opening \" + finalPath + \"...\")\nmyShell.launch(notepadPath, finalPath)",
        "ID": "42c8e15f059d93db0b0b8fbf2dfd088a",
        "refCount": 2
    },
    {
        "Content": "device = params[0]\n\nif device == null then\n\tprint(\"Show devices\")\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "1ec4eee1ddc2be61b6ecf3a667a33a97",
        "refCount": 1
    },
    {
        "Content": "print(params.length)\ndevice = params[0]\n\nif device == null then\n\tprint(\"Show devices\")\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "b6868fdf3673ab3fbdf3da0fdcf66064",
        "refCount": 1
    },
    {
        "Content": "print(params.len)\ndevice = params[0]\n\nif device == null then\n\tprint(\"Show devices\")\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "8441862c6035c6e7fff31344be98d0f9",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\n\ndevice = getParam(0)\n\nif device == null then\n\tprint(\"Show devices\")\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "97e5c2e66f13e32a16dfdc3753f4c053",
        "refCount": 1
    },
    {
        "Content": "getParams = include_lib(\"/home/ayecue/scripts/libraries/getParams.txt\")\n\n\ndevice = getParam(0)\n\nif device == null then\n\tprint(\"Show devices\")\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "5b4cebd6682a44f6869bf4bedc48c9f9",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\ndevice = getParam(0)\n\nif device == null then\n\tcrypto.airmon()\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "29a1ac0294f42a51e2907d5faba971f5",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\ndevice = getParam(0)\n\nif device == null then\n\tprint(crypto.airmon())\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "cc17ba3c9740ab88bfe781e2315b2a47",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\ndevice = getParam(0)\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif device == null then\n\tprint(myComputer.network_devices)\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "fbdb74741e95d1fb901e1264a951d4a8",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nshowNetworkDevices = function(computer = get_shell.host_computer)\n\tnetworkDevices = computer.network_devices\n\n\tprint(typeof(networkDevices))\nend function\n\ndevice = getParam(0)\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif device == null then\n\tshowNetworkDevices()\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "ac160857ea83dc1c93341b0d855f1151",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nshowNetworkDevices = function(computer = get_shell.host_computer)\n\tnetworkDevices = computer.network_devices\n\n\tprint(typeof(networkDevices))\nend function\n\ndevice = getParam(0)\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif device == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "42734b3a6129e78587fbcfcc1b56e003",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nshowNetworkDevices = function(computer)\n\tprint(computer.network_devices)\nend function\n\ndevice = getParam(0)\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif device == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "edc18e8e7be52fa507b461ca1f43ace7",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nshowNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tprint(networkDevices, list.len)\n\t\nend function\n\ndevice = getParam(0)\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif device == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "1111d52aeffb1ab661f8af7b6a5fdf82",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nshowNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tprint(networkDevices)\n\tprint(list.len)\n\t\nend function\n\ndevice = getParam(0)\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif device == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "eb043330d301e45b89e53b5c380a0f80",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nshowNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\tprint(\"Error: No network devices found.\")\n\t\treturn\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\tprint(index + \".) \" + list[index])\n\t\tindex = index + 1\n\tend while\nend function\n\ndevice = getParam(0)\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif device == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\nend if",
        "ID": "49e8e734204d096804f0d23474542541",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == false then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\ndeviceIndex = getParam(0)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif deviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\n\ta = getNetworkDeviceByIndex(deviceIndex)\n\tprint(a.name)\nend if",
        "ID": "55139a60a57be71a20e5d6ca8cd5c243",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == false then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\ndeviceIndex = getParam(0)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif deviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\n\ta = getNetworkDeviceByIndex(computer, deviceIndex)\n\tprint(a.name)\nend if",
        "ID": "643816481c971ee7117ee8a36e118d4b",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == false then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\ndeviceIndex = getParam(0)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif deviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\n\ta = getNetworkDeviceByIndex(myComputer, deviceIndex)\n\tprint(a.name)\nend if",
        "ID": "860c5281a965bfe8d9e86e119752f5fe",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tprint(list.hasIndex(networkDeviceIndex))\n\n\tif list.hasIndex(networkDeviceIndex) == false then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\ndeviceIndex = getParam(0)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif deviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\n\ta = getNetworkDeviceByIndex(myComputer, deviceIndex)\n\tprint(a.name)\nend if",
        "ID": "cf2a2d9e7fcdf9e99fc518350f85ca31",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\ndeviceIndex = getParam(0)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif deviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\n\ta = getNetworkDeviceByIndex(myComputer, deviceIndex)\n\tprint(a.name)\nend if",
        "ID": "701be0f5cbf1f48e54e1eff09edbfb50",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tprint(list)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\ndeviceIndex = getParam(0)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif deviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\n\ta = getNetworkDeviceByIndex(myComputer, deviceIndex)\n\tprint(a.name)\nend if",
        "ID": "cb289d7ebf4b6e9471ebe222bcace2a5",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tprint(list)\n\tprint(networkDeviceIndex)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\ndeviceIndex = getParam(0)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif deviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\n\ta = getNetworkDeviceByIndex(myComputer, deviceIndex)\n\tprint(a.name)\nend if",
        "ID": "60ed7b39dbabef6fb370c39c9a668d8b",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list[networkDeviceIndex]\n\n\tprint(device)\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\ndeviceIndex = getParam(0)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif deviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\n\ta = getNetworkDeviceByIndex(myComputer, deviceIndex)\n\tprint(a.name)\nend if",
        "ID": "33faf28e93e7c94e8334e4c6cb1100bc",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[0]\n\n\tprint(device)\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\ndeviceIndex = getParam(0)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif deviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tprint(\"Show something else\")\n\ta = getNetworkDeviceByIndex(myComputer, deviceIndex)\n\tprint(a.name)\nend if",
        "ID": "d84fb020b6a59a6150194e097f3205f9",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDevice.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\tlist = netDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, networkDeviceIndex)\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"Done\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, netDeviceIndex)\n\t\tprint(selectedNetDevice)\n\tend if\nend if",
        "ID": "0dff75231091cd995d278008cf98c0dd",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDevice.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\tlist = netDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"Done\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\t\tprint(selectedNetDevice)\n\tend if\nend if",
        "ID": "dbee0bf357658120a2dd288a3a1acf7b",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDevice.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\tprint(netDevices)\n\tlist = netDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"Done\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\t\tprint(selectedNetDevice)\n\tend if\nend if",
        "ID": "9898117c0d67ee137392f847bf75edcf",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDevice.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"Done\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\t\tprint(selectedNetDevice)\n\tend if\nend if",
        "ID": "8414d56ece5d230a34fb0ba817b9de86",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDeviceString.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"Done\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\t\tprint(selectedNetDevice)\n\tend if\nend if",
        "ID": "064880f19156f5e65214e016cb9c7417",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDeviceString.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function(computer)\n\tfile = computer.File(getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\nmaxAcks = getParam(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tclearAireplayFile(myComputer)\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypo.aircrack(fileCapPath)\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if",
        "ID": "ba98edc09f8e986b65f2c7a0eb505949",
        "refCount": 1
    },
    {
        "Content": "root:54676b65d7ad6fdb0f30a6927dfa0234\n",
        "ID": "225bba5ad12a5b1b3b38176208c38fd6",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDeviceString.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function(computer)\n\tfile = computer.File(getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\nmaxAcks = getParam(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tclearAireplayFile(myComputer)\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if",
        "ID": "5f7e7093e288ec9d3e2f04450a47f0f7",
        "refCount": 1
    },
    {
        "Content": "root:b6f100f62577f410ef3968e7882680c5\n",
        "ID": "ccf23deff3ffab505a0615aa6e11907a",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDeviceString.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function(computer)\n\tfile = computer.File(getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\nmaxAcks = getParam(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\tclearAireplayFile(myComputer)\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if",
        "ID": "624d6d178b1194c9861fd48dd5d6a489",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDeviceString.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function(computer)\n\tfile = computer.File(getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\nmaxAcks = getParam(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tprint(maxAcks)\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\tclearAireplayFile(myComputer)\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if",
        "ID": "591807f71369eafb93e13e8a7b78a757",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[0]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDeviceString.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function(computer)\n\tfile = computer.File(getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\nmaxAcks = getParam(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tprint(maxAcks)\n\t\t\tprint(params)\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\tclearAireplayFile(myComputer)\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if",
        "ID": "70ab0afbd0d02f3864c942dc116a7e34",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDeviceString.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function(computer)\n\tfile = computer.File(getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\nmaxAcks = getParam(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tprint(maxAcks)\n\t\t\tprint(params)\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\tclearAireplayFile(myComputer)\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if",
        "ID": "88c5040e0aef610d79bb3293fb1f6767",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDeviceString.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function(computer)\n\tfile = computer.File(getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\nmaxAcks = getParam(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\tclearAireplayFile(myComputer)\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if",
        "ID": "738f314f06811e3b37aab7d544c62153",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\treturn null\nend function\n\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDeviceString.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function(computer)\n\tfile = computer.File(getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\nmaxAcks = getParam(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\tclearAireplayFile(myComputer)\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if",
        "ID": "2eae862a7fd89b8d153c463bd4603317",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn file\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createPasswordEntryFromColumn(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParams(0, true)\npassword = getParams(1, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(computer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nmyPasswordList.push(createPasswordEntry(key, password))\n\nsavePasswordFile(file, myPasswordList)\n\n",
        "ID": "f40602281ef9a28cf440a8276aca7baf",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn file\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createPasswordEntryFromColumn(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(computer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nmyPasswordList.push(createPasswordEntry(key, password))\n\nsavePasswordFile(file, myPasswordList)\n\n",
        "ID": "a599be0c36153278b0f4f44bf45ee686",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn file\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createPasswordEntryFromColumn(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nmyPasswordList.push(createPasswordEntry(key, password))\n\nsavePasswordFile(file, myPasswordList)\n\n",
        "ID": "4dc8979ddbcf4d320232fd9cc9e35941",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createPasswordEntryFromColumn(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nmyPasswordList.push(createPasswordEntry(key, password))\n\nsavePasswordFile(file, myPasswordList)\n\n",
        "ID": "552eaa3938e6d4666e03a8486a5cdeb7",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(list)\n\n\twhile index < maxIndex\n\t\titem = createPasswordEntryFromColumn(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nmyPasswordList.push(createPasswordEntry(key, password))\n\nsavePasswordFile(file, myPasswordList)\n\n",
        "ID": "12433fc9aec50c331b609e3422e35371",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nmyPasswordList.push(createPasswordEntry(key, password))\n\nsavePasswordFile(file, myPasswordList)\n\n",
        "ID": "ef0d5807fefe8d85c9723b9b896f1799",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nmyPasswordList.push(createPasswordEntry(key, password))\n\nsavePasswordFile(myPasswordFile, myPasswordList)\n\n",
        "ID": "3eb4597be6d46c145ed4061fa51b7e0d",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max - 1)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 2)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max - 1)\n\treturn before + [passwordEntry] + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\noverride = getParam(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tmyPasswordList = setPasswordByKey(myPasswordList, createPasswordEntry(key, password))\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tmyPasswordList.push(createPasswordEntry(key, password))\nend if\n\nsavePasswordFile(myPasswordFile, myPasswordList)\n\n",
        "ID": "2a0c3c00cf2ab0a6ab2713746c1148ee",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max - 1)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 2)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max - 1)\n\treturn before + [passwordEntry] + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\noverride = getParam(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tmyPasswordList = setPasswordByKey(myPasswordList, createPasswordEntry(key, password))\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tmyPasswordList.push(createPasswordEntry(key, password))\nend if\n\nprint(\"Saving password...\")\nsavePasswordFile(myPasswordFile, myPasswordList)\n\n",
        "ID": "3750351b21e3b6f89e22f8698ca60675",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max - 1)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 2)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max - 1)\n\treturn before + [passwordEntry] + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry.password)\n\n",
        "ID": "af208568b0e9aab06c88bf3865131e55",
        "refCount": 2
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max - 1)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 2)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max - 1)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max - 1)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 2)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max - 1)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry.password)\n\n",
        "ID": "84f00a91b215cc0018a52386b07cade5",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max - 1)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 2)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max - 1)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max - 1)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 2)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max - 1)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\noverride = getParam(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tmyPasswordList = setPasswordByKey(myPasswordList, createPasswordEntry(key, password))\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tmyPasswordList.push(createPasswordEntry(key, password))\nend if\n\nprint(\"Saving password...\")\nsavePasswordFile(myPasswordFile, myPasswordList)\n\n",
        "ID": "f4ca7ebdecd6ae26096fe1cc939d606e",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max - 1)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 2)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max - 1)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max - 1)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 2)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max - 1)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nmyPasswordList = removePasswordByKey(myPasswordList, existingEntry)\n\nprint(\"Removing password...\")\nsavePasswordFile(myPasswordFile, myPasswordList)\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Removing was a success\")\nend if\n\nexit(\"Something went wrong\")\n",
        "ID": "44647ce967f86654a20fe4b364b2a280",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max - 1)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 2)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max - 1)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max - 1)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 2)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nmyPasswordList = removePasswordByKey(myPasswordList, existingEntry)\n\nprint(\"Removing password...\")\nsavePasswordFile(myPasswordFile, myPasswordList)\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Removing was a success\")\nend if\n\nexit(\"Something went wrong\")\n",
        "ID": "1781410d6b1b5211e19cdc6589858e96",
        "refCount": 1
    },
    {
        "Content": "test;was\ntest3;f",
        "ID": "0b4dec9d9e106d860275270d04b7d3d1",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nmyPasswordList = removePasswordByKey(myPasswordList, existingEntry)\n\nprint(\"Removing password...\")\nsavePasswordFile(myPasswordFile, myPasswordList)\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Removing was a success\")\nend if\n\nexit(\"Something went wrong\")\n",
        "ID": "578bc0f03bb70868c95c37e4e770948f",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\noverride = getParam(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tmyPasswordList = setPasswordByKey(myPasswordList, createPasswordEntry(key, password))\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tmyPasswordList.push(createPasswordEntry(key, password))\nend if\n\nprint(\"Saving password...\")\nsavePasswordFile(myPasswordFile, myPasswordList)\n\n",
        "ID": "7b25c2c0d4553a94cdbb42dfef63ad2f",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry.password)\n\n",
        "ID": "c040d88da8bfbfef4d8ed3018fa20f3c",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\noverride = getParam(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tmyPasswordList = setPasswordByKey(myPasswordList, createPasswordEntry(key, password))\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tmyPasswordList.push(createPasswordEntry(key, password))\nend if\n\nprint(\"Saving password...\")\nsavePasswordFile(myPasswordFile, myPasswordList)\n\n",
        "ID": "cc9f1bb51ad9d7267da9d72116b0dba9",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry.password)\n\n",
        "ID": "32de1b5cc1e6795c8688665ffe07301c",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nmyPasswordList = removePasswordByKey(myPasswordList, existingEntry)\n\nprint(\"Removing password...\")\nsavePasswordFile(myPasswordFile, myPasswordList)\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Removing was a success\")\nend if\n\nexit(\"Something went wrong\")\n",
        "ID": "9d4babdedcfb40ef3fcecaa55d7b85dc",
        "refCount": 1
    },
    {
        "Content": "test3;mal",
        "ID": "beb99d538c12bb3725b21c219fba2427",
        "refCount": 1
    },
    {
        "Content": "root:79b7cdcd14db14e9cb498f1793817d69\nKorth:3c8da28d97a019e4590f721303bb0d8b\nAbramo:d52e32f3a96a64786814ae9b5279fbe5\nHemannan:21bb5bb51758eab175d4d640334abba0\n",
        "ID": "416598a8b6539cfb3375c845b44512d4",
        "refCount": 1
    },
    {
        "Content": "Korth@aetna.info:f074215cbb57ca55c3e42659b979f527",
        "ID": "141d0b15507d9ca02b2ea1c2f0a49c14",
        "refCount": 1
    },
    {
        "Content": "OalpNfJF:a904e23f06f1bba04162be6e08e2551d",
        "ID": "a230e9688307741858e5b80ac93de487",
        "refCount": 1
    },
    {
        "Content": "Abramo@forthwestel.org:5500920ff225833b79a8fec0c73e725e",
        "ID": "8f254180cd9b3fb376ba14b9fd16f784",
        "refCount": 1
    },
    {
        "Content": "V7HOVypV:17221fc7fe483e691d484f1b31f535ea",
        "ID": "023ebb97685574d111d9f2efc7a5821d",
        "refCount": 1
    },
    {
        "Content": "Hemannan@borage.net:b53af759a47a71cc1c77740d64f444fc",
        "ID": "6d8e037e83706cfccb1925612bb3caab",
        "refCount": 1
    },
    {
        "Content": "5VIAvXLS:4edd8ba553f93c346219a158b56f5396",
        "ID": "6ecab6b481a273f424fd88c6ee70b735",
        "refCount": 1
    },
    {
        "Content": "<!DOCTYPE html>\n<style type='text/css'>\n\n  h1 { font-size: 40px; text-align: center}\n  body { font: 12px Helvetica, sans-serif; color: #333; margin:0; overflow-y:auto; height:100%; }\n  .btn {\n    background-color: #444444FF;\n    border: 1px solid #B2B2B2FF;\n    color: #C1C1C1FF;\n    padding: 8px 8px;\n    font-size: 18;    \n    width: 130px;\n  }\n  .btn-group button:hover {\n    background-color: #690000FF;\n  }\n\n  article { display: block; text-align: left; width: 600px; margin: 0 auto; } \n\n  html{\n    background-color: white;\n    height:100%;\n  }\n  .mainText{\n    text-align: center;\n    padding: 10px;\n  }\n\n  .logo{\n    text-align: right;    \n    position: absolute;\n    right: 10px;\n    font-size: 25px;\n    \n  }\n  img{\n    display: block;\n    margin: 0 auto;\n  }\n</style>\n\n</div>\n<div style=\"background-color:#A92222FF;color:white;padding:11px;\">\n  <div class=\"logo\">Rinions</div>\n<div class=\"btn-group\">\n  <button type=\"button\" class=\"btn btn-primary\" id=\"Home\">Main</button>\n  <button type=\"button\" class=\"btn btn-primary\" id=\"RegisterMail\">Email services</button>\n  <button type=\"button\" class=\"btn btn-primary\">News</button>    \n  \n</div>\n\n</div>\n\n<article>\n    <div class=\"mainText\">    \n        <p>\nWelcome, we are Rinions, a company that offers services through the network.<br><br>\n\nWe currently have a mail service available, it's totally free.<br>\nRegister now!<br><br>\n    </p>\n           <img src=\"email_alter.png\" width=\"85\" height=\"85\" align=\"center\">\n    </div> \n</article>\n",
        "ID": "a614a6e014ca453b99c4e164022e8aef",
        "refCount": 1
    },
    {
        "Content": "192.168.1.2:3306",
        "ID": "ae766a7812fa081a2b22616915708d71",
        "refCount": 1
    },
    {
        "Content": "rinions.net",
        "ID": "4ac7accd03b76b4df05aaf00f1ba60fd",
        "refCount": 1
    },
    {
        "Content": "{\n  \"encryption_enabled\": false,\n  \"message_encrypted_conn\": true,\n  \"path_enc\": \"/server/encode.src\",\n  \"path_dec\": \"/server/decode.bin\"\n}",
        "ID": "1813424a1cc016e5a8e8927a66ebf727",
        "refCount": 8
    },
    {
        "Content": "Encode = function(password)\n    caesar = function(pass, type)\n        nr = pass.len%10\n        crypt = function(char, nr, type)\n            if type == \"enc\" then return char+nr\n            if type == \"dec\" then return char-nr\n        end function    \n        out = []\n        for i in range(0, pass.len-1)\n            c = pass[i].code    \n            if c >= 48 and c <= 57 then \n                c = crypt(c, nr, type)\n                if c < 48 then c = c+10\n                if c > 57 then c = c-10    \n            else if c >= 65 and c <= 90 then \n                c = crypt(c, nr, type)\n                if c < 65 then c = c+26\n                if c > 90 then c = c-26\n            else if c >= 97 and c <= 122 then \n                c = crypt(c, nr, type)\n                if c < 97 then c = c+26\n                if c > 122 then c = c-26\n            end if        \n            out.push(char(c))\n        end for\n        return out.join(\"\")\n    end function\n    output = caesar(password, \"enc\")\n    return output\nend function",
        "ID": "beb3da14d995c416a4626fcc40d7bc6d",
        "refCount": 8
    },
    {
        "Content": "Decode = function(password)\n    caesar = function(pass, type)\n        nr = pass.len%10\n        crypt = function(char, nr, type)\n            if type == \"enc\" then return char+nr\n            if type == \"dec\" then return char-nr\n        end function    \n        out = []\n        for i in range(0, pass.len-1)\n            c = pass[i].code    \n            if c >= 48 and c <= 57 then \n                c = crypt(c, nr, type)\n                if c < 48 then c = c+10\n                if c > 57 then c = c-10    \n            else if c >= 65 and c <= 90 then \n                c = crypt(c, nr, type)\n                if c < 65 then c = c+26\n                if c > 90 then c = c-26\n            else if c >= 97 and c <= 122 then \n                c = crypt(c, nr, type)\n                if c < 97 then c = c+26\n                if c > 122 then c = c-26\n            end if        \n            out.push(char(c))\n        end for\n        return out.join(\"\")\n    end function\n    output = caesar(password, \"dec\")\n    return output\nend function",
        "ID": "35305b74bb64611340ef9461a132222b",
        "refCount": 8
    },
    {
        "Content": "<?xml version=\"1.0\" encoding=\"utf-16\"?>\n<ContentFichas xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>177932464</telefono>\n    <mailAddress>Bertyles@orterpub.org</mailAddress>\n    <faceParts>Hombre/Base_b;Hombre/Ears_b;Hombre/Eyes_d;Hombre/Hair_a;Hombre/Nose_b;Hombre/Mouth_d;Hombre/Neck_b;Accesorios/scar2</faceParts>\n    <faceScales>-1.032716,1.090312,0,0;-1.032716,0.9251982,0,0;-0.8777555,0.9904329,0,-0.01088451;-1.032716,0.9864591,0,0;-0.7911751,0.8179042,0,0.4411753;-1.084692,0.9724281,0,-1.119623;-1.032716,1,0,0;-1.032716,1.090312,0,0</faceScales>\n    <nombreCompleto>Hastings Bertyles</nombreCompleto>\n    <edad>28</edad>\n    <horario>10:15 - 16:45</horario>\n    <idPersona>92907839-11f9-4072-ab73-43c4017c23e6</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>482719112</telefono>\n    <mailAddress>Korth@aetna.info</mailAddress>\n    <faceParts>Mujer/Base_a;Mujer/Ears_a;Mujer/Eyes_c;Mujer/Hair_b;Mujer/Nose_b;Mujer/Mouth_c;Mujer/Neck_c;Accesorios/scar</faceParts>\n    <faceScales>1.033277,1.076994,0,0;1.033277,1.164131,0,0;1.03839,0.8571241,0,-0.2487143;1.033277,0.9734848,0,0;0.8195248,1.032212,0,0.08636955;0.9934202,0.8670726,0,0.2368187;1.033277,1,0,0;1.033277,1.076994,0,0</faceScales>\n    <nombreCompleto>Raf Korth</nombreCompleto>\n    <edad>62</edad>\n    <horario>08:30 - 15:00</horario>\n    <idPersona>6187bb78-6c80-4547-89e3-e330cfd29094</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>178181211</telefono>\n    <mailAddress>Abramo@forthwestel.org</mailAddress>\n    <faceParts>Mujer/Base_c;Mujer/Ears_b;Mujer/Eyes_a;Mujer/Hair_c;Mujer/Nose_c;Mujer/Mouth_a;Mujer/Neck_c;Accesorios/glasses</faceParts>\n    <faceScales>-1.022943,1.00816,0,0;-1.022943,1.111819,0,0;-1.067327,1.090445,0,0.6944446;-1.022943,0.9674754,0,0;-0.7639646,0.7548873,0,-0.6070189;-1.079019,0.8632796,0,-2.348534;-1.022943,1,0,0;-1.022943,1.00816,0,0</faceScales>\n    <nombreCompleto>Morgan Abramo</nombreCompleto>\n    <edad>31</edad>\n    <horario>07:30 - 14:00</horario>\n    <idPersona>2f0bebba-0412-45f2-95b4-97130917c9f3</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>667734414</telefono>\n    <mailAddress>Hemannan@borage.net</mailAddress>\n    <faceParts>Mujer/Base_a;Mujer/Ears_b;Mujer/Eyes_a;Mujer/Hair_b;Mujer/Nose_b;Mujer/Mouth_b;Mujer/Neck_b;Accesorios/glasses;Accesorios/scar2</faceParts>\n    <faceScales>1.011296,1.005301,0,0;1.011296,0.9882993,0,0;1.01879,1.037869,0,0.2090105;1.011296,0.9619062,0,0;0.9708498,0.9672849,0,0.6301749;0.6837046,0.9235972,0,0.9127856;1.011296,1,0,0;1.011296,1.005301,0,0;1.011296,1.005301,0,0</faceScales>\n    <nombreCompleto>Vita Hemannan</nombreCompleto>\n    <edad>22</edad>\n    <horario>06:30 - 13:00</horario>\n    <idPersona>54cbcb71-fa79-4956-b6cc-3f40c158351a</idPersona>\n    <incidencias />\n  </Ficha>\n</ContentFichas>",
        "ID": "90d1506fc604a0e7cfdbe3871439180d",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"112.58.71.88\",\"fecha\":\"4-1-1990 08:21\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "24b0e98510d5594581125cbaa805d66e",
        "refCount": 1
    },
    {
        "Content": "root:cd8c618d2d8b2b35c7b6f761b2907101\n",
        "ID": "56dc19d2b533513c1d565812a1723103",
        "refCount": 1
    },
    {
        "Content": "root:5bb7fd73f77c78ecab4977f51395d9ec\n",
        "ID": "756711da65f030d5f990a139e90daa96",
        "refCount": 1
    },
    {
        "Content": "root:5bb7fd73f77c78ecab4977f51395d9ec\nNersteini:d77f29328f9c2f22af65647f19fa55ea\nLiannisti:57153d60d3d447b2b00fe53d813e85bb\nEsenargyr:bbec4e09c4b020a7c18eb330d952542a\n",
        "ID": "25d3029991260b1a0d837a69841196fd",
        "refCount": 1
    },
    {
        "Content": "Nersteini@nixtern.net:d93591bdf7860e1e4ee2fca799911215",
        "ID": "f61408c74ac0976882bdb11a709dbe81",
        "refCount": 2
    },
    {
        "Content": "XuKwLtik:b3ad052465f84313b14697a5c2f8994e",
        "ID": "496fb7f6035afd43c9502301f52949c7",
        "refCount": 2
    },
    {
        "Content": "Liannisti@usecomf.info:26c6fec90f5403d14a1ed2aabf35c935",
        "ID": "9bf99de97f08bab5dc24f0f0c128a5a9",
        "refCount": 1
    },
    {
        "Content": "6hdAMTy2:9d4fba86d95b8bc859d0e5dfd3b070b2",
        "ID": "b85ced8c69fc144465856debb4cd5f29",
        "refCount": 1
    },
    {
        "Content": "Esenargyr@nashlanda.com:87bcd267609127a4d35b2af5d1f145ab",
        "ID": "c5288d99832905ece61b57d3d0af498f",
        "refCount": 1
    },
    {
        "Content": "28vRUbvV:07d028e97fea80dc4b3a8477557b5cc2",
        "ID": "97851bcc3a4b37feb0de534ebe08cfcc",
        "refCount": 1
    },
    {
        "Content": "ayecue@rinions.net:687e11060822a882f0df6e7626d2411f",
        "ID": "1ee9e20c381ca5e21f64081aedca48fa",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ndoImports = function(fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != -1\n\t\timport = slice(fileContent, index, endIndex)\n\n\t\tprint(import)\n\n\t\tfileContent = replace(import, \"\")\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\nend function\n\nname = getParam(0, true)\n\nextension = \"txt\"\nscriptFile = name + \".\" + extension\n\n\nuser = active_user\nscriptFolder = \"/home/\" + user + \"/scripts\"\n\nfullPath = [scriptFolder, scriptFile].join(\"/\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(fullPath)\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(content)\n",
        "ID": "009baff0b2b12b725208fc519f07d88b",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ndoImports = function(fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != -1\n\t\timport = slice(fileContent, index, endIndex)\n\n\t\tprint(import)\n\n\t\tfileContent = fileContent.replace(import, \"\")\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\nend function\n\nname = getParam(0, true)\n\nextension = \"txt\"\nscriptFile = name + \".\" + extension\n\n\nuser = active_user\nscriptFolder = \"/home/\" + user + \"/scripts\"\n\nfullPath = [scriptFolder, scriptFile].join(\"/\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(fullPath)\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(content)\n",
        "ID": "b929801969d9b063533f1bb760692b5d",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ndoImports = function(fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex)\n\n\t\tfileContent = fileContent.replace(import, \"\")\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\nend function\n\nname = getParam(0, true)\n\nextension = \"txt\"\nscriptFile = name + \".\" + extension\n\n\nuser = active_user\nscriptFolder = \"/home/\" + user + \"/scripts\"\n\nfullPath = [scriptFolder, scriptFile].join(\"/\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(fullPath)\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(content)\n",
        "ID": "37d29e23627fea50ff96a9f46089bbbf",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ndoImports = function(fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex)\n\n\t\tprint(import)\n\n\t\tfileContent = fileContent.replace(import, \"\")\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\nend function\n\nname = getParam(0, true)\n\nextension = \"txt\"\nscriptFile = name + \".\" + extension\n\n\nuser = active_user\nscriptFolder = \"/home/\" + user + \"/scripts\"\n\nfullPath = [scriptFolder, scriptFile].join(\"/\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(fullPath)\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(content)\n",
        "ID": "7e44d7d1b73e8fdaf02a9f7288dbce62",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex)\n\t\tparsed = import.split(\" \")\n\t\tpath = parsed[1]\n\n\t\timportFilePath = [getScriptFolder(), path + \".\" + getExtension()].join(\"/\")\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tfileContent = fileContent.replace(import, \"\")\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nfullPath = [getScriptFolder(), scriptFile].join(\"/\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(fullPath)\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(computer, content)\n",
        "ID": "597be8cf3ff4a49aef20d0e7d39e4f05",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex)\n\t\tparsed = import.split(\" \")\n\t\tpath = parsed[1]\n\n\t\timportFilePath = [getScriptFolder(), path + \".\" + getExtension()].join(\"/\")\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tfileContent = fileContent.replace(import, \"\")\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nfullPath = [getScriptFolder(), scriptFile].join(\"/\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(fullPath)\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n",
        "ID": "c739a63240c2b235104edde9d5ce547e",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex)\n\t\tparsed = import.split(\" \")\n\t\tpath = parsed[1]\n\n\t\timportFilePath = [getScriptFolder(), path + \".\" + getExtension()].join(\"/\")\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\tfileContent = fileContent.replace(import, \"\")\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nfullPath = [getScriptFolder(), scriptFile].join(\"/\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(fullPath)\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n",
        "ID": "db0fda79f4f5e815d7410cf4a54384ba",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len)\n\n\t\timportFilePath = [getScriptFolder(), path + \".\" + getExtension()].join(\"/\")\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nfullPath = [getScriptFolder(), scriptFile].join(\"/\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(fullPath)\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n",
        "ID": "371734299ac26ea943bc3b918df7e692",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = [getScriptFolder(), path + \".\" + getExtension()].join(\"/\")\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nfullPath = [getScriptFolder(), scriptFile].join(\"/\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(fullPath)\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n",
        "ID": "34e87c6b1bbd79aa20ca2e1a241d4315",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = [getScriptFolder(), path + \".\" + getExtension()].join(\"/\")\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nfullPath = [getScriptFolder(), scriptFile].join(\"/\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(fullPath)\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n\nprint(content)\n",
        "ID": "b308b8e90cfa41c12b6fecc30093663d",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\npathJoin = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = pathJoin(getScriptFolder(), path + \".\" + getExtension())\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(pathJoin(getScriptFolder(), scriptFile))\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n\nnewFile = createFile(computer, getScriptFolder(), scriptFile + \".tmp\")\n\nmyShell.build(pathJoin(getScriptFolder(), scriptFile + \".tmp\"), getBinFolder())\n\nnewFile.delete\n\nexit(\"Done compiling...\")\n\n\n",
        "ID": "531961eca1b21b98504de767c1769030",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\npathJoin = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = pathJoin(getScriptFolder(), path + \".\" + getExtension())\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(pathJoin(getScriptFolder(), scriptFile))\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n\nnewFile = createFile(myComputer, getScriptFolder(), scriptFile + \".tmp\")\n\nmyShell.build(pathJoin(getScriptFolder(), scriptFile + \".tmp\"), getBinFolder())\n\nnewFile.delete\n\nexit(\"Done compiling...\")\n\n\n",
        "ID": "66ed7df9a831fe266220e145ea17f36b",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\npathJoin = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = pathJoin(getScriptFolder(), path + \".\" + getExtension())\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(pathJoin(getScriptFolder(), scriptFile))\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n\nnewFile = createFile(myComputer, getScriptFolder(), scriptFile + \".tmp\")\n\nnewFile.set_content(content)\n\nprint(\"Building in \" + getBinFolder() + \"...\")\n\nmyShell.build(pathJoin(getScriptFolder(), scriptFile + \".tmp\"), getBinFolder())\n\nnewFile.delete\n\nexit(\"Done compiling...\")\n\n\n",
        "ID": "35d82ea7cb97fe93ca2ebad40a13a775",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\npathJoin = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = pathJoin(getScriptFolder(), path + \".\" + getExtension())\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(pathJoin(getScriptFolder(), scriptFile))\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n\nnewFile = createFile(myComputer, getScriptFolder(), name + \".tmp\")\n\nnewFile.set_content(content)\n\nprint(\"Building in \" + getBinFolder() + \"...\")\n\nmyShell.build(pathJoin(getScriptFolder(), name + \".tmp\"), getBinFolder())\n\nnewFile.delete\n\nexit(\"Done compiling...\")\n\n\n",
        "ID": "e435648ba7856378da72513b93418bd4",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetTempFolder = function()\n\treturn \"/var\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\npathJoin = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = pathJoin(getScriptFolder(), path + \".\" + getExtension())\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(pathJoin(getScriptFolder(), scriptFile))\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n\nnewFile = createFile(myComputer, getTempFolder(), name + \".tmp\")\n\nnewFile.set_content(content)\n\nprint(\"Building in \" + getBinFolder() + \"...\")\n\nmyShell.build(pathJoin(getTempFolder(), name + \".tmp\"), getBinFolder())\n\nnewFile.delete\n\nexit(\"Done compiling...\")\n\n\n",
        "ID": "a50d88557a5317860c1e533e21e26374",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetTempFolder = function()\n\treturn \"/var\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\npathJoin = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = pathJoin(getScriptFolder(), path + \".\" + getExtension())\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(pathJoin(getScriptFolder(), scriptFile))\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n\nnewFile = createFile(myComputer, getTempFolder(), name + \".tmp\")\n\nif newFile == null then\n\texit(\"Unable to create file...\")\nend if\n\nnewFile.set_content(content)\n\nprint(\"Building in \" + getBinFolder() + \"...\")\n\nmyShell.build(pathJoin(getTempFolder(), name + \".tmp\"), getBinFolder())\n\nnewFile.delete\n\nexit(\"Done compiling...\")\n\n\n",
        "ID": "79ba1ab05c1134c6ef83e332cff6f95d",
        "refCount": 1
    },
    {
        "Content": "getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\ngetTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\ngetExtension = function()\n\treturn \"txt\"\nend function\n\ngetBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\npathJoin = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\ndoImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = pathJoin(getScriptFolder(), path + \".\" + getExtension())\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nname = getParam(0, true)\n\nscriptFile = name + \".\" + getExtension()\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfile = myComputer.File(pathJoin(getScriptFolder(), scriptFile))\n\nif file == null then\n\texit(\"Cannot find file.\")\nend if\n\ncontent = file.get_content\ncontent = doImports(myComputer, content)\n\nnewFile = createFile(myComputer, getTempFolder(), name + \".tmp\")\n\nif newFile == null then\n\texit(\"Unable to create file...\")\nend if\n\nnewFile.set_content(content)\n\nprint(\"Building in \" + getBinFolder() + \"...\")\n\nmyShell.build(pathJoin(getTempFolder(), name + \".tmp\"), getBinFolder())\n\nnewFile.delete\n\nexit(\"Done compiling...\")\n\n\n",
        "ID": "538a196dad60515f92ca9f91eeeacbda",
        "refCount": 1
    },
    {
        "Content": "getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function(computer)\n\tfile = computer.File(getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function",
        "ID": "c21993fe2ff44392c4f5662b68093d6b",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\ngetParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\nNetworkDevice = {}\n\ncreateNetworkDeviceFromString = function(networkDeviceString)\n\tnetworkDevice = new NetworkDevice\n\tparsed = networkDeviceString.split(\" \")\n\t\n\tnetworkDevice.name = parsed[0]\n\tnetworkDevice.chipset = parsed[1]\n\tnetworkDevice.monitor = parsed[2]\n\n\treturn networkDevice\nend function\n\ngetNetworkDevices = function(computer)\n\tnetworkDevices = computer.network_devices\n\tlist = networkDevices.split(\"\n\")\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetworkDevices = function(computer)\n\tlist = getNetworkDevices(computer)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetworkDeviceByIndex = function(computer, networkDeviceIndex = 0)\n\tlist = getNetworkDevices(computer)\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\nNetDevice = {}\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\ncreateNetDeviceFromString = function(netDeviceString)\n\tnetDevice = new NetDevice\n\tparsed = netDeviceString.split(\" \")\n\t\n\tnetDevice.bssid = parsed[0]\n\tnetDevice.pwr = parsed[1]\n\tnetDevice.essid = parsed[2]\n\n\treturn netDevice\nend function\n\ngetNetDevices = function(computer, networkDevice)\n\tnetDevices = computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nshowNetDevices = function(computer, networkDevice)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\ngetNetDeviceByIndex = function(computer, networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(computer, networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function(computer)\n\tfile = computer.File(getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nnetworkDeviceIndex = getParam(0)\nnetDeviceIndex = getParam(1)\nmaxAcks = getParam(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nif networkDeviceIndex == null then\n\tshowNetworkDevices(myComputer)\nelse\n\tselectedNetworkDevice = getNetworkDeviceByIndex(myComputer, to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tshowNetDevices(myComputer, selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = getNetDeviceByIndex(myComputer, selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\tclearAireplayFile(myComputer)\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if",
        "ID": "cdf94892945f481378db34970f8b8b5e",
        "refCount": 4
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\npassword = getParam(1, true)\noverride = getParam(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tmyPasswordList = setPasswordByKey(myPasswordList, createPasswordEntry(key, password))\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tmyPasswordList.push(createPasswordEntry(key, password))\nend if\n\nprint(\"Saving password...\")\nsavePasswordFile(myPasswordFile, myPasswordList)\n\n",
        "ID": "3e6a2c134d608f290419f810333c3d29",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry.password)\n\n",
        "ID": "55c3b990dad202de415beb2aff0e8a86",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nkey = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nmyPasswordList = removePasswordByKey(myPasswordList, existingEntry)\n\nprint(\"Removing password...\")\nsavePasswordFile(myPasswordFile, myPasswordList)\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = findPasswordByKey(myPasswordList, key)\n\nif existingEntry == null then\n\texit(\"Removing was a success\")\nend if\n\nexit(\"Something went wrong\")\n",
        "ID": "4cbf0dedd1f80f1e88fb981e0bb09ce3",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nlistIndex = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = myPasswordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry[listIndex])\n\n",
        "ID": "0289141ea3135bb59265ca59a8d61808",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nlistIndex = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nprint(myPasswordList)\n\n",
        "ID": "84cf1c708cb4ba93052177e4c59a55a4",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nprint(myPasswordList)\n\n",
        "ID": "5157233576ae90475decbbb5b689a1e4",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nprint(myPasswordList.values)\n\n",
        "ID": "056c45d879103abe53d5673b128aae29",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nlistIndex = getParam(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = myPasswordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry[listIndex].toString())\n\n",
        "ID": "4322715df86e9de3f171ce4698c7677c",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nlistIndex = to_int(getParam(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = myPasswordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry[listIndex].toString())\n\n",
        "ID": "93dd030a76595548ff2d14840aeb20dc",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nlistIndex = to_int(getParam(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = myPasswordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry[listIndex])\n\n",
        "ID": "5711c630c36f03efa10b0c86a2b607fe",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nlistIndex = to_int(getParam(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = myPasswordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry.toString())\n\n",
        "ID": "96775b20c76ea11d6f8fb39e7796b985",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nlistIndex = to_int(getParam(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = myPasswordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry)\n\n",
        "ID": "1e0f7516aad2e8faeb5d17c173a4d0eb",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nlistIndex = to_int(getParam(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = myPasswordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + myPasswordList[listIndex].toString())\n\n",
        "ID": "cc47691f1c0edf2ef0a526ef1aca69f7",
        "refCount": 1
    },
    {
        "Content": "getParam = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\ncreateFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\ngetPasswordFile = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = \"passwords\"\n\tbasePath = [directory, user].join(\"/\")\n\tfullPath = [directory, user, passwordFileName].join(\"/\")\n\n\tpasswordFile = computer.File(fullPath)\n\n\tif passwordFile == null then\n\t\tpasswordFile = createFile(computer, basePath, passwordFileName)\n\tend if\n\n\treturn passwordFile\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\ncreatePasswordEntry = function(key, password)\n\tentry = new PasswordEntry\n\n\tentry.key = key\n\tentry.password = password\n\n\treturn entry\nend function\n\ncreatePasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn createPasswordEntry(parsed[0], parsed[1])\nend function\n\nparsePasswordFile = function(file)\n\tcontent = file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nfindPasswordByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nfindPasswordIndexByKey = function(passwordList, key)\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn -1\nend function\n\nsetPasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(passwordList, 1, max)\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(passwordList, 0, max - 1)\n\t\treturn before + [passwordEntry]\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + [passwordEntry] + after\nend function\n\nremovePasswordByKey = function(passwordList, passwordEntry)\n\tindex = findPasswordIndexByKey(passwordList, passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\treturn slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\treturn slice(passwordList, 0, max - 1)\n\tend if\n\n\tbefore = slice(passwordList, 0, index)\n\tafter = slice(passwordList, index + 1, max)\n\treturn before + after\nend function\n\nsavePasswordFile = function(file, passwordList)\n\tstringList = []\n\tindex = 0\n\tmaxIndex = passwordList.len\n\n\twhile index < maxIndex\n\t\titem = passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tfile.set_content(content)\nend function\n\nlistIndex = to_int(getParam(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nmyPasswordFile = getPasswordFile(myComputer)\nmyPasswordList = parsePasswordFile(myPasswordFile)\n\nexistingEntry = myPasswordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Entry: \" + myPasswordList[listIndex].toString())\n\n",
        "ID": "6b8715ac3061e69c728a210523f95106",
        "refCount": 1
    },
    {
        "Content": "//command: decipher\ncryptools = include_lib(\"/lib/crypto.so\")\nif not cryptools then exit(\"Error: Missing crypto library\")\n\nGetPassword = function(userPass)\n\tif userPass.len != 2 then exit(\"decipher: \" + file.path + \" wrong syntax\")\n\tpassword = cryptools.decipher(userPass[1])\n\treturn password\nend function\n\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"decipher_usage\"))\n\norigFile = params[0]\nfile = get_shell.host_computer.File(origFile)\nif not file then exit(\"decipher: can't find \" + origFile)\nif not file.has_permission(\"r\") then exit(\"can't read file. Permission denied\")\nif file.get_content.len == 0 then exit(\"decipher: no users found\")\n\t\nlines = file.get_content.split(\"\\n\")\npassword = null\nif lines.len == 1 then\n\t\n\tuserPass = lines[0].split(\":\")\n\tpassword = GetPassword(userPass)\nelse\n\tprint(\"Multiple users found.\")\n\tnumLine = 1\n\tfor line in lines\n\t\tif line.len > 0 then\n\t\t\tprint(numLine + \": \" + line)\n\t\t\tnumLine = numLine + 1\n\t\tend if\n\tend for\n\toption = \"\"\n\tinputOk = false\n\twhile( not inputOk )\n\t\toption = user_input(\"Select user: \").to_int\n\t\tif typeof(option) != \"number\" or (option < 1 or option > lines.len) then\n\t\t\tprint(\"Invalid input. Type a valid number\")\n\t\telse \n\t\t\tinputOk = true\n\t\tend if\n\tend while\n\t\t\n\tuserPass = lines[option - 1].split(\":\")\n\tprint(\"Selected user: \" + userPass[0] + \"\\nDeciphering...\")\n\tpassword = GetPassword(userPass)\nend if\n\t\nif not password then exit(\"Can't find password :(\")\nprint(\"password found! => \" + password)\n\t",
        "ID": "c8a5e4c3a63511fdee363cc7b2e0d043",
        "refCount": 1
    },
    {
        "Content": "root:08fe2f395dcef58ac3bf8b934d13b81d\nRaina:bf7e605a167a6d9b964f7ca816d86307\nLissen:7e889e65b24a15c05422eab2a71946d8\nUreralt:6074c6aa3488f3c2dddff2a7ca821aab\n",
        "ID": "4960fe49a5c60cc22be9f651eb56fe5c",
        "refCount": 1
    },
    {
        "Content": "Raina@yerse.info:9f516f478e650e9a4e8d8968d429a5eb",
        "ID": "50e140ec7c7b6d722e403517716b17a2",
        "refCount": 1
    },
    {
        "Content": "NZnhp3j7:9905b5165fcb72b66104d22039271d9b",
        "ID": "2cb1205041e1ed4b605f16f620c247c8",
        "refCount": 1
    },
    {
        "Content": "Lissen@wellab.info:c9990473656b9e724af1c64864dd2299",
        "ID": "a26e51a212b3c3ab8a8c32478a28a042",
        "refCount": 1
    },
    {
        "Content": "SIGBjNv2:33d64693d6e827bf63737fdfc0c8cf11",
        "ID": "09c1b2d7af86a07b9cb6d79902c586df",
        "refCount": 1
    },
    {
        "Content": "Ureralt@namcorp.org:a25eb1417e578cb5e222b8680576f31c",
        "ID": "53342569e976502129554f57b6803bd1",
        "refCount": 1
    },
    {
        "Content": "38AOVmXh:f0049acd3951499d61b0f23667fa9bbc",
        "ID": "f28bcb716073914872e01767d85f2e06",
        "refCount": 1
    },
    {
        "Content": "<!DOCTYPE html>\n<style type='text/css'>\n\nbody { font: 12px Helvetica, sans-serif; margin:0; overflow-y:auto; height:100%; }\n\nhtml{\n\tbackground-color: #607662FF;\n    height:100%;\n    margin:0; overflow-y:auto;\n}\n\n.hackshop { \n    text-align: center;    \n    padding: 100px;\n    padding-top: 25px;\n}\n\n.btn {\n    background-color: #28381EFF;\n    border: 1px solid #B2B2B2FF;\n    color: #C1C1C1FF;\n    padding: 8px 8px;\n    text-align: center;\n    text-decoration: none;\n    display: inline-block;\n    font: 18;\n    width: 130px;\n  }\n\n.btn-sel{\n    background-color: #3D542FFF;\n}\n.btn-group button:hover {\n    background-color: #3D542FFF;\n}\n\n</style>\n<div style=\"background-color:#768E7AFF;color:white;padding:3px;\">\n<div class=\"btn-group\" style=\"text-align: center;\">\n  <button type=\"button\" class=\"btn btn-primary btn-sel\" id=\"Home\">Main</button>\n  <button type=\"button\" class=\"btn btn-primary\" id=\"InformaticaShop\">Shop</button>\n</div>\n</div>\n\n  \n  <div class=\"hackshop\">\n    <img src=\"shop_alter.jpg\" width=\"250\" height=\"145\" align=\"center\">\n    <p style=\"font-size:18px;\">Welcome</p>    \n    <p>\nWe are the best computer store in the network.<br>\nEnter and check our stock! We have the best prices!\n    </p>\n  </div>\n",
        "ID": "cd91e5f1dceb39ee6a07909875f7f127",
        "refCount": 5
    },
    {
        "Content": "192.168.0.2:3306",
        "ID": "da6cd2c93e2b7561f47aa01c724dfedc",
        "refCount": 2
    },
    {
        "Content": "<?xml version=\"1.0\" encoding=\"utf-16\"?>\n<ContentFichas xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>729548999</telefono>\n    <mailAddress>Keterb@essonixtern.org</mailAddress>\n    <faceParts>Mujer/Base_c;Mujer/Ears_b;Mujer/Eyes_b;Mujer/Hair_c;Mujer/Nose_c;Mujer/Mouth_b;Mujer/Neck_c;Accesorios/earing2;Accesorios/scar2</faceParts>\n    <faceScales>-0.8913383,0.951856,0,0;-0.8913383,1.174003,0,0;-1.000703,0.9575077,0,0.3416969;-0.8913383,0.9507166,0,0;-1.00487,0.8638085,0,-0.1516543;-0.9429812,0.9281296,0,-2.024548;-0.8913383,1,0,0;-0.8913383,1.174003,-0.75,0;-0.8913383,0.951856,0,0</faceScales>\n    <nombreCompleto>Kaylee Keterb</nombreCompleto>\n    <edad>63</edad>\n    <horario>07:15 - 13:45</horario>\n    <idPersona>89c5ec03-7afa-4e71-8ae4-d2e40fbbc706</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>536263973</telefono>\n    <mailAddress>Raina@yerse.info</mailAddress>\n    <faceParts>Mujer/Base_c;Mujer/Ears_a;Mujer/Eyes_b;Mujer/Hair_c;Mujer/Nose_c;Mujer/Mouth_a;Mujer/Neck_a;Accesorios/earing2</faceParts>\n    <faceScales>-0.9153222,0.9780054,0,0;-0.9153222,1.117648,0,0;-1.037238,0.9778426,0,0.1134316;-0.9153222,0.9487052,0,0;-0.8828853,1.0015,0,-0.05753132;-1.002372,0.9186402,0,-1.400968;-0.9153222,1,0,0;-0.9153222,1.117648,-0.75,0</faceScales>\n    <nombreCompleto>Kendra Raina</nombreCompleto>\n    <edad>36</edad>\n    <horario>06:30 - 13:00</horario>\n    <idPersona>20692ec5-ffa1-4d20-9dc9-4b1b746d311a</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>636725443</telefono>\n    <mailAddress>Lissen@wellab.info</mailAddress>\n    <faceParts>Hombre/Base_c;Hombre/Ears_c;Hombre/Eyes_b;Hombre/Hair_c;Hombre/Nose_a;Hombre/Mouth_b;Hombre/Neck_d;Accesorios/goat;Accesorios/earing</faceParts>\n    <faceScales>0.9691151,1.070381,0,0;0.9691151,1.180313,0,0;1.001124,1.09538,0,-0.5759666;0.9691151,0.9657369,0,0;0.9678968,0.7836594,0,-0.58678;0.9656989,0.8791797,0,-5.121721;0.9691151,1,0,0;0.9691151,1.070381,0,0;0.9691151,1.180313,0.75,0</faceScales>\n    <nombreCompleto>Owen Lissen</nombreCompleto>\n    <edad>47</edad>\n    <horario>08:45 - 15:15</horario>\n    <idPersona>a36fa99e-05bd-4e70-9bd0-cfb4a985df27</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>218675388</telefono>\n    <mailAddress>Ureralt@namcorp.org</mailAddress>\n    <faceParts>Mujer/Base_c;Mujer/Ears_a;Mujer/Eyes_b;Mujer/Hair_a;Mujer/Nose_a;Mujer/Mouth_c;Mujer/Neck_b</faceParts>\n    <faceScales>-1.011808,0.9793085,0,0;-1.011808,1.001875,0,0;-1.003692,1.09163,0,-0.4920366;-1.011808,0.9541683,0,0;-0.870038,0.8781183,0,0.138259;-0.7412148,0.8513765,0,-1.966958;-1.011808,1,0,0</faceScales>\n    <nombreCompleto>Evita Ureralt</nombreCompleto>\n    <edad>24</edad>\n    <horario>09:00 - 15:30</horario>\n    <idPersona>ad03db88-21f9-45eb-b86d-997da7afa715</idPersona>\n    <incidencias />\n  </Ficha>\n</ContentFichas>",
        "ID": "16d89c56dfd08094e87df29f1aa70f6e",
        "refCount": 1
    },
    {
        "Content": "//command: nmap\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"nmap_usage\"))\t\nif not is_valid_ip(params[0]) then exit(\"nmap: invalid ip address\")\nif not get_shell.host_computer.is_network_active then exit(\"nmap: can't connect. No internet access.\")\n\nipAddress = params[0]\nisLanIp = is_lan_ip( ipAddress )\n\nif isLanIp then\n   router = get_router;\nelse \n   router = get_router( ipAddress )\nend if\n\nif router == null then exit(\"nmap: ip address not found\")\nports = null\n\nif not isLanIp then\n   ports = router.used_ports\nelse\n   ports = router.device_ports(ipAddress)\nend if\n\nif ports == null then exit(\"nmap: ip address not found\")\nif typeof(ports) == \"string\" then exit(ports)\n      \ninfo = \"PORT STATE SERVICE VERSION LAN\"   \nprint(\"\\nStarting nmap v1.1 at \" + current_date)\nprint(\"Interesting ports on \" + params[0] + \"\\n\")\nif(ports.len == 0) then exit(\"Scan finished. No open ports.\")\n\nfor port in ports\n   service_info = router.port_info(port)\n   lan_ips = port.get_lan_ip\n   port_status = \"open\"\n\n   if(port.is_closed and not isLanIp) then\n      port_status = \"closed\"\n   end if\n   info = info + \"\\n\" + port.port_number + \" \" + port_status + \" \" + service_info + \" \" + lan_ips\nend for\nprint(format_columns(info) + \"\\n\")",
        "ID": "960c89def7cb52929b05d61e2dcf02ab",
        "refCount": 1
    },
    {
        "Content": "//command: smtp-user-list\ncryptools = include_lib(\"/lib/crypto.so\")\nif not cryptools then exit(\"Error: Missing crypto library\")\n\nif params.len == 0 or params.len > 2 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"smtpuserlist_usage\"))\t\n\nipAddress = params[0]\nport = \"25\"\nif(params.len > 1) then \n   port = params[1]\nend if\n\nprint(\"Connecting...\")\nusers = cryptools.smtp_user_list(ipAddress, port.to_int)\nif not users then exit(\"smtp_user_list: invalid parameters\")\nif(typeof(users) == \"string\") then exit(users)\n\nprint(\"Starting smtp-mail-list...\\n\\n###### Scan started ######\")\nfor user in users\n   print(user)\nend for\nprint(\"###### Scan completed ######\\n\" + users.len + \" results.\")",
        "ID": "5b623d8ee13d825961a6c8359a485497",
        "refCount": 1
    },
    {
        "Content": "1.0;0",
        "ID": "27718dc81b10cf0bac527b4f496fae86",
        "refCount": 30
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"112.58.71.88\",\"fecha\":\"5-1-1990 08:49\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "7e4cb13d4e09b002528a098fc8a66967",
        "refCount": 1
    },
    {
        "Content": "root:a0f99153fe6b106d02c7faece1f48f25\nReich:06d89e3e996ecc5eb79e997c405f9a32\nTheward:b69e7e3d37b28944f7d426497dc202f0\nAganeys:a162b102347ce9ab14a23bb06c7275dd\n",
        "ID": "1036d181fda27c78d81391b2d52ad0a3",
        "refCount": 1
    },
    {
        "Content": "Reich@ernese.com:5d0b1cd47a10c1422de51eba55e40a27",
        "ID": "ea429d07d6d019a5bdd99cc73953364a",
        "refCount": 1
    },
    {
        "Content": "04w5Q5Fj:9cda1bfadfffb6299501987da18ee7a3",
        "ID": "869c9554a3a981715bf57300a4f924bd",
        "refCount": 1
    },
    {
        "Content": "Theward@radellac.net:46640a0a946c2ebf4691fdd3bf969be4",
        "ID": "f9fee15170331505094602b6bbc3d547",
        "refCount": 1
    },
    {
        "Content": "4KBdbpV2:55143def56183d703c8ba5f37e944011",
        "ID": "14c35e42c4e7de0f43667932764b5ac1",
        "refCount": 1
    },
    {
        "Content": "Aganeys@atedhea.org:dd2ce21bc9495a1aa28a9eed910da8eb",
        "ID": "3e93dd901d8c45a7e40a6b0c851f8e1e",
        "refCount": 1
    },
    {
        "Content": "sSVJwjJQ:7eeef71f8d92bf387a22fe416f100bcc",
        "ID": "4fe623de37aec772c2cd2cb4cb7c4a67",
        "refCount": 1
    },
    {
        "Content": "<!DOCTYPE html>\n<style type='text/css'>\n\n  h1 { font-size: 40px; text-align: center}\n  body { font: 12px Helvetica, sans-serif; color: #333; margin:0; overflow-y:auto; height:100%; }\n  .btn {\n    background-color: #072C3F;\n    border: 1px solid #4B4B4B;\n    color: white;\n    padding: 8px 8px;\n    font-size: 18;\n    width: 130px; \n  }\n  .btn-group button:hover {\n    background-color: #137AACFF;\n  }\n\n  article { display: block; text-align: left; width: 600px; margin: 0 auto; }\n  html{\n    background-color: white;\n    height:100%;\n  }\n  .btn-group{\n    text-align: center;\n  }\n  .logo{\n    text-align: center;\n    padding: 10px;\n  }\n  img{\n    display: block;\n    margin: 0 auto;\n  }\n  </style>\n  <div style=\"background-color:#4A6470;color:white;padding:11px;\">\n    <font size=\"30\">Intect</font>\n  </div>\n  <div style=\"background-color:#00445A;color:white;padding:5px;\">\n    <div class=\"btn-group\">\n      <button type=\"button\" class=\"btn btn-primary\" id=\"Home\">Home</button>\n      <button type=\"button\" class=\"btn btn-primary\" id=\"RegisterBank\">Register</button>\n      <button type=\"button\" class=\"btn btn-primary\" id=\"LoginBank\">Login</button>\n    </div>\n  </div>\n  <article>\n    <div class=\"logo text-center\">\n      <p>\nAt Intect we are at your service every day to offer you the best.<br>Let us be your bank.\n    </p>\n      <img src=\"bank.png\" width=\"120\" height=\"120\" align=\"center\">\n    </div>\n  </article>",
        "ID": "401902fb6c511606c3822fe1c407a462",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"112.58.71.88\",\"fecha\":\"5-1-1990 11:39\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "3ab9830789234676dee902c9093b290e",
        "refCount": 1
    },
    {
        "Content": "NjSmaRkn:7938b5a64decef3875c670fc140b0527",
        "ID": "5a92599040d38758e6e90009dbd477c8",
        "refCount": 1
    },
    {
        "Content": "root:adfc2c84285880f6a5655f13c94ee491\nErristone:01e0a38f743de9b387dceb579f546270\n",
        "ID": "fb8c2be578f4e59a948bd7dba6178709",
        "refCount": 1
    },
    {
        "Content": "Erristone@mutual.com:7bba849ed9cafa3ce46c73399afee862",
        "ID": "3ce07c00e1bbf7c66d21a4b8f7a1bb4d",
        "refCount": 1
    },
    {
        "Content": "iT2zTnlT:648009a916eb8998e06be7cc36da0e82",
        "ID": "25889979edd22dccb6244a81acba98cb",
        "refCount": 1
    },
    {
        "Content": "10.0.19.9:3306",
        "ID": "b14e0dd5c83eb6febf036865ee9b0a9a",
        "refCount": 1
    },
    {
        "Content": "<?xml version=\"1.0\" encoding=\"utf-16\"?>\n<ContentFichas xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>311375982</telefono>\n    <mailAddress>Entleh@thwestvac.net</mailAddress>\n    <faceParts>Hombre/Base_c;Hombre/Ears_a;Hombre/Eyes_d;Hombre/Hair_d;Hombre/Nose_c;Hombre/Mouth_b;Hombre/Neck_b;Accesorios/goat</faceParts>\n    <faceScales>-0.9559817,1.049063,0,0;-0.9559817,1.11417,0,0;-0.908321,1.065202,0,-0.6873455;-0.9559817,0.9729602,0,0;-0.811595,0.752205,0,0.07892804;-0.7792732,0.8671471,0,-5.23962;-0.9559817,1,0,0;-0.9559817,1.049063,0,0</faceScales>\n    <nombreCompleto>Talbert Entleh</nombreCompleto>\n    <edad>44</edad>\n    <horario>07:30 - 14:00</horario>\n    <idPersona>cbb08833-d0bd-476a-be59-441c39543d0f</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>912666892</telefono>\n    <mailAddress>Erristone@mutual.com</mailAddress>\n    <faceParts>Mujer/Base_a;Mujer/Ears_c;Mujer/Eyes_b;Mujer/Hair_c;Mujer/Nose_b;Mujer/Mouth_b;Mujer/Neck_b;Accesorios/glasses</faceParts>\n    <faceScales>-1.026187,1.023296,0,0;-1.026187,0.9446522,0,0;-0.9523839,1.067327,0,-0.337709;-1.026187,0.952036,0,0;-0.7509746,0.9295371,0,-0.5365319;-0.9643037,0.9740147,0,-4.462716;-1.026187,1,0,0;-1.026187,1.023296,0,0</faceScales>\n    <nombreCompleto>Wynne Erristone</nombreCompleto>\n    <edad>28</edad>\n    <horario>09:45 - 16:15</horario>\n    <idPersona>ac4e67c0-cf1c-4a9c-b13f-9abde4ade288</idPersona>\n    <incidencias />\n  </Ficha>\n</ContentFichas>",
        "ID": "bf576a1c2f816b2df7b1b7a16abb1843",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"112.58.71.88\",\"fecha\":\"8-1-1990 13:51\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "220c8d9df86e7bb6242a8c07f95ff794",
        "refCount": 1
    },
    {
        "Content": "root:6efa24826b64b1b49586dc411b293c1b\n",
        "ID": "0dc3cc1a33b18de540ffffd18fb34b05",
        "refCount": 2
    },
    {
        "Content": "[\"168.42.167.182\"]",
        "ID": "ed036db2ca0ca408a241953982bddef8",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"112.58.71.88\",\"fecha\":\"8-1-1990 14:33\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "ad25ae3b5e45438bbb0c169a31755d61",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"8-1-1990 14:33\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "68f6db1f16fe5c139a05916a5d6f993e",
        "refCount": 1
    },
    {
        "Content": "Params = {}\n\nParams.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nCompiler = {}\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function(name)\n\treturn name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function(name)\n\treturn name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function(name)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath(name))\nend function\n\nCompiler.getFullTempFilePath = function(name)\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath(name))\nend function\n\nCompiler.doImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = pathJoin(self.getScriptFolder(), path + \".\" + self.getExtension())\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\n\tfile = myComputer.File(compiler.getFullScriptFile(name))\n\n\tif file == null then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = file.get_content\n\tcontent = compile.doImports(myComputer, content)\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath(name))\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(name), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nparams = new Params\n\nmain(params.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "6b31b04a34194d47f67e1b6d131f880e",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nCompiler = {}\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function(name)\n\treturn name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function(name)\n\treturn name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function(name)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath(name))\nend function\n\nCompiler.getFullTempFilePath = function(name)\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath(name))\nend function\n\nCompiler.doImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = pathJoin(self.getScriptFolder(), path + \".\" + self.getExtension())\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\n\tfile = myComputer.File(compiler.getFullScriptFile(name))\n\n\tif file == null then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = file.get_content\n\tcontent = compile.doImports(myComputer, content)\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath(name))\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(name), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "077ef7efb99c83ceb595ccf4e1384a3d",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nCompiler = {}\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function(name)\n\treturn name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function(name)\n\treturn name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function(name)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath(name))\nend function\n\nCompiler.getFullTempFilePath = function(name)\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath(name))\nend function\n\nCompiler.doImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = pathJoin(self.getScriptFolder(), path + \".\" + self.getExtension())\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\n\tfile = myComputer.File(compiler.getFullScriptFilePath(name))\n\n\tif file == null then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = file.get_content\n\tcontent = compile.doImports(myComputer, content)\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath(name))\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(name), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "d2920345ea943636b415c6247bd6a92b",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nCompiler = {}\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function(name)\n\treturn name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function(name)\n\treturn name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function(name)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath(name))\nend function\n\nCompiler.getFullTempFilePath = function(name)\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath(name))\nend function\n\nCompiler.doImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = pathJoin(self.getScriptFolder(), path + \".\" + self.getExtension())\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\n\tfile = myComputer.File(compiler.getFullScriptFilePath(name))\n\n\tif file == null then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = file.get_content\n\tcontent = compiler.doImports(myComputer, content)\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath(name))\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(name), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "a1828653b20d3b4441442bce9c50643f",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nCompiler = {}\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function(name)\n\treturn name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function(name)\n\treturn name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function(name)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath(name))\nend function\n\nCompiler.getFullTempFilePath = function(name)\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath(name))\nend function\n\nCompiler.getFullImportFilePath = function(importPath)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), importPath + \".\" + self.getExtension())\nend function\n\nCompiler.doImports = function(computer, fileContent)\n\tindex = fileContent.indexOf(\"#include\")\n\tendIndex = fileContent.indexOf(\";\", index)\n\n\twhile index != null\n\t\timport = slice(fileContent, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\n\t\timportFilePath = self.getFullImportFilePath(path)\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = fileContent.replace(import, importFileContent)\n\n\t\tindex = fileContent.indexOf(\"#include\")\n\t\tendIndex = fileContent.indexOf(\";\", index)\n\tend while\n\n\treturn fileContent\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\n\tfile = myComputer.File(compiler.getFullScriptFilePath(name))\n\n\tif file == null then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = file.get_content\n\tcontent = compiler.doImports(myComputer, content)\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath(name))\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(name), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "ab8f97c4ad19f0fca9ba2b9a8d412ad3",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.getFullImportFilePath = function(importPath)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), importPath + \".\" + self.getExtension())\nend function\n\nCompiler.findDependenciesInFile = function(content)\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\t\n\t\tresult.push(path)\n\t\t\n\t\tindex = fileContent.indexOf(\"#include\", endIndex)\n\t\tendIndex = fileContent.indexOf(\";\", endIndex)\n\tend while\n\n\treturn result\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tdependencies = self.findDependenciesInFile(content)\n\tprint(dependencies)\n\n\tfor dependency in dependencies\n\t\timportFilePath = self.getFullImportFilePath(dependency)\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = self.replaceImport(dependency, importFileContent)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath(name))\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(name), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "ec0773313542ca7d7603d9833507772c",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.getFullImportFilePath = function(importPath)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), importPath + \".\" + self.getExtension())\nend function\n\nCompiler.findDependenciesInFile = function(content)\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\t\n\t\tresult.push(path)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\treturn result\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tdependencies = self.findDependenciesInFile(content)\n\tprint(dependencies)\n\n\tfor dependency in dependencies\n\t\timportFilePath = self.getFullImportFilePath(dependency)\n\t\timportFile = computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = self.replaceImport(dependency, importFileContent)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath(name))\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(name), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "eadcd938e051bd781719475380fa1eb0",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.getFullImportFilePath = function(importPath)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), importPath + \".\" + self.getExtension())\nend function\n\nCompiler.findDependenciesInFile = function(content)\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\t\n\t\tresult.push(path)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\treturn result\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tdependencies = self.findDependenciesInFile(content)\n\tprint(dependencies)\n\n\tfor dependency in dependencies\n\t\timportFilePath = self.getFullImportFilePath(dependency)\n\t\timportFile = self.computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = self.replaceImport(dependency, importFileContent)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath(name))\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(name), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "0afed746bb434ada07772841e9b75c85",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.getFullImportFilePath = function(importPath)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), importPath + \".\" + self.getExtension())\nend function\n\nCompiler.findDependenciesInFile = function(content)\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\t\n\t\tresult.push(path)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\treturn result\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tdependencies = self.findDependenciesInFile(content)\n\tprint(dependencies)\n\n\tfor dependency in dependencies\n\t\timportFilePath = self.getFullImportFilePath(dependency)\n\t\timportFile = self.computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = self.replaceImport(dependency, importFileContent)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(name), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "89ae0fb6c1b246e66c143a5a4373a24e",
        "refCount": 1
    },
    {
        "Content": "library/aireplay-helper",
        "ID": "2ff5a4ae84a9ccee88621ffbe55fbc18",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.getFullImportFilePath = function(importPath)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), importPath + \".\" + self.getExtension())\nend function\n\nCompiler.findDependenciesInFile = function(content)\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\t\n\t\tresult.push(path)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\treturn result\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tdependencies = self.findDependenciesInFile(content)\n\tprint(dependencies)\n\n\tfor dependency in dependencies\n\t\timportFilePath = self.getFullImportFilePath(dependency)\n\t\timportFile = self.computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = self.replaceImport(dependency, importFileContent)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "6a7908ff1dae78b40c494693b559d5c2",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.getFullImportFilePath = function(importPath)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), importPath + \".\" + self.getExtension())\nend function\n\nCompiler.findDependenciesInFile = function(content)\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\t\n\t\tresult.push(path)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\treturn result\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tdependencies = self.findDependenciesInFile(content)\n\tprint(dependencies)\n\tprint(self)\n\n\tfor dependency in dependencies\n\t\timportFilePath = self.getFullImportFilePath(dependency)\n\t\timportFile = self.computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = self.replaceImport(dependency, importFileContent)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "ebb138e2c10de7dcb3a88b64f4526bb6",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, path)\n\tself.path = path\n\tself.computer = computer\n\tself.target = computer.File(path)\nend function\n\nDependency.findDependencies = function()\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\t\n\t\tresult.push(path)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.getFullImportFilePath = function(importPath)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), importPath + \".\" + self.getExtension())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependenciesInFile()\n\tprint(dependencies)\n\tprint(self)\n\n\tfor dependency in dependencies\n\t\timportFilePath = self.getFullImportFilePath(dependency)\n\t\timportFile = self.computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = self.replaceImport(dependency, importFileContent)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "18884e9a97842f07571c96dd2b52d23a",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, path)\n\tself.path = path\n\tself.computer = computer\n\tself.target = computer.File(path)\nend function\n\nDependency.findDependencies = function()\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\t\n\t\tresult.push(path)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.getFullImportFilePath = function(importPath)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), importPath + \".\" + self.getExtension())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tprint(dependencies)\n\tprint(self)\n\n\tfor dependency in dependencies\n\t\timportFilePath = self.getFullImportFilePath(dependency)\n\t\timportFile = self.computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = self.replaceImport(dependency, importFileContent)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "94f751fcdc6700b93c5f1ad46d269807",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, path)\n\tpathHelper = new Path\n\t\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\tprint(self.basePath)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\t\n\t\tresult.push(path)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nCompiler.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nCompiler.getExtension = function()\n\treturn \"src\"\nend function\n\nCompiler.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nCompiler.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + self.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + self.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(self.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.getFullImportFilePath = function(importPath)\n\tpath = new Path\n\treturn path.join(self.getScriptFolder(), importPath + \".\" + self.getExtension())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tprint(dependencies)\n\tprint(self)\n\n\tfor dependency in dependencies\n\t\timportFilePath = self.getFullImportFilePath(dependency)\n\t\timportFile = self.computer.File(importFilePath)\n\n\t\tif importFile == null then\n\t\t\texit(\"Cannot find \" + importFilePath + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + importFilePath + \"...\")\n\n\t\timportFileContent = importFile.get_content\n\n\t\tfileContent = self.replaceImport(dependency, importFileContent)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "f974c1c63db0b0d81e97514972a1e42e",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tprint(dependencies)\n\tprint(self)\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tfileContent = self.replaceImport(dependency.target.get_content, dependency.importCode)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "9ee9ab75d625025d318ab26ecd69b3b6",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tprint(path)\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tprint(dependencies)\n\tprint(self)\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tfileContent = self.replaceImport(dependency.target.get_content, dependency.importCode)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "d6f849ac96c288aaf4fe743e02c0a487",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tprint(dependencies)\n\tprint(self)\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tfileContent = self.replaceImport(dependency.target.get_content, dependency.importCode)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "2a9fe02fcf0d8dd891a43b5650145a48",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tprint(dependencies)\n\tprint(self)\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tfileContent = self.replaceImport(dependency.target.get_content, dependency.importCode)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), compiler.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + compiler.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(), compiler.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "c90b03d0c5f8f430de1469e3c2adeb2c",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tprint(dependencies)\n\tprint(self)\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tfileContent = self.replaceImport(dependency.target.get_content, dependency.importCode)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, compiler.getTempFolder(), config.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(), config.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "ba1ef1329506eb192edfa62967374f47",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function(content)\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tprint(dependencies)\n\tprint(self)\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tfileContent = self.replaceImport(dependency.target.get_content, dependency.importCode)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.execute = function()\n\tcontent = self.target.get_content\n\tcontent = self.doImports(content)\n\treturn content\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.execute()\n\n\tnewFile = fs.createFile(myComputer, config.getTempFolder(), compiler.getTempFilePath())\n\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tnewFile.set_content(content)\n\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\n\tmyShell.build(compiler.getFullTempFilePath(), config.getBinFolder())\n\n\tnewFile.delete\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "3c9aa7680182e95fb6b5145ca5eaec95",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\t\t\n\t\timport = \"#include \" + dependency.importCode + \";\"\n\t\tcontent = content.replace(import, dependency.target.get_content)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getTempFilePath())\n\t\n\tself.computer.createFolder(buildPath)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getTempFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "31e7e8704770bd11501ee4c66bc7efb3",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\t\t\n\t\timport = \"#include \" + dependency.importCode + \";\"\n\t\tcontent = content.replace(import, dependency.target.get_content)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getTempFilePath())\n\t\n\tself.computer.create_folder(buildPath)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getTempFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "096d5a6268ef59a9c7fbcfad8ef421d5",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.get = function()\n\tmath = new Math\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + char(math.random(49, 123))\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\t\t\n\t\timport = \"#include \" + dependency.importCode + \";\"\n\t\tcontent = content.replace(import, dependency.target.get_content)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getTempFilePath())\n\t\n\tself.computer.create_folder(buildPath)\n\t\n\tprint(buildPath)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getTempFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "0d839fae46ec1e42ee10ea9ef1579950",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\t\t\n\t\timport = \"#include \" + dependency.importCode + \";\"\n\t\tcontent = content.replace(import, dependency.target.get_content)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getTempFilePath())\n\t\n\tself.computer.create_folder(buildPath)\n\t\n\tprint(buildPath)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getTempFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "dbeb04e7a796eaa6eb7ab632272c0720",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\t\t\n\t\timport = \"#include \" + dependency.importCode + \";\"\n\t\tcontent = content.replace(import, dependency.target.get_content)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getTempFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(buildPath)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getTempFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "4e4db45f018fa250df75535c9f546f30",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getTempFilePath = function()\n\treturn self.name + \".\" + config.getTempExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getTempFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\t\t\n\t\timport = \"#include \" + dependency.importCode + \";\"\n\t\tcontent = content.replace(import, dependency.target.get_content)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getTempFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(buildPath)\n\tprint(self.getTempFilePath())\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getTempFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "2fef15437df25d8a0ee9d88acde7d9ea",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"-\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\t\t\n\t\timport = \"#include \" + dependency.importCode + \";\"\n\t\tcontent = content.replace(import, dependency.target.get_content)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(buildPath)\n\tprint(self.getScriptFilePath())\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "b08cdf61fde360b714b5a15ad339b8fb",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\t\t\n\t\timport = \"#include \" + dependency.importCode + \";\"\n\t\tcontent = content.replace(import, dependency.target.get_content)\n\tend for\n\n\treturn fileContent\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "560fd24e50437446c8e4a89b2d62f67c",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\t\t\n\t\timport = \"#include \" + dependency.importCode + \";\"\n\t\tcontent = content.replace(import, dependency.target.get_content)\n\tend for\n\n\treturn content\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "59528d725065f6f04c75017b6f3fc89d",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\t\t\n\t\timport = \"#include \" + dependency.importCode + \";\"\n\t\tcontent = content.replace(import, dependency.target.get_content)\n\tend for\n\n\treturn content\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tprint(content)\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "8560b8453ae886ef225378ee2b44fd87",
        "refCount": 2
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\t\t\n\t\timport = \"#include \" + dependency.importCode + \";\"\n\t\tprint(import)\n\t\tcontent = content.replace(import, dependency.target.get_content)\n\tend for\n\n\treturn content\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "18da5aefabe573e1455af4421fc9d1a1",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tcontent = content.replace(dependency.importCode, dependency.target.get_content)\n\tend for\n\n\treturn content\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n",
        "ID": "5e51be55410df749eb1de5892a74f5fc",
        "refCount": 1
    },
    {
        "Content": "FS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(file)\n\tself.file = file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = my.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = new PasswordEntry\n\t\t\titem = item.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordManager\n\npasswordManager.constructor(myComputer)\n\nprint(passwordManager.passwordList.values)\n\n\n\n",
        "ID": "b27aa483e2e5ad3d75b51ceb10ae2a76",
        "refCount": 1
    },
    {
        "Content": "FS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(file)\n\tself.file = file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = my.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = new PasswordEntry\n\t\t\titem = item.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nprint(passwordManager.passwordList.values)\n\n\n\n\n",
        "ID": "4f15bc69544ba7cc950bee3912a889e9",
        "refCount": 1
    },
    {
        "Content": "FS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(file)\n\tself.file = file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = new PasswordEntry\n\t\t\titem = item.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nprint(passwordManager.passwordList.values)\n\n\n\n\n",
        "ID": "d322a90f4801e5cbc19a1935064ff078",
        "refCount": 1
    },
    {
        "Content": "FS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(file)\n\tself.file = file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = new PasswordEntry\n\t\t\titem = item.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nprint(passwordManager.passwordList.values)\n\n\n\n\n",
        "ID": "8547560e27346d04fbb38a274f1cb0e7",
        "refCount": 1
    },
    {
        "Content": "FS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\titem = new PasswordEntry\n\t\t\titem = item.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(item)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nprint(passwordManager.passwordList.values)\n\n\n\n\n",
        "ID": "980319d04745999e546b82c93aee7a9e",
        "refCount": 1
    },
    {
        "Content": "FS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nprint(passwordManager.passwordList.values)\n\n\n\n\n",
        "ID": "0c09150022b0e0af2cf0d3474d1b99aa",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\nargv = new Argv\n\nkey = argv.get(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry.password)\n\n\n\n",
        "ID": "50b381ef768afd1ccc11045b0bf641d2",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\nargv = new Argv\n\nlistIndex = to_int(argv(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.passwordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Entry: \" + passwordManager.passwordList[listIndex].toString())\n\n\n\n",
        "ID": "73c7dc0dfa7b7c9b234c71120e074e4d",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\nargv = new Argv\n\nlistIndex = to_int(argv(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nprint(passwordManager.passwordList)\n\nexistingEntry = passwordManager.passwordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Entry: \" + passwordManager.passwordList[listIndex].toString())\n\n\n\n\n",
        "ID": "b1c82b1d7e85df633b072139c1ea410b",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\nargv = new Argv\n\nlistIndex = to_int(argv(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nprint(listIndex)\n\nexistingEntry = passwordManager.passwordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Entry: \" + passwordManager.passwordList[listIndex].toString())\n\n\n\n\n",
        "ID": "ba111e5dbf35b2d409bd70f4bb212907",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\nargv = new Argv\n\nlistIndex = to_int(argv.get(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nprint(listIndex)\n\nexistingEntry = passwordManager.passwordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Entry: \" + passwordManager.passwordList[listIndex].toString())\n\n\n\n\n",
        "ID": "49d2a000a39594399b7a37b0c30b2fb6",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\nargv = new Argv\n\nlistIndex = to_int(argv.get(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.passwordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Entry: \" + passwordManager.passwordList[listIndex].toString())\n\n\n\n\n",
        "ID": "3657b1ef579ce03e4a2a4e4acea301ac",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\nargv = new Argv\n\nkey = argv.get(0, true)\npassword = argv.get(1, true)\noverride = argv.get(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nentry = new PasswordEntry\nentry.constructor(key, password)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tpasswordManager.setPasswordByKey(entry)\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tpasswordManager.passwordList.push(entry)\nend if\n\nprint(\"Saving password...\")\npasswordManager.savePasswordFile()\n\n\n\n",
        "ID": "c4c7b0799b698e3fe3f76e830b9cec0a",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\n\nargv = new Argv\n\nkey = argv.get(0, true)\npassword = argv.get(1, true)\noverride = argv.get(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nentry = new PasswordEntry\nentry.constructor(key, password)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tpasswordManager.setPasswordByKey(entry)\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tpasswordManager.passwordList.push(entry)\nend if\n\nprint(\"Saving password...\")\npasswordManager.savePasswordFile()\n\n\n\n",
        "ID": "59d8040f100c59908ec356c2e3e54cc6",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(passwordList, 0, index)\n\t\tafter = slice(passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\n\nargv = new Argv\n\nkey = argv.get(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\npasswordManager.removePasswordByKey(existingEntry)\n\nprint(\"Removing password...\")\npasswordManager.savePasswordFile()\n\npasswordManager.parsePasswordFile()\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Removing was a success\")\nend if\n\nexit(\"Something went wrong\")\n\n\n",
        "ID": "646d033f13067767cd866e9c7dd06cc8",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\n\n\nargv = new Argv\n\nkey = argv.get(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\npasswordManager.removePasswordByKey(existingEntry)\n\nprint(\"Removing password...\")\npasswordManager.savePasswordFile()\n\npasswordManager.parsePasswordFile()\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Removing was a success\")\nend if\n\nexit(\"Something went wrong\")\n\n\n",
        "ID": "f2c2aa96618c88ae69fe47c0cc6df52b",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\n\n\nargv = new Argv\n\nkey = argv.get(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry.password)\n\n\n\n",
        "ID": "333f37f8e2687726c1c1b9df832ad07f",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\n\n\nargv = new Argv\n\nlistIndex = to_int(argv.get(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.passwordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Entry: \" + passwordManager.passwordList[listIndex].toString())\n\n\n\n\n",
        "ID": "bea6405c943b3c14c18347217de188a1",
        "refCount": 1
    },
    {
        "Content": "FS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\n\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nprint(passwordManager.passwordList.values)\n\n\n\n\n",
        "ID": "d618905c87629294c9e4aa178b4dc3af",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\n\n\n\n\n\n\n\n\nargv = new Argv\n\nkey = argv.get(0, true)\npassword = argv.get(1, true)\noverride = argv.get(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nentry = new PasswordEntry\nentry.constructor(key, password)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tpasswordManager.setPasswordByKey(entry)\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tpasswordManager.passwordList.push(entry)\nend if\n\nprint(\"Saving password...\")\npasswordManager.savePasswordFile()\n\n\n\n",
        "ID": "e71bc433334fa5460459f67434707406",
        "refCount": 2
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage == null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(my.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\n\nmyShell = get_shell\n\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\nmyShell.scp(localFile, remoteFile, connection.shell)\n",
        "ID": "0f64008ccb8e0fc9a2149edbc95be32b",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage == null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(my.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\n\nmyShell = get_shell\n\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\nmyShell.scp(localFile, remoteFile, connection.shell)\n",
        "ID": "81e859946cc3455c320abc4ccd0576be",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(my.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\n\nmyShell = get_shell\n\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\nmyShell.scp(localFile, remoteFile, connection.shell)\n",
        "ID": "2030b13c8d7d342dad4370ff8aff89a6",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tpath = new Path\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\n\nargv = new Argv\n\ntarget = argv.get(0, true)\n\nfs = new FS\nfs.constructor(get_shell.host_computer)\n\nif fs.doesFileExist(target) then\n\texit(\"File does not exist\")\nend if\n\nprompt = input(\"You are about to delete all folders in \" + target + \". Are you sure? (Y/n)\")\n\nif prompt != \"Y\" then\n\texit(\"Aborted...\")\nend if\n\nfolder = fs.getFilesInFolder(target)\n\nif folder == null then\n\texit(\"Could not find folder.\")\nend if\n\nfor file in folder\n\tfile.delete\nend for\n",
        "ID": "9a99d3fe07f15a308cda71af11ff4b3b",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tpath = new Path\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\n\nargv = new Argv\n\ntarget = argv.get(0, true)\n\nfs = new FS\nfs.constructor(get_shell.host_computer)\n\nif fs.doesFileExist(target) == false then\n\texit(\"File does not exist\")\nend if\n\nprompt = input(\"You are about to delete all folders in \" + target + \". Are you sure? (Y/n)\")\n\nif prompt != \"Y\" then\n\texit(\"Aborted...\")\nend if\n\nfolder = fs.getFilesInFolder(target)\n\nif folder == null then\n\texit(\"Could not find folder.\")\nend if\n\nfor file in folder\n\tfile.delete\nend for\n",
        "ID": "8d101d5746668e647fa509827711b656",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tpath = new Path\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\n\nargv = new Argv\n\ntarget = argv.get(0, true)\n\nfs = new FS\nfs.constructor(get_shell.host_computer)\n\nif fs.doesFileExist(target) == false then\n\texit(\"File does not exist\")\nend if\n\nprompt = user_input(\"You are about to delete all folders in \" + target + \". Are you sure? (Y/n)\")\n\nif prompt != \"Y\" then\n\texit(\"Aborted...\")\nend if\n\nfolder = fs.getFilesInFolder(target)\n\nif folder == null then\n\texit(\"Could not find folder.\")\nend if\n\nfor file in folder\n\tfile.delete\nend for\n",
        "ID": "038ff89a7aeafe6d673ef69a007d7809",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tpath = new Path\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\n\nargv = new Argv\n\ntarget = argv.get(0, true)\n\nfs = new FS\nfs.constructor(get_shell.host_computer)\n\nif fs.doesFileExist(target) == false then\n\texit(\"File does not exist\")\nend if\n\nprompt = user_input(\"You are about to delete all folders in \" + target + \". Are you sure? (Y/n)\")\n\nif prompt != \"Y\" then\n\texit(\"Aborted...\")\nend if\n\nfolder = fs.getFilesInFolder(target)\n\nif folder == null then\n\texit(\"Could not find folder.\")\nend if\n\nfor file in folder\n\tprint(\"Deleting \" + file.path + \"...\")\n\tfile.delete\nend for\n\nexit(\"Done!\")\n",
        "ID": "307fc48faffc3bcf33732374edf06826",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\n\t\n\tif target == null then\n\t\texit(\"Dependency \" + path + \" does not exist...\")\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tcontent = content.replace(dependency.importCode, dependency.target.get_content)\n\tend for\n\n\treturn content\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n\n",
        "ID": "841c913ddc34d85a29c08d0acad377d9",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\texit(\"Dependency \" + path + \" does not exist...\")\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tcontent = content.replace(dependency.importCode, dependency.target.get_content)\n\tend for\n\n\treturn content\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n\n",
        "ID": "b76f59c8277a8b8bbdab0ac2144f8e97",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\texit(\"Dependency \" + path + \" does not exist...\")\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tcontent = content.replace(dependency.importCode, dependency.target.get_content)\n\tend for\n\n\treturn content\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tshell.build(buildPathFull, config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\texit(\"Couldn't build file for unknown reason...\")\n\tend if\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n\n",
        "ID": "b1304cdd04cdb36aa7b4f13505936537",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\texit(\"Dependency \" + path + \" does not exist...\")\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tcontent = content.replace(dependency.importCode, dependency.target.get_content)\n\tend for\n\n\treturn content\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tresult = shell.build(buildPathFull, config.getBinFolder())\n\t\n\tprint(result)\n\t\n\tcompiledBuildPathFull = pathHelper.join(config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\texit(\"Couldn't build file for unknown reason...\")\n\tend if\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n\n",
        "ID": "ff52e90aa7c7540797eb4da195ae33e9",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\texit(\"Dependency \" + path + \" does not exist...\")\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.replaceImport = function(content, path)\n\timport = \"#include \" + path + \";\"\n\treturn content.replace(import, content)\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\tdependencies = thisFile.findDependencies()\n\tcontent = thisFile.target.get_content\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tcontent = content.replace(dependency.importCode, dependency.target.get_content)\n\tend for\n\n\treturn content\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\tprint(buildReport)\n\t\texit(\"Couldn't build file for unknown reason...\")\n\tend if\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n\n",
        "ID": "04d3646e5e4c269cde7f173e0e2a49dd",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\n//include library/fs;\n//include library/connection-manager;\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile> <isFetching>\"\n\nprint(\"what\")\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\n//remoteFile = argv.get(5, true, description)\n\nprint(\"test\")\n\n//isFetching = argv.get(6, false, description)\n\n\nmyShell = get_shell\n\n//localFs = new FS\n//remoteFs = new FS\n//connectionManager = new ConnectionManager\n\n//connectionManager.constructor(myShell)\n\n//connection = connectionManager.getOrConnect(target, port, username, password)\n\n//localFs.constructor(myShell.host_computer)\n//remoteFs.constructor(connection.shell.host_computer)\n\nprint(\"before\")\n\n//print(localFs.getTree(localFile))\n\nexit(\"Testing\")\n\nif isFetching == \"true\" then\n\t\n\t\n\t//connection.shell.scp(remoteFile, localFile, myShell)\nelse\n\t//myShell.scp(localFile, remoteFile, connection.shell)\nend if\n\n\n",
        "ID": "9de8228ef2324555605aa7bc994f0d12",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tpath = new Path\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTree = function(pathString, collection = [])\n\tfile = pathString\n\t\n\tprint(file)\n\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\tcollection.push(file)\n\tfolder = self.getFilesInFolder(file.path)\n\t\n\tprint(file)\n\tprint(folder)\n\t\n\tif folder != null then\n\t\tfor file in folder\n\t\t\tself.getTree(file.path, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile> <isFetching>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\nisFetching = argv.get(6, false, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nremoteFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\nremoteFs.constructor(connection.shell.host_computer)\n\nprint(localFs.getTree(localFile))\n\nexit(\"Testing\")\n\nif isFetching == \"true\" then\n\t\n\t\n\t//connection.shell.scp(remoteFile, localFile, myShell)\nelse\n\t//myShell.scp(localFile, remoteFile, connection.shell)\nend if\n\n\n",
        "ID": "79b1def1c9789bc6c215a55fca31e353",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tpath = new Path\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTree = function(pathString, collection = [])\n\tfile = pathString\n\t\n\tprint(file)\n\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\tcollection.push(file)\n\tfolder = self.getFilesInFolder(file.path)\n\t\n\tprint(file)\n\tprint(folder)\n\t\n\tif folder != null then\n\t\tfor file in folder\n\t\t\tself.getTree(file.path, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile> <isFetching>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\nisFetching = argv.get(6, false, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nremoteFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n//remoteFs.constructor(connection.shell.host_computer)\n\nprint(localFs.getTree(localFile))\n\nexit(\"Testing\")\n\nif isFetching == \"true\" then\n\t\n\t\n\t//connection.shell.scp(remoteFile, localFile, myShell)\nelse\n\t//myShell.scp(localFile, remoteFile, connection.shell)\nend if\n\n\n",
        "ID": "4dae710489fe5f9889ba2bf953eeaed4",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tpath = new Path\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\tfolder = self.getFilesInFolder(file.path)\n\t\n\tif folder != null then\n\t\tfor file in folder\n\t\t\tself.getTreeIterator(file, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile> <isFetching>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\nisFetching = argv.get(6, false, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nremoteFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n//remoteFs.constructor(connection.shell.host_computer)\n\nprint(localFs.getTree(localFile))\n\nexit(\"Testing\")\n\nif isFetching == \"true\" then\n\t\n\t\n\t//connection.shell.scp(remoteFile, localFile, myShell)\nelse\n\t//myShell.scp(localFile, remoteFile, connection.shell)\nend if\n\n\n",
        "ID": "9062b2ec95e62f84bf4926db342d4890",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tpath = new Path\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\tfolder = self.getFilesInFolder(file.path)\n\t\n\tprint(folder)\n\t\n\tif folder != null then\n\t\tfor file in folder\n\t\t\tself.getTreeIterator(file, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile> <isFetching>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\nisFetching = argv.get(6, false, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nremoteFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n//remoteFs.constructor(connection.shell.host_computer)\n\nprint(localFs.getTree(localFile))\n\nexit(\"Testing\")\n\nif isFetching == \"true\" then\n\t\n\t\n\t//connection.shell.scp(remoteFile, localFile, myShell)\nelse\n\t//myShell.scp(localFile, remoteFile, connection.shell)\nend if\n\n\n",
        "ID": "643e5424b8988c4cd6e2ac1fc84510d9",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tpath = new Path\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\tfolder = self.getFilesInFolder(file.path)\n\t\n\tprint(file.path)\n\t\n\tif folder != null then\n\t\tfor file in folder\n\t\t\tself.getTreeIterator(file, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile> <isFetching>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\nisFetching = argv.get(6, false, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nremoteFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n//remoteFs.constructor(connection.shell.host_computer)\n\nprint(localFs.getTree(localFile))\n\nexit(\"Testing\")\n\nif isFetching == \"true\" then\n\t\n\t\n\t//connection.shell.scp(remoteFile, localFile, myShell)\nelse\n\t//myShell.scp(localFile, remoteFile, connection.shell)\nend if\n\n\n",
        "ID": "f3c3a0035045d7bd81ba6fde3fcbca0a",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tfolder = file.get_folders\n\t\n\t\tfor file in folder\n\t\t\tself.getTreeIterator(file, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile> <isFetching>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\nisFetching = argv.get(6, false, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nremoteFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n//remoteFs.constructor(connection.shell.host_computer)\n\nprint(localFs.getTree(localFile))\n\nexit(\"Testing\")\n\nif isFetching == \"true\" then\n\t\n\t\n\t//connection.shell.scp(remoteFile, localFile, myShell)\nelse\n\t//myShell.scp(localFile, remoteFile, connection.shell)\nend if\n\n\n",
        "ID": "8198c61ed92747c2187c70287b356dd0",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tprint(file.is_folder)\n\t\n\tif file.is_folder then\n\t\tfolder = file.get_folders\n\t\n\t\tfor file in folder\n\t\t\tself.getTreeIterator(file, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile> <isFetching>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\nisFetching = argv.get(6, false, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nremoteFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n//remoteFs.constructor(connection.shell.host_computer)\n\nprint(localFs.getTree(localFile))\n\nexit(\"Testing\")\n\nif isFetching == \"true\" then\n\t\n\t\n\t//connection.shell.scp(remoteFile, localFile, myShell)\nelse\n\t//myShell.scp(localFile, remoteFile, connection.shell)\nend if\n\n\n",
        "ID": "d4f3c4d32e8c26c6d9e12b19d647290f",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile> <isFetching>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\nisFetching = argv.get(6, false, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nremoteFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n//remoteFs.constructor(connection.shell.host_computer)\n\nprint(localFs.getTree(localFile))\n\nexit(\"Testing\")\n\nif isFetching == \"true\" then\n\t\n\t\n\t//connection.shell.scp(remoteFile, localFile, myShell)\nelse\n\t//myShell.scp(localFile, remoteFile, connection.shell)\nend if\n\n\n",
        "ID": "645f023c9fcc2661909ae946c5742ef0",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n\nfiles = localFs.getTree(localFile)\n\nfor file in files\n\tprint(\"Uploading \" + file.path + \"...\")\n\tconnection.shell.scp(file.path, localFile + \"/\" + file.name, myShell)\nend for\n\n\n",
        "ID": "d54fd88cb21a73e7f6698106259a0af0",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n\nfiles = localFs.getTree(localFile)\n\nfor file in files\n\tprint(\"Uploading \" + file.path + \"...\")\n\tif file.is_folder != true then\n\t\tconnection.shell.scp(file.path, localFile + \"/\" + file.name, myShell)\n\tend if\nend for\n\n\n",
        "ID": "b87dbebe958bab32f4b52de022c6843b",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n\nfiles = localFs.getTree(localFile)\n\nfor file in files\n\tprint(\"Uploading \" + file.path + \"...\")\n\tif file.is_folder != true then\n\t\tconnection.shell.scp(file.path, remoteFile + \"/\" + file.name, myShell)\n\tend if\nend for\n\n\n",
        "ID": "7bc175b6b7b88f04428978496f517375",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n\nfiles = localFs.getTree(localFile)\n\nfor file in files\n\tprint(\"Uploading \" + file.path + \"...\")\n\tif file.is_folder != true then\n\t\tmyShell.shell.scp(file.path, remoteFile + \"/\" + file.name, connection.shell)\n\tend if\nend for\n\n\n",
        "ID": "375e51384f06e36d465f12890c17b957",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n\nfiles = localFs.getTree(localFile)\n\nfor file in files\n\tprint(\"Uploading \" + file.path + \"...\")\n\tif file.is_folder != true then\n\t\tmyShell.scp(file.path, remoteFile + \"/\" + file.name, connection.shell)\n\tend if\nend for\n\n\n",
        "ID": "fe4e78981e9888acd285193266ae45bb",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\n\nargv = new Argv\n\ntarget = argv.get(0, true)\n\nfs = new FS\nfs.constructor(get_shell.host_computer)\n\nif fs.doesFileExist(target) == false then\n\texit(\"File does not exist\")\nend if\n\nprompt = user_input(\"You are about to delete all folders in \" + target + \". Are you sure? (Y/n)\")\n\nif prompt != \"Y\" then\n\texit(\"Aborted...\")\nend if\n\nfolder = fs.getFilesInFolder(target)\n\nif folder == null then\n\texit(\"Could not find folder.\")\nend if\n\nfor file in folder\n\tprint(\"Deleting \" + file.path + \"...\")\n\tfile.delete\nend for\n\nexit(\"Done!\")\n",
        "ID": "9b25495ac04f70194927c8e02799eccd",
        "refCount": 2
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n\nfiles = localFs.getTree(localFile)\n\nfor file in files\n\ttarget = remoteFile + \"/\" + file.name\n\tprint(\"Uploading \" + file.path + \" to \" + target +  \"...\")\n\tif file.is_folder != true then\n\t\tmyShell.scp(file.path, target, connection.shell)\n\tend if\nend for\n\n\n",
        "ID": "9843d65061727d2b47e26bd58d8477f9",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\n#include library/get-param;\n#include library/fs;\n#include library/connection-manager;\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n\nfiles = localFs.getTree(localFile)\n\nfor file in files\n\tprint(\"Uploading \" + file.path + \" to \" + remoteFile +  \"...\")\n\tif file.is_folder != true then\n\t\tmyShell.scp(file.path, remoteFile, connection.shell)\n\tend if\nend for\n\n\n",
        "ID": "68164de00662218d8c47dde530869631",
        "refCount": 1
    },
    {
        "Content": "print(\"what is happening?\")\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\nConnection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\n\n\nargv = new Argv\n\ndescription = \"<ip> <port> <username> <password> <localFile> <remoteFile>\"\n\ntarget = argv.get(0, true, description)\nport = to_int(argv.get(1, true, description))\nusername = argv.get(2, true, description)\npassword = argv.get(3, true, description)\n\nlocalFile = argv.get(4, true, description)\nremoteFile = argv.get(5, true, description)\n\n\nmyShell = get_shell\n\nlocalFs = new FS\nconnectionManager = new ConnectionManager\n\nconnectionManager.constructor(myShell)\n\nconnection = connectionManager.getOrConnect(target, port, username, password)\n\nlocalFs.constructor(myShell.host_computer)\n\nfiles = localFs.getTree(localFile)\n\nfor file in files\n\tprint(\"Uploading \" + file.path + \" to \" + remoteFile +  \"...\")\n\tif file.is_folder != true then\n\t\tmyShell.scp(file.path, remoteFile, connection.shell)\n\tend if\nend for\n\n\n",
        "ID": "97499bcd9f369e72a94e8dde9f4fd468",
        "refCount": 2
    },
    {
        "Content": "\n",
        "ID": "68b329da9893e34099c7d8ad5cb9c940",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\n\nargv = new Argv\n\nname = argv.get(0, true)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = \"/home/\" + user + \"/scripts\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\nfs.createFile(folder, name + extension)\n",
        "ID": "cf7cf0a2670fc5e8f0d1fa5f398ee3d7",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\n\nargv = new Argv\n\nname = argv.get(0, true)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = \"/home/\" + user + \"/scripts\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\nfs.createFile(folder, name + extension)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n",
        "ID": "8863a52cd79e31dbc4b5c762d6d83389",
        "refCount": 1
    },
    {
        "Content": "#include library/get-param;\n\n\n",
        "ID": "290693c3262a643790215ac3fd2dd404",
        "refCount": 1
    },
    {
        "Content": "getHomeDirectory = function()\n\tuser = active_user\n\treturn \"/home/\" + user\nend function\n",
        "ID": "d5b93e50a7189aef0aa1a96a5d8f19f9",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\ngetHomeDirectory = function()\n\tuser = active_user\n\treturn \"/home/\" + user\nend function\n\n\nargv = new Argv\n\nname = argv.get(0, true)\ntemplate = argv.get(1)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = getHomeDirectory() + \"/scripts\"\ntemplates = getHomeDirectory() + \"/templates\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\ntemplate = \"\"\n\nif fs.doesFileExist(folder + \"/\" + name + extension) then\n\texit(\"Script already exists.\")\nend if\n\nif fs.doesFileExist(templates + \"/\" + template) then\n\ttemplate = fs.openFile(templates + \"/\" + template).get_content\nelse\n\tprint(\"Template doesn't exist.\")\nend if\n\ncreatedFile = fs.createFile(folder, name + extension)\ncreatedFile.set_content(template)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n\n",
        "ID": "7af211d785e4c604575cf3fb5930dbe5",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\ngetHomeDirectory = function()\n\tuser = active_user\n\treturn \"/home/\" + user\nend function\n\n\nargv = new Argv\n\nname = argv.get(0, true)\ntemplate = argv.get(1)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = getHomeDirectory() + \"/scripts\"\ntemplates = getHomeDirectory() + \"/templates\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\ntemplateContent = \"\"\n\nif fs.doesFileExist(folder + \"/\" + name + extension) then\n\texit(\"Script already exists.\")\nend if\n\nif fs.doesFileExist(templates + \"/\" + template) then\n\ttemplateContent = fs.openFile(templates + \"/\" + template).get_content\nelse\n\tprint(\"Template doesn't exist. Using default\")\n\ttemplateContent = fs.openFile(templates + \"/default\").get_content\nend if\n\ncreatedFile = fs.createFile(folder, name + extension)\ncreatedFile.set_content(template)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n\n",
        "ID": "82dce177ad84b9b794974b038eeaf6a6",
        "refCount": 1
    },
    {
        "Content": "#include library/get-param;\n#include library/fs;\n\nargv = new Argv\n\n//add args\n\n//default variables\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\n//initialize fs\nfs = new FS\n\nfs.constructor(myComputer)\n\n//add code",
        "ID": "5f39930cc22f48a2de10b45f492a042c",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\ngetHomeDirectory = function()\n\tuser = active_user\n\treturn \"/home/\" + user\nend function\n\n\nargv = new Argv\n\nname = argv.get(0, true)\ntemplate = argv.get(1)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = getHomeDirectory() + \"/scripts\"\ntemplates = getHomeDirectory() + \"/templates\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\ntemplateContent = \"\"\n\nif fs.doesFileExist(folder + \"/\" + name + extension) then\n\texit(\"Script already exists.\")\nend if\n\nif fs.doesFileExist(templates + \"/\" + template) then\n\ttemplateContent = fs.openFile(templates + \"/\" + template).get_content\nelse if fs.doesFileExist(templates + \"/default\") then\n\tprint(\"Template doesn't exist. Using default\")\n\ttemplateContent = fs.openFile(templates + \"/default\").get_content\nelse\n\tprint(\"Default template doesn't exist.\")\nend if\n\ncreatedFile = fs.createFile(folder, name + extension)\ncreatedFile.set_content(template)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n\n",
        "ID": "1cd8fa2bdd8dea749bdfdaf20105ed2b",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\ngetHomeDirectory = function()\n\tuser = active_user\n\treturn \"/home/\" + user\nend function\n\n\nargv = new Argv\n\nname = argv.get(0, true)\ntemplate = argv.get(1)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = getHomeDirectory() + \"/scripts\"\ntemplates = getHomeDirectory() + \"/templates\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\ntemplateContent = \"\"\n\nif fs.doesFileExist(folder + \"/\" + name + extension) then\n\texit(\"Script already exists.\")\nend if\n\nprint(templates + \"/default\")\n\nif fs.doesFileExist(templates + \"/\" + template) then\n\ttemplateContent = fs.openFile(templates + \"/\" + template).get_content\nelse if fs.doesFileExist(templates + \"/default\") then\n\tprint(\"Template doesn't exist. Using default\")\n\ttemplateContent = fs.openFile(templates + \"/default\").get_content\nelse\n\tprint(\"Default template doesn't exist.\")\nend if\n\ncreatedFile = fs.createFile(folder, name + extension)\ncreatedFile.set_content(template)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n\n",
        "ID": "9ef0a02d0d66553e26a1cd266757e1d8",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\ngetHomeDirectory = function()\n\tuser = active_user\n\treturn \"/home/\" + user\nend function\n\n\nargv = new Argv\n\nname = argv.get(0, true)\ntemplate = argv.get(1)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = getHomeDirectory() + \"/scripts\"\ntemplates = folder + \"/templates\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\ntemplateContent = \"\"\n\nif fs.doesFileExist(folder + \"/\" + name + extension) then\n\texit(\"Script already exists.\")\nend if\n\nprint(templates + \"/default\")\n\nif fs.doesFileExist(templates + \"/\" + template) then\n\ttemplateContent = fs.openFile(templates + \"/\" + template).get_content\nelse if fs.doesFileExist(templates + \"/default\") then\n\tprint(\"Template doesn't exist. Using default\")\n\ttemplateContent = fs.openFile(templates + \"/default\").get_content\nelse\n\tprint(\"Default template doesn't exist.\")\nend if\n\ncreatedFile = fs.createFile(folder, name + extension)\ncreatedFile.set_content(template)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n\n",
        "ID": "30db84735e6a81b80bec52c7bb9fb629",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\ngetHomeDirectory = function()\n\tuser = active_user\n\treturn \"/home/\" + user\nend function\n\n\nargv = new Argv\n\nname = argv.get(0, true)\ntemplate = argv.get(1)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = getHomeDirectory() + \"/scripts\"\ntemplates = folder + \"/templates\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\ntemplateContent = \"\"\n\nif fs.doesFileExist(folder + \"/\" + name + extension) then\n\texit(\"Script already exists.\")\nend if\n\nprint(templates + \"/default\")\n\nif fs.doesFileExist(templates + \"/\" + template) then\n\ttemplateContent = fs.openFile(templates + \"/\" + template).get_content\nelse if fs.doesFileExist(templates + \"/default\") then\n\tprint(\"Template doesn't exist. Using default\")\n\ttemplateContent = fs.openFile(templates + \"/default\").get_content\nelse\n\tprint(\"Default template doesn't exist.\")\nend if\n\ncreatedFile = fs.createFile(folder, name + extension)\ncreatedFile.set_content(templateContent)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n\n",
        "ID": "2a308c7d29cd97926a6c03ef15849295",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\ngetHomeDirectory = function()\n\tuser = active_user\n\treturn \"/home/\" + user\nend function\n\n\nargv = new Argv\n\nname = argv.get(0, true)\ntemplate = argv.get(1)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = getHomeDirectory() + \"/scripts\"\ntemplates = folder + \"/templates\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\ntemplateContent = \"\"\n\nif fs.doesFileExist(folder + \"/\" + name + extension) then\n\texit(\"Script already exists.\")\nend if\n\nprint(templates + \"/default\")\n\nif fs.doesFileExist(templates + \"/\" + template) then\n\ttemplateContent = fs.openFile(templates + \"/\" + template + \".txt\").get_content\nelse if fs.doesFileExist(templates + \"/default.txt\") then\n\tprint(\"Template doesn't exist. Using default\")\n\ttemplateContent = fs.openFile(templates + \"/default.txt\").get_content\nelse\n\tprint(\"Default template doesn't exist.\")\nend if\n\ncreatedFile = fs.createFile(folder, name + extension)\ncreatedFile.set_content(templateContent)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n\n",
        "ID": "56a2e42a4e51ed3f3a956ea34d3441b6",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\ngetHomeDirectory = function()\n\tuser = active_user\n\treturn \"/home/\" + user\nend function\n\n\nargv = new Argv\n\nname = argv.get(0, true)\ntemplate = argv.get(1)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = getHomeDirectory() + \"/scripts\"\ntemplates = folder + \"/templates\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\ntemplateContent = \"\"\n\nif fs.doesFileExist(folder + \"/\" + name + extension) then\n\texit(\"Script already exists.\")\nend if\n\nprint(templates + \"/default\")\n\nif fs.doesFileExist(templates + \"/\" + template) then\n\ttemplateContent = fs.openFile(templates + \"/\" + template + \".txt\").get_content\nelse if fs.doesFileExist(templates + \"/default.txt\") then\n\tprint(\"Template doesn't exist. Using default\")\n\tprint(fs.openFile(templates + \"/default.txt\"))\n\ttemplateContent = fs.openFile(templates + \"/default.txt\").get_content\nelse\n\tprint(\"Default template doesn't exist.\")\nend if\n\ncreatedFile = fs.createFile(folder, name + extension)\ncreatedFile.set_content(templateContent)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n\n",
        "ID": "44a8b2aec3fd4a4d0c6de8de9b5e43dc",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\ngetHomeDirectory = function()\n\tuser = active_user\n\treturn \"/home/\" + user\nend function\n\n\nargv = new Argv\n\nname = argv.get(0, true)\ntemplate = argv.get(1)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = getHomeDirectory() + \"/scripts\"\ntemplates = folder + \"/templates\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\ntemplateContent = \"\"\n\nif fs.doesFileExist(folder + \"/\" + name + extension) then\n\texit(\"Script already exists.\")\nend if\n\nprint(templates + \"/default\")\n\nif fs.doesFileExist(templates + \"/\" + template) then\n\ttemplateContent = myComputer.File(templates + \"/\" + template + \".txt\").get_content\nelse if fs.doesFileExist(templates + \"/default.txt\") then\n\tprint(\"Template doesn't exist. Using default\")\n\ttemplateContent = myComputer.File(templates + \"/default.txt\").get_content\nelse\n\tprint(\"Default template doesn't exist.\")\nend if\n\ncreatedFile = fs.createFile(folder, name + extension)\ncreatedFile.set_content(templateContent)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n\n",
        "ID": "7e7db1da515eb74c3871a6906266dee3",
        "refCount": 1
    },
    {
        "Content": "#include library/get-param;\n#include library/fs;\n#include library/generic;\n\nargv = new Argv\n\nname = argv.get(0, true)\ntemplate = argv.get(1)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = getHomeDirectory() + \"/scripts\"\ntemplates = folder + \"/templates\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\ntemplateContent = \"\"\n\nif fs.doesFileExist(folder + \"/\" + name + extension) then\n\texit(\"Script already exists.\")\nend if\n\nif fs.doesFileExist(templates + \"/\" + template + \".txt\") then\n\ttemplateContent = myComputer.File(templates + \"/\" + template + \".txt\").get_content\nelse if fs.doesFileExist(templates + \"/default.txt\") then\n\tprint(\"Template doesn't exist. Using default\")\n\ttemplateContent = myComputer.File(templates + \"/default.txt\").get_content\nelse\n\tprint(\"Default template doesn't exist.\")\nend if\n\ncreatedFile = fs.createFile(folder, name + extension)\ncreatedFile.set_content(templateContent)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n\n",
        "ID": "e8eb852823b378cf8bf0cc51c455ba45",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection)\n\tcollection.push(file)\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [])\nend function \n\n\n\n\ngetHomeDirectory = function()\n\tuser = active_user\n\treturn \"/home/\" + user\nend function\n\n\nargv = new Argv\n\nname = argv.get(0, true)\ntemplate = argv.get(1)\n\nuser = active_user\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nfolder = getHomeDirectory() + \"/scripts\"\ntemplates = folder + \"/templates\"\nextension = \".src\"\n\n\nfs = new FS\n\nfs.constructor(myComputer)\n\ntemplateContent = \"\"\n\nif fs.doesFileExist(folder + \"/\" + name + extension) then\n\texit(\"Script already exists.\")\nend if\n\nif fs.doesFileExist(templates + \"/\" + template + \".txt\") then\n\ttemplateContent = myComputer.File(templates + \"/\" + template + \".txt\").get_content\nelse if fs.doesFileExist(templates + \"/default.txt\") then\n\tprint(\"Template doesn't exist. Using default\")\n\ttemplateContent = myComputer.File(templates + \"/default.txt\").get_content\nelse\n\tprint(\"Default template doesn't exist.\")\nend if\n\ncreatedFile = fs.createFile(folder, name + extension)\ncreatedFile.set_content(templateContent)\nexit(\"Created file at \" + folder + \"/\" + name + extension + \"...\")\n\n",
        "ID": "40e02b3d37e1b700ab9520d098778489",
        "refCount": 1
    },
    {
        "Content": "root:15d866b722c8e9b997fd39aba35460f1\nHong-wo:5bf2735d1c93bee7dcf62d29f0a8da2d\nTeinsworto:c80e8bb404c0d20e1617911b2340dc2a\n",
        "ID": "9c0e413124e08de950f19d997a68dc59",
        "refCount": 1
    },
    {
        "Content": "Hong-wo@safeco.com:775b46c7229af94e3e8fc43c1f016a4c",
        "ID": "61bcb6e38072bad6b290672e364ceb6e",
        "refCount": 1
    },
    {
        "Content": "XwxHW1wI:39b3216515ed3a8513e24b0ff4e80de1",
        "ID": "8a98717cbc97f04e3a54897760f93bd5",
        "refCount": 1
    },
    {
        "Content": "Teinsworto@danalog.org:87399272477ee48f908b086f50328c79",
        "ID": "e74feb7f39cb7b13acde86d617493280",
        "refCount": 1
    },
    {
        "Content": "Y9zH33wX:bbba01e2632dcc7542c7275120de14d8",
        "ID": "58ce37b1973e09c6340b23fbb59bfbb7",
        "refCount": 1
    },
    {
        "Content": "172.16.2.6:3306",
        "ID": "a0aa3e63d375719f68d818d40b6c4ab1",
        "refCount": 1
    },
    {
        "Content": "<?xml version=\"1.0\" encoding=\"utf-16\"?>\n<ContentFichas xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>258971793</telefono>\n    <mailAddress>Quister@swifth.org</mailAddress>\n    <faceParts>Mujer/Base_c;Mujer/Ears_a;Mujer/Eyes_b;Mujer/Hair_b;Mujer/Nose_b;Mujer/Mouth_c;Mujer/Neck_a;Accesorios/earing;Accesorios/piercing;Accesorios/glasses</faceParts>\n    <faceScales>-1.049571,0.9640617,0,0;-1.049571,0.9855568,0,0;-0.9380276,0.957356,0,0.1585733;-1.049571,0.9404316,0,0;-1.016158,0.9884732,0,-0.6892027;-0.6700876,0.8675995,0,-5.480085;-1.049571,1,0,0;-1.049571,0.9855568,0.75,0;-1.049571,0.9640617,0,0;-1.049571,0.9640617,0,0</faceScales>\n    <nombreCompleto>Dayna Quister</nombreCompleto>\n    <edad>63</edad>\n    <horario>10:00 - 16:30</horario>\n    <idPersona>119774cd-addf-4c0c-8e93-1cfdc1b632fe</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>679342411</telefono>\n    <mailAddress>Hong-wo@safeco.com</mailAddress>\n    <faceParts>Hombre/Base_b;Hombre/Ears_a;Hombre/Eyes_d;Hombre/Hair_b;Hombre/Nose_b;Hombre/Mouth_b;Hombre/Neck_a;Accesorios/glasses;Accesorios/piercing2;Accesorios/beard1</faceParts>\n    <faceScales>1.00884,1.04556,0,0;1.00884,1.01934,0,0;0.9260115,1.050394,0,0.2341633;1.00884,0.9882201,0,0;0.7981937,0.7797725,0,0.06752674;1.062026,0.9851973,0,-0.8283733;1.00884,1,0,0;1.00884,1.04556,0,0;1.00884,1.04556,0,0;1.00884,1.04556,0,0</faceScales>\n    <nombreCompleto>Court Hong-wo</nombreCompleto>\n    <edad>53</edad>\n    <horario>08:45 - 15:15</horario>\n    <idPersona>31ee94be-3666-4446-a074-6219bdd70b1d</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>837275473</telefono>\n    <mailAddress>Teinsworto@danalog.org</mailAddress>\n    <faceParts>Mujer/Base_c;Mujer/Ears_b;Mujer/Eyes_c;Mujer/Hair_b;Mujer/Nose_b;Mujer/Mouth_c;Mujer/Neck_b;Accesorios/glasses2</faceParts>\n    <faceScales>-0.9652622,1.099535,0,0;-0.9652622,1.064596,0,0;-0.8603311,0.9338257,0,-0.6491424;-0.9652622,0.9931245,0,0;-0.9586774,0.8035594,0,0.4963436;-0.6737636,0.9675528,0,-0.004942;-0.9652622,1,0,0;-0.9652622,1.099535,0,0</faceScales>\n    <nombreCompleto>Monica Teinsworto</nombreCompleto>\n    <edad>34</edad>\n    <horario>09:45 - 16:15</horario>\n    <idPersona>e124a898-7a86-40e6-8a89-6c410fcdd283</idPersona>\n    <incidencias />\n  </Ficha>\n</ContentFichas>",
        "ID": "e7bc8352393b92fcb958a6e9c04b465b",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"112.58.71.88\",\"fecha\":\"14-1-1990 22:12\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "9a24385feed7d0e42c47a1f161c02f0a",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"168.42.167.182\",\"fecha\":\"22-1-1990 03:47\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true}]}",
        "ID": "ffe0a3ffaf18d42a5fcf2d34da115b88",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":4,\"ip\":\"192.168.0.2\",\"fecha\":\"22-1-1990 03:47\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"152.196.125.79\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "f9d8a724a9b5837d3e80a34e8f3da9fb",
        "refCount": 2
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"168.42.167.182\",\"fecha\":\"22-1-1990 03:47\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true},{\"action\":2,\"ip\":\"168.42.167.182\",\"fecha\":\"22-1-1990 03:47\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true},{\"action\":1,\"ip\":\"168.42.167.182\",\"fecha\":\"22-1-1990 04:07\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true}]}",
        "ID": "ca9434f0e4090b3f8c6d0938347bfaff",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\n\n\n\n\n\nargv = new Argv\n\n//add args\nfilter = argv.get(0, true)\n\n//default variables\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\n//initialize fs\nfs = new FS\n\nfs.constructor(myComputer)\n\n//add code\nitems = fs.getTree(\"/\", filter)\n\nif items.len == 0 then\n\texit(\"Nothing found.\")\nend if\n\nfor item in items\n\tprint(\"Found \" + item.path + \"...\")\nend for\n\nexit(\"Done!\")\n",
        "ID": "e11005396f1207d5018bfdeac37e8e85",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"8-1-1990 14:33\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"12-1-1990 18:19\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"12-1-1990 18:37\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"12-1-1990 19:57\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"12-1-1990 20:36\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"12-1-1990 20:54\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 01:04\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 03:01\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 03:05\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 03:22\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 03:32\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 03:59\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 04:21\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 04:31\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 04:33\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 04:39\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 04:46\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 04:50\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 05:03\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 05:25\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 05:27\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"13-1-1990 05:32\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.5\",\"fecha\":\"13-1-1990 15:51\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"22-1-1990 03:31\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.0.4\",\"fecha\":\"22-1-1990 11:01\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "170c8b1697fd634f518e510daf378b28",
        "refCount": 1
    },
    {
        "Content": "myclass = {}\nmyclass.method = function(arg1)\n\tprint(\"hey\")\n\tprint(arg1)\nend function\n\n\nmyclass[\"method\"](\"test\")\n",
        "ID": "5252116569f02ee84f9c4dc42d428b01",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\n\nargv = new Argv\narg1 = argv.get(0)\n\nmyclass = {}\nmyclass.method = function(arg1)\n\tprint(\"hey\")\n\tprint(arg1)\nend function\n\nprint(myclass[arg1] == null)\n\nmyclass[arg1](\"test\")\n",
        "ID": "6ffd3119787d589f9093b4e54fe4359e",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\n\nargv = new Argv\narg1 = argv.get(0)\n\ncallback = function(something)\n\tprint(something)\nend function\n\nothermethod = function(cb)\n\tcb(\"test\")\nend function\n\nothermethod(callback)\n",
        "ID": "a51738e3d40e6739eec9edf3b9ad24a1",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\n\nargv = new Argv\narg1 = argv.get(0)\n\ncallback = function(something)\n\tprint(something)\n\tprint(\"was\")\nend function\n\nothermethod = function(cb)\n\tcb(\"test\")\nend function\n\nothermethod(callback)\n",
        "ID": "9af9e7d328a34251af2177a5cb2c2dc4",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\n\nargv = new Argv\narg1 = argv.get(0)\n\ncallback = function(a,b)\n\tprint(a)\n\tprint(\"was\")\nend function\n\nothermethod = function(cb)\n\tcb(\"test\", \"klar\")\nend function\n\nothermethod(callback)\n",
        "ID": "838c6c9b92864fb8a9f64013cd1f5a43",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\n\n\n\n\nargv = new Argv\narg1 = argv.get(0)\n\ncallback = function(a,b)\n\tprint(a)\n\tprint(b)\n\tprint(\"was\")\nend function\n\nothermethod = function(cb)\n\tcb(\"test\", \"klar\")\nend function\n\nothermethod(callback)\n",
        "ID": "13d635343a4cb71d539f8c4baa966a1b",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\t\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nPath.getBase = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\n\tresult = path.split(\"/\")\n\tresult.pop()\n\treturn result.join(\"/\")\nend function\n\nPath.getFilename = function(path)\n\tif path == null then\n\t\treturn \"\"\n\tend if\n\t\n\tresult = path.split(\"/\")\n\treturn result.pop()\nend function\n\nFS = {}\n\nFS.createFile = function(computer, path, name)\n\tcomputer.touch(path, name)\n\treturn computer.File([path, name].join(\"/\"))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/scripts\"\nend function\n\nConfig.getTempFolder = function()\n\tuser = active_user\n\treturn \"/home/\" + user + \"/tmp\"\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nDependency = {}\n\nDependency.constructor = function(computer, importCode, path)\n\tpathHelper = new Path\n\t\n\tself.importCode = importCode\n\tself.path = path\n\tself.basePath = pathHelper.getBase(path)\n\tself.computer = computer\n\tself.target = computer.File(path)\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\texit(\"Dependency \" + path + \" does not exist...\")\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcontent = self.target.get_content\n\tresult = []\n\tindex = content.indexOf(\"#include\")\n\tendIndex = content.indexOf(\";\", index)\n\t\n\twhile index != null\n\t\timport = slice(content, index, endIndex + 1)\n\t\tparsed = import.split(\" \")\n\t\tpath = slice(parsed[1], 0, parsed[1].len - 1)\n\t\tdependency = new Dependency\n\t\t\n\t\tdependency.constructor(self.computer, import, pathHelper.join(self.basePath, path + \".\" + config.getExtension()))\n\t\tdependency.findDependencies()\n\t\t\n\t\tresult.push(dependency)\n\t\t\n\t\tindex = content.indexOf(\"#include\", endIndex)\n\t\tendIndex = content.indexOf(\";\", endIndex)\n\tend while\n\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nDependencies.getAllDependencies = function()\n\tdep\n\t\n\tif (self.dependencies)\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.doImports = function()\n\tthisFile = new Dependency\n\tthisFile.constructor(self.computer, null, self.getFullScriptFilePath())\n\texistingDependencies = [] + dependencies\n\tcontent = thisFile.target.get_content\n\tcollect = function(dependencies)\n\t\t\n\tend function\n\n\tcollect(thisFile.findDependencies())\n\n\tfor dependency in dependencies\n\t\tif dependency.target == null then\n\t\t\texit(\"Cannot find \" + dependency.path + \"...\")\n\t\tend if\n\n\t\tprint(\"Importing \" + dependency.path + \"...\")\n\n\t\tcontent = content.replace(dependency.importCode, dependency.target.get_content)\n\tend for\n\n\treturn content\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\tcontent = self.doImports()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\tprint(buildReport)\n\t\texit(\"Couldn't build file for unknown reason...\")\n\tend if\nend function\n\nmain = function(name)\n\tcompiler = new Compiler\n\tfs = new FS\n\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler.constructor(myComputer, name)\n\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n\n\n\n",
        "ID": "d3c076f29402e1788ecfb0f37ebf99d0",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":1,\"ip\":\"112.58.71.88\",\"fecha\":\"19-1-1990 07:34\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":0,\"ip\":\"112.58.71.88\",\"fecha\":\"22-1-1990 03:31\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":2,\"ip\":\"112.58.71.88\",\"fecha\":\"22-1-1990 03:31\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"168.42.167.182\",\"fecha\":\"22-1-1990 03:47\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"152.196.125.79\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":1,\"ip\":\"112.58.71.88\",\"fecha\":\"22-1-1990 10:52\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":0,\"ip\":\"112.58.71.88\",\"fecha\":\"22-1-1990 11:01\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":2,\"ip\":\"112.58.71.88\",\"fecha\":\"22-1-1990 11:01\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":1,\"ip\":\"112.58.71.88\",\"fecha\":\"31-1-1990 11:05\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "656f7a92d356ec770e39fe91db2572cc",
        "refCount": 1
    },
    {
        "Content": "foo = {}\n\nfoo.constructor = function()\n\tself.test = \"abc\"\n\t\n\treturn self\nend function\n\nfoo.toString = function()\n\treturn self.test\nend function\n\nprint(new foo.constructor().toString())\n",
        "ID": "2ed02f123ac955233d15b6347ce36289",
        "refCount": 1
    },
    {
        "Content": "foo = {}\n\nfoo.constructor = function()\n\tself.test = \"abc\"\n\t\n\treturn self\nend function\n\nfoo.toString = function()\n\treturn self.test\nend function\n\ninstance = new foo.constructor()\n\nprint(instance.toString())\n",
        "ID": "51e07e647b6c78d001784676aeb5cb59",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn str\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\na = new String.constructor(\"You are: $0!!!!\")\nprint(a.parse([\"shit\"]))\n",
        "ID": "268310e52e7f75461f2ca03b4860e048",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\na = new String.constructor(\"You are: $0!!!!\")\nprint(a.parse([\"shit\"]))\n",
        "ID": "7cf615c302370da356f96eec82d188fc",
        "refCount": 1
    },
    {
        "Content": "foo = {}\n\n\nfoo[md5(\"12345t\")] = function()\n\tprint(\"hey\")\nend function\n\nfoo[md5(\"12345a\")] = function()\n\tprint(\"hey\")\nend function\n",
        "ID": "43a13ba00f5c83e65f31016235a0ce52",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\na = new String.constructor(\"You are: $0!!!!\")\nprint(a.parse([\"shit\"]))\nprint((new String.constructor(\"You are: $0!!!!\")).parse([\"test\"]))\n\n",
        "ID": "793250344d63720b5841099d141854a1",
        "refCount": 2
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\na = new String.constructor(\"You are: $0!!!!\")\nprint(a.parse([\"shit\"]))\nprint(new String.constructor(\"You are: $0!!!!\").parse([\"test\"]))\n\n",
        "ID": "f0fc557f06202acac7894dc8b3e109c4",
        "refCount": 2
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nString.substr = function(a, b)\n\treturn self.str[a:b]\nend function\n\na = new String.constructor(\"You are: $0!!!!\")\nprint(a.parse([\"shit\"]))\nprint((new String.constructor(\"You are: $0!!!!\")).parse([\"test\"]))\n\nprint(a.substr(1))\n\n",
        "ID": "8fc1577de5b62a02dd5babd78da110b6",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nString.substr = function(a, b)\n\treturn self.str[a:b]\nend function\n\na = new String.constructor(\"You are: $0!!!!\")\nprint(a.parse([\"shit\"]))\nprint((new String.constructor(\"You are: $0!!!!\")).parse([\"test\"]))\n\nprint(a.substr(null,1))\n\n",
        "ID": "f36887520af23c525dec7abe9e3bb08c",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nString.substr = function(a, b)\n\treturn self.str[a:b]\nend function\n\na = new String.constructor(\"You are: $0!!!!\")\nprint(a.parse([\"shit\"]))\nprint((new String.constructor(\"You are: $0!!!!\")).parse([\"test\"]))\n\nprint(a.substr(null,2))\n\n",
        "ID": "8a807bc672eafca561b64a9d01239790",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nString.substr = function(a, b)\n\treturn self.str[a:b]\nend function\n\na = new String.constructor(\"You are: $0!!!!\")\nprint(a.parse([\"shit\"]))\nprint((new String.constructor(\"You are: $0!!!!\")).parse([\"test\"]))\n\nprint(a.substr(-1))\n\n",
        "ID": "720585554a8a3991ff0e092d759cee9e",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nString.substr = function(a, b)\n\treturn self.str[a:b]\nend function\n\na = new String.constructor(\"You are: $0!!!!\")\nprint(a.parse([\"shit\"]))\nprint((new String.constructor(\"You are: $0!!!!\")).parse([\"test\"]))\n\nprint(a.substr(-1))\n\ntest = {}\n\ntest.what = function(a)\n\tprint(\"h\"+a)\nend function\n\nmmm = test.what\n\nmmm(\"1\")\n\n",
        "ID": "53503c509209b5aad77c46b17d94a96b",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nString.substr = function(a, b)\n\treturn self.str[a:b]\nend function\n\na = new String.constructor(\"You are: $0!!!!\")\nprint(a.parse([\"shit\"]))\nprint((new String.constructor(\"You are: $0!!!!\")).parse([\"test\"]))\n\nprint(a.substr(-1))\n\ntest = {}\n\ntest.what = function(a)\n\tprint(\"h\"+a)\nend function\n\nmmm = \"what\"\n\ntest[mmm](\"1\")\n\n",
        "ID": "4e74fdf71f3291ab21447e6df799d0de",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values)\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user])\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user])\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTCommands[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analzye()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\texit(\"TESTING\")\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "3a20f1d6e8fddda0179b43ef1e90cd75",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values)\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user])\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user])\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTCommands[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\tprint(command)\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analzye()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\texit(\"TESTING\")\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "ad2f02cff25c184f321fc567e47d3e7c",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values)\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error.constructor(\"Error cannot find param[$0]\", [index])).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user])\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user])\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTCommands[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\tprint(command)\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analzye()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\texit(\"TESTING\")\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "510b5d5216043f89e2788f2bf2c47e25",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user])\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user])\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTCommands[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\tprint(command)\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analzye()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\texit(\"TESTING\")\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\texit(\"Cannot find file.\")\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "3eb36381f928737d6246a55c140c74d7",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user])\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user])\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTCommands[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\tprint(command)\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analzye()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\texit(\"TESTING\")\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "b86d7f02be5bd4c888e30e0fb10d6397",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTCommands[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\tprint(command)\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analzye()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(self.computer, buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\n\texit(\"TESTING\")\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "4a3e01debf40af953c460805c14f0285",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTCommands[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\tprint(command)\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analzye()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "89e50fdf14f2a04d2a623ba358620154",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTCommands[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\tprint(command)\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analzye()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "48a7c3165d2dcb2b1120cb94220633b6",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTCommands[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\tprint(command)\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "cdcaa986749f87a509e2803c66692d24",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\tprint(command)\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "5cc0451b960470272e2a04a3e071db54",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\tprint(commands)\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "0740d6e2ec98eec9a670ac751c159852",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "76147058e14a63cec9855288dddd44fe",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "989bd5c45d996a1e54a8ca0e97dbc3bc",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "266cf5d5a1a1063bc86e6b1e260cb07e",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommands.push({line: index, str: str, key: key})\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "1c4e84196790509638dd089d258ac1a6",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "c29fcc7b4cc3b47f9cc974b65094b8d7",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + Config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "2ce833ddce263d591efd2ae190d47d23",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str(str.indexOf(\" \"), str.indexOf(\";\"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "7e377135b8181db72e4347ec28240fd7",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.substr(str.indexOf(\" \"), str.indexOf(\";\")).toString()\n\t\t\tprint(path)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "ce346aad783368a0b074e58ddff7b275",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(str.indexOf(\" \"), str.indexOf(\";\")).toString()\n\t\t\tprint(path)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "a1a4d1741a7efd2203dc0473c46521e8",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(path)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "199f4306295bb687584241c895f1fc10",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str.indexOf(\" \"))\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "3e68b4bdddb262f42eb88c9e2f11e2af",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "6420f8c209a36e63071ad3bd5ec35abb",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tprint(command.str)\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "d8f7690f501b4f0b4d72c59ce98a2fa3",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tprint(str.toString())\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tprint(command.str)\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "d9db000ed86538e87f45b6f7548723ec",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tprint(str.toString())\n\t\t\tprint(line)\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tprint(command.str)\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "9f7e5941d1219b6167c1eff55d5ea3e9",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\tprint(str.toString())\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tprint(str.toString())\n\t\t\tprint(line)\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tprint(command.str)\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "8a4037c98f6bbb29ce7c65b1817be231",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\tprint(new String.constructor(line))\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tprint(str.toString())\n\t\t\tprint(line)\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tprint(command.str)\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "0f27a0dcd6ba6c6a769098497a6b761a",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(self.str[startIndex:endIndex])\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tprint(new String.constructor(line))\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tprint(str.toString())\n\t\t\tprint(line)\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tprint(command.str)\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "1d6cc033db48dda0b4af63931e3be62c",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tprint(new String.constructor(line))\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tprint(str.toString())\n\t\t\tprint(line)\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tprint(command.str)\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "4a63bb6c223b4bf45a1450c60afdd046",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tprint(\"1\")\n\t\t\tprint(str.toString())\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tprint(str.toString())\n\t\t\tprint(line)\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tprint(command.str)\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "8932fc7bd81f7c890820f436f6645788",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn new String.constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn new String.constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn new String.constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn new String.constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tprint(\"1\")\n\t\t\tprint(str.toString())\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tprint(\"2\")\n\t\t\tprint(str.toString())\n\t\t\tprint(line)\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tprint(command.str)\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "567f20c3654e00a61c6e46c07cb4c876",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = new String.constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = new String.constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = new String.constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tprint(\"1\")\n\t\t\tprint(str.toString())\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tprint(\"2\")\n\t\t\tprint(str.toString())\n\t\t\tprint(line)\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = new ASTCommand.constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tprint(command)\n\t\tprint(command.line+\":\"+command.key)\n\t\tif (command.key == \"include\") then\n\t\t\tprint(command.str)\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(command.str)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = new AST.constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = new Dependency.constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = new AST.constructor(self.computer, file)\n\tast.analyze()\n\tdependency = new Dependency.constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = new Preprocessor.constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = new FS.constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = new Compiler.constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "060f0f5ce032d59c9cbadb0dfd662a3b",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = my.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "236a8e72c1159277e4dd619ad83a5145",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "a2ea0708a3ee94e8c2e6701c105eee94",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "3472ae83d93ea72012b66807ed8f05ff",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(path)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "70d83a229ba30f0dd54e78410451d923",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \"), command.str.indexOf(\";\")).toString()\n\t\t\tprint(path)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tprint(filePath)\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "83547166530101f2886e2fcf6598f0df",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \") + 1, command.str.indexOf(\";\")).toString()\n\t\t\tprint(path)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tprint(filePath)\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "914736329c50eb36c1cbcdd7e70dceab",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \") + 1, command.str.indexOf(\";\")).toString()\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "33607ff26293e670a1c39f44cfce974c",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTInclude = {}\n\nASTInclude.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.include = ASTInclude\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"include\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\" \") + 1, command.str.indexOf(\";\")).toString()\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tprint(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "9320135ea007e7525e61a6eedb0b66a1",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTTransform = {}\n\nASTTransform.constructor = function(header, line)\n\tself.header = header\n\tself.line = line\n\treturn self\nend function\n\nASTImportTransform = {}\n\nASTImportTransform.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportTransform\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 1, command.str.indexOf(\";\")).toString().trim()\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "120f584819300ed7f566836155c2f5d0",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTTransform = {}\n\nASTTransform.constructor = function(header, line)\n\tself.header = header\n\tself.line = line\n\treturn self\nend function\n\nASTImportTransform = {}\n\nASTImportTransform.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportTransform\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 1, command.str.indexOf(\";\")).toString().trim()\n\t\t\tprint(path)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "cdd04beedf3dfbfe2f180d7402916be6",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTTransform = {}\n\nASTTransform.constructor = function(header, line)\n\tself.header = header\n\tself.line = line\n\treturn self\nend function\n\nASTImportTransform = {}\n\nASTImportTransform.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportTransform\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString().trim()\n\t\t\tprint(path)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "98f03f589f174d9453ac0b7192368f24",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTTransform = {}\n\nASTTransform.constructor = function(header, line)\n\tself.header = header\n\tself.line = line\n\treturn self\nend function\n\nASTImportTransform = {}\n\nASTImportTransform.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportTransform\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\timport(command.str.toString())\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString().trim()\n\t\t\tprint(path)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "d93951bdf356bed1f610c5d365637f04",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTTransform = {}\n\nASTTransform.constructor = function(header, line)\n\tself.header = header\n\tself.line = line\n\treturn self\nend function\n\nASTImportTransform = {}\n\nASTImportTransform.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportTransform\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tprint(command.str.toString())\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString().trim()\n\t\t\tprint(path)\n\t\t\tfilePath = pathHelper.join(self.basePath, path + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "ff46eb62b7b52e0145f805850c3b6f99",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTTransform = {}\n\nASTTransform.constructor = function(header, line)\n\tself.header = header\n\tself.line = line\n\treturn self\nend function\n\nASTImportTransform = {}\n\nASTImportTransform.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportTransform\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == \"\") then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0...\", [command.line]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "e37cdb7fcacf67e40f60631bdbe8a4e3",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTTransform = {}\n\nASTTransform.constructor = function(header, line)\n\tself.header = header\n\tself.line = line\n\treturn self\nend function\n\nASTImportTransform = {}\n\nASTImportTransform.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportTransform\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0...\", [command.line]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "81e99e97388c3d51944783cdb71b2332",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTTransform = {}\n\nASTTransform.constructor = function(header, line)\n\tself.header = header\n\tself.line = line\n\treturn self\nend function\n\nASTImportTransform = {}\n\nASTImportTransform.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportTransform\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\t\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "6eeef5ab3c3f9a4edfb42f27bc8e0f12",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTTransform = {}\n\nASTTransform.constructor = function(header, line)\n\tself.header = header\n\tself.line = line\n\treturn self\nend function\n\nASTImportTransform = {}\n\nASTImportTransform.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportTransform\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tprint(self.dependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "0156a04b6b6dba8920af62a90ec4cf6e",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTTransform = {}\n\nASTTransform.constructor = function(header, line)\n\tself.header = header\n\tself.line = line\n\treturn self\nend function\n\nASTImportTransform = {}\n\nASTImportTransform.constructor = function()\n\t\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportTransform\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tprint(self.dependency.dependencies)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "ddbe495e7152b662fe07d40578ceb39a",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTRegistry = {}\n\nASTRegistry.import = true\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.file.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\tprint(command)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(item)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "94e4d6ff806449067b8d7ee59add0586",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = true\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.file.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\tprint(command)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(item)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "9244f5741e3dce3d966a10d6d8d77959",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = true\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\tprint(command)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(item)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "8beb0c5652032e67d407a2a758dcff1a",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = true\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\tprint(command)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "cfa1d21ce17e79050505cb1235a265f8",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = true\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\tprint(command.str)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "bbfc78b411befe2ff10f770db253962b",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = true\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tentry = (new ASTCommand).constructor(index, str, key)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\tprint(command.str.toString())\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "00a5015819ea732fc6f2d836d67594fd",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefinition = command.str.substr(importIndex + 6, fromIndex)\n\t\t\t\n\t\t\tprint(command.str.toString())\n\t\t\tprint(command.action.file.path)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "f2b3622e662e5703a699af77cb6d5156",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefinition = command.str.substr(importIndex + 6, fromIndex)\n\t\t\t\n\t\t\tprint(definition)\n\t\t\tprint(command.action.file.path)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "56c54053d790a81a1b380c29230423ad",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefinition = command.str.substr(importIndex + 6, fromIndex)\n\t\t\t\n\t\t\tprint(definition.toString())\n\t\t\tprint(command.action.file.path)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "a1d297c07fa909aa8be634a71a1e3e3b",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefinition = command.str.substr(importIndex + 7, fromIndex)\n\t\t\t\n\t\t\tprint(definition.toString())\n\t\t\tprint(command.action.file.path)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "4589eccbd32c7c2a7f8dd3c2160e4f87",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefinition = command.str.substr(importIndex + 6, fromIndex).trim()\n\t\t\t\n\t\t\tprint(definition.toString())\n\t\t\tprint(command.action.file.path)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "691b191fdcf74fb49abbb27b32b5c3a8",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\tprint(code.toString())\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "0c3fb66c9fa23ee7923bbc353a32d650",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in item.ast.commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\tprint(code.toString())\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "72cf88e7ff9814124e9e45bb521dca94",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\treturn self.lines[0:line] + [code] + self.lines[line + 1:]\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\ttransformed = item.ast.transform(command.line, code)\n\t\t\t\n\t\t\tprint(code.toString())\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "624fc04645d1cecc707f3272abce89c9",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\treturn self.lines[0:line] + [code] + self.lines[line + 1:]\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\ttransformed = item.ast.transform(command.line, code)\n\t\t\t\n\t\t\tprint(code.toString())\n\t\t\tprint(transformed)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "39edc2370de59ae76255acc0d488f430",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\treturn self.lines[0:line] + [code] + self.lines[line + 1:]\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\ttransformed = item.ast.transform(command.line, code.toString())\n\t\t\t\n\t\t\tprint(code.toString())\n\t\t\tprint(transformed)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "e4c401db6f645722f5e2d753254eb66a",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\ttransformations = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tprint(moduleName)\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\ttransformed = item.ast.transform(command.line, code.toString())\n\t\t\t\n\t\t\tprint(code.toString())\n\t\t\tprint(transformed)\n\t\tend for\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "34a5cd91af7245f22f6032781e33293c",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\".parse([moduleName]).toString()))\n\t\t\tnewLines.push(\"if (export == null) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + commands.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return export\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines.join(\"\\n\")\n\t\t\tprint(modules[moduleName])\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "f3877fd12e82280a0d66d03115e6841f",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"if (export == null) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + commands.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return export\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines.join(\"\\n\")\n\t\t\tprint(modules[moduleName])\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "ccba3ecb51ae79081af55bb825386e4e",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"if (export == null) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return export\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines.join(\"\\n\")\n\t\t\tprint(modules[moduleName])\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "ce7d4c16f81dedd9c41a35dc3d019b66",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules[moduleName] != null) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"if (export == null) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return export\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\tnewLines = []\n\t\n\tfor module in modules\n\t\tnewLines = module + newLines\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\tprint(newLines.join(\"\\n\"))\n\n\titerator(mainDependency)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "346fad177139e1534a32f2a9592b5e3a",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules[moduleName] != null) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"if (export == null) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return export\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\n\t\n\tnewLines = []\n\t\n\tfor module in modules\n\t\tnewLines = module + newLines\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\tprint(newLines.join(\"\\n\"))\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "8aa84b5ad7cab7cd1e470583aa84bf41",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"if (export == null) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return export\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\n\t\n\tnewLines = []\n\t\n\tfor module in modules\n\t\tnewLines = module + newLines\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\tprint(newLines.join(\"\\n\"))\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "060faf6f8108ead81dbbb051c2776a89",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"if (export == null) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return export\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\n\t\n\tnewLines = []\n\t\n\tfor module in modules.values\n\t\tnewLines = module + newLines\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\tprint(newLines.join(\"\\n\"))\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\texit(\"TESTING\")\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "ab296abe6e1fd77c52f188a02a9d32e1",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"if (export == null) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return export\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\n\t\n\tnewLines = []\n\t\n\tnewLines.push(\"MODULES = {}\")\n\tnewLines.push(\"__require = function(r)\")\n\tnewLines.push(\"return MODULES[r]\")\n\tnewLines.push(\"end function\")\n\t\n\tfor module in modules.values\n\t\tnewLines = module + newLines\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\treturn newLines.join(\"\\n\")\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "671a823b8320d9a6eb3906eb3af78513",
        "refCount": 1
    },
    {
        "Content": "MODULES[\"52edf8f54a3b49ab67736352e981402c\"] = function()\nif (export == null) then\ncodeBlock = function()\nexport = \"lol\"\nend function\ncodeBlock()\nend if\nreturn export\nend function\nMODULES[\"36ef606d661239c7fed32347a1278cdc\"] = function()\nif (export == null) then\ncodeBlock = function()\nexport = \"was\"\nend function\ncodeBlock()\nend if\nreturn export\nend function\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMAIN = function()\ntest2 = __require(\"36ef606d661239c7fed32347a1278cdc\")\ntest3 = __require(\"52edf8f54a3b49ab67736352e981402c\")\n\nprint(test2)\nprint(test3)\nend function\nMAIN()",
        "ID": "d9719753ca6e1c2eacf0be2276d395ca",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"if (export == null) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return export\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\n\t\n\tnewLines = []\n\t\n\tnewLines.push(\"MODULES = {}\")\n\tnewLines.push(\"__require = function(r)\")\n\tnewLines.push(\"return MODULES[r]\")\n\tnewLines.push(\"end function\")\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\treturn newLines.join(\"\\n\")\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "138728f78c2bf14774d80c1b6febcaec",
        "refCount": 1
    },
    {
        "Content": "print(1)\nMODULES = {}\nprint(2)\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"36ef606d661239c7fed32347a1278cdc\"] = function()\nif (export == null) then\ncodeBlock = function()\nexport = \"was\"\nend function\ncodeBlock()\nend if\nreturn export\nend function\nMODULES[\"52edf8f54a3b49ab67736352e981402c\"] = function()\nif (export == null) then\ncodeBlock = function()\nexport = \"lol\"\nend function\ncodeBlock()\nend if\nreturn export\nend function\nMAIN = function()\ntest2 = __require(\"36ef606d661239c7fed32347a1278cdc\")\ntest3 = __require(\"52edf8f54a3b49ab67736352e981402c\")\n\nprint(test2)\nprint(test3)\nend function\nMAIN()\n",
        "ID": "6a03da28b8f4ae87e4011fff8d31dbb6",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"module = {}\")\n\t\t\tnewLines.push(\"if (module.exports == null) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return module.exports\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\n\t\n\tnewLines = []\n\t\n\tnewLines.push(\"MODULES = {}\")\n\tnewLines.push(\"__require = function(r)\")\n\tnewLines.push(\"return MODULES[r]\")\n\tnewLines.push(\"end function\")\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\treturn newLines.join(\"\\n\")\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "cc9975783b66c9278989b71bfd44378c",
        "refCount": 1
    },
    {
        "Content": "module.exports = \"lol\"",
        "ID": "f393889b310dfcaed425d236cbf8cbed",
        "refCount": 1
    },
    {
        "Content": "MODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"36ef606d661239c7fed32347a1278cdc\"] = function()\nmodule = {}\nif (module.exports == null) then\ncodeBlock = function()\nmodule.exports = \"was\"\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"52edf8f54a3b49ab67736352e981402c\"] = function()\nmodule = {}\nif (module.exports == null) then\ncodeBlock = function()\nmodule.exports = \"lol\"\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ntest2 = __require(\"36ef606d661239c7fed32347a1278cdc\")\ntest3 = __require(\"52edf8f54a3b49ab67736352e981402c\")\n\nprint(test2)\nprint(test3)\nend function\nMAIN()",
        "ID": "1f47052db639545f7ec97a0f42360281",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"module = {}\")\n\t\t\tnewLines.push(\"if (module.hasIndex(\"\"exports\"\")) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return module.exports\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\n\t\n\tnewLines = []\n\t\n\tnewLines.push(\"MODULES = {}\")\n\tnewLines.push(\"__require = function(r)\")\n\tnewLines.push(\"return MODULES[r]\")\n\tnewLines.push(\"end function\")\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\treturn newLines.join(\"\\n\")\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "5c096c8439ad4aca68d06fa9c6516811",
        "refCount": 1
    },
    {
        "Content": "MODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"36ef606d661239c7fed32347a1278cdc\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\")) then\ncodeBlock = function()\nmodule.exports = \"was\"\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"52edf8f54a3b49ab67736352e981402c\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\")) then\ncodeBlock = function()\nmodule.exports = \"lol\"\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ntest2 = __require(\"36ef606d661239c7fed32347a1278cdc\")\ntest3 = __require(\"52edf8f54a3b49ab67736352e981402c\")\n\nprint(test2)\nprint(test3)\nend function\nMAIN()",
        "ID": "2b22b976fd389156e13379d08f234e47",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"module = {}\")\n\t\t\tnewLines.push(\"if (!module.hasIndex(\"\"exports\"\")) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return module.exports\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\n\t\n\tnewLines = []\n\t\n\tnewLines.push(\"MODULES = {}\")\n\tnewLines.push(\"__require = function(r)\")\n\tnewLines.push(\"return MODULES[r]\")\n\tnewLines.push(\"end function\")\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\treturn newLines.join(\"\\n\")\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "974b8c02cd0003678f83328442aecbe6",
        "refCount": 1
    },
    {
        "Content": "String = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(\"\\n\")\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(\"#\")) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"module = {}\")\n\t\t\tnewLines.push(\"if (module.hasIndex(\"\"exports\"\") == false) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return module.exports\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\n\titerator(mainDependency)\n\t\n\tnewLines = []\n\t\n\tnewLines.push(\"MODULES = {}\")\n\tnewLines.push(\"__require = function(r)\")\n\tnewLines.push(\"return MODULES[r]\")\n\tnewLines.push(\"end function\")\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\treturn newLines.join(\"\\n\")\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "87beecd9c47481a220d82a87a3fc8095",
        "refCount": 1
    },
    {
        "Content": "MODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"36ef606d661239c7fed32347a1278cdc\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nmodule.exports = \"was\"\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"52edf8f54a3b49ab67736352e981402c\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nmodule.exports = \"lol\"\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ntest2 = __require(\"36ef606d661239c7fed32347a1278cdc\")\ntest3 = __require(\"52edf8f54a3b49ab67736352e981402c\")\n\nprint(test2)\nprint(test3)\nend function\nMAIN()",
        "ID": "956fae95bdc9acf3a67f37368ae64104",
        "refCount": 1
    },
    {
        "Content": "#import test3 from testdep3;\n\nmodule.exports = \"was\" + test3",
        "ID": "2d0b991fa4afd16049821e1362292de0",
        "refCount": 1
    },
    {
        "Content": "MODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"36ef606d661239c7fed32347a1278cdc\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\ntest3 = __require(\"52edf8f54a3b49ab67736352e981402c\")\n\nmodule.exports = \"was\" + test3\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"52edf8f54a3b49ab67736352e981402c\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nmodule.exports = \"lol\"\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ntest2 = __require(\"36ef606d661239c7fed32347a1278cdc\")\ntest3 = __require(\"52edf8f54a3b49ab67736352e981402c\")\n\nprint(test2)\nprint(test3)\nend function\nMAIN()",
        "ID": "cd17673696906e92d0767d91d86bd322",
        "refCount": 1
    },
    {
        "Content": "Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n",
        "ID": "c4f3b2bc11849a6c92875f7cb4bd7621",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.split(\"\\n\\r\"))\n",
        "ID": "f655cdb0847eaf46121da2e834737945",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\"\\n\\r\"))\n",
        "ID": "670aa3b52e48bcb265dfb43b61fe54c2",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\"\\r\\n\"))\n",
        "ID": "74b80b37fb72cf885f9e0b4c633c52ef",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\"\\r\"))\n",
        "ID": "45ed3639d74cbdda77dce831e70f733f",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\"[;]\\n\"))\n",
        "ID": "31c520365d11d44d2568cb8563825409",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\"(?!\"\")\\n(?<!\"\")\"))\n",
        "ID": "911b6f21b18c04af7822b196b21660b2",
        "refCount": 1
    },
    {
        "Content": "#import test2 from testdep2;\n#import test3 from testdep3;\n\nprint(\"test was\".split(\"\\n\"))\n\nprint(test2)\nprint(test3)",
        "ID": "4fa8d43531a055a5323955b69fccecb7",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\"(?!\"\")\\n(?<!\"\")\").join(\"\\n\"))\n",
        "ID": "d31e7db969e20c6bed3ec84b89ccdec6",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\"\\n(?<!\"\")\").join(\"\\n\"))\n",
        "ID": "da007d65af5551674e003d15bc365c27",
        "refCount": 2
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\"\\n$\").join(\"\\n\"))\n",
        "ID": "303b073307c8d41b468c03a3d1e6928a",
        "refCount": 2
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\"(\\r?\\n)\").join(\"\\n\"))\n",
        "ID": "be39c591f0b298ed99fd3ef5d2162f9f",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\"(\\r\\n)\").join(\"\\n\"))\n",
        "ID": "bcb7c3866974c35a0dec8423be179376",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\"\").join(\"\\n\"))\n",
        "ID": "d06b998911612627d76c5064ee26827b",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\n\nprint(file.get_content.split(\" \").join(\"\\n\"))\n",
        "ID": "94a60a883007d9d0fc0a4c1fbe109d42",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\nlines = file.get_content.split(\"\\r\\n\")\n\nprint(lines)\nprint(lines.join(\"\\n\"))\n",
        "ID": "40c6a0e565d015a6a3ae9aafb1e5fd6f",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\nlines = file.get_content.split(\"(?!\"\")\\n(?<!\"\")\")\n\nprint(lines)\nprint(lines.join(\"\\n\"))\n",
        "ID": "7d1bb7f31344bc0537a254ca5d52ce9f",
        "refCount": 1
    },
    {
        "Content": "file = get_shell.host_computer.File(\"/home/ayecue/scripts/testdep1.src\")\nlines = file.get_content.replace(\"\")\n\nprint(lines)\nprint(lines.join(\"\\n\"))\n",
        "ID": "b020e4d5354e8ac5c7bf1486116f22d5",
        "refCount": 1
    },
    {
        "Content": "COMMAND_START = \"#\"\nNEW_LINE_OPERATOR = \"\\n\"\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(COMMAND_START)) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"module = {}\")\n\t\t\tnewLines.push(\"if (module.hasIndex(\"\"exports\"\") == false) then\")\n\t\t\tnewLines.push(\"codeBlock = function()\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end function\")\n\t\t\tnewLines.push(\"codeBlock()\")\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return module.exports\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tnewLines = []\n\t\n\tnewLines.push(\"NEW_LINE_OPERATOR = \"\"\\\"\"+\"\"n\"\"\")\n\tnewLines.push(\"MODULES = {}\")\n\tnewLines.push(\"__require = function(r)\")\n\tnewLines.push(\"return MODULES[r]\")\n\tnewLines.push(\"end function\")\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\treturn newLines.join(NEW_LINE_OPERATOR)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "0f1ca044a86e5807810687ac32f968aa",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetWorkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNetworkDevices = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDevices = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\nend function\nMAIN()",
        "ID": "bfeeee65f3f64faf64da9bf66481a249",
        "refCount": 1
    },
    {
        "Content": "crypto = include_lib(\"/lib/crypto.so\")\n\n#import Argv from library/get-param;\n#import NewtworkDeviceManager from library/network-devices;\n#import NetDeviceManager from library/net-devices;\n#import AireplayHelper from library/aireplay-helper;\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n",
        "ID": "a7b235dba23a7cbd3fb118ad9c2b5a77",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetWorkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()",
        "ID": "c3fa1c925629284348e91c4aaea24d6e",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()",
        "ID": "0c6b08cde4fd107ff33b00230eddbbba",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\t\n\tprint(list)\n\n\twhile index < maxIndex\n\t\titem = new NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n",
        "ID": "fc578329b36e054352d103f3b44a831d",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\t\n\tprint(NetworkDevice)\n\n\twhile index < maxIndex\n\t\titem = new NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n",
        "ID": "9e01df6c498c9f80fa5cd60b49200b5f",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nprint(1)\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n",
        "ID": "e688d27726db29d1542a0fb8f4948945",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nprint(1)\nprint(NetworkDevice)\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n",
        "ID": "76789a4f95788a243147dc4bd3794d4e",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.constructor = function(computer)\n\ttest = new NetworkDevice\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n",
        "ID": "79bac4b3bb0df417c0775fcb7b4d2ea6",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\ntest = new NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\ttest = new NetworkDevice\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n",
        "ID": "727ab451b1f288ad2f8af4e7aef12643",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n",
        "ID": "a4485fa6fa3f8d22fe24bdb98c750b8d",
        "refCount": 1
    },
    {
        "Content": "NetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n",
        "ID": "597194a95310df003f20ba41245c58f9",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()",
        "ID": "88bbc294a3232ef8dde04546c2a8d564",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\ncodeBlock = function()\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\ngetAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nclearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\nend function\ncodeBlock()\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()",
        "ID": "42e4a009523ec492a35dd14fd8291831",
        "refCount": 1
    },
    {
        "Content": "AireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nAireplayHelper.getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nAireplayHelper.clearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\n",
        "ID": "1715ce2bdca8d8f2dd0d9f263b295e95",
        "refCount": 1
    },
    {
        "Content": "COMMAND_START = \"#\"\nNEW_LINE_OPERATOR = \"\\n\"\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nconfig = new Config\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(COMMAND_START)) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(dependency)\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tnewLines = []\n\t\t\tnewLines.push((new String).constructor(\"MODULES[\"\"$0\"\"] = function()\").parse([moduleName]).toString())\n\t\t\tnewLines.push(\"module = {}\")\n\t\t\tnewLines.push(\"if (module.hasIndex(\"\"exports\"\") == false) then\")\n\t\t\tnewLines = newLines + item.ast.lines\n\t\t\tnewLines.push(\"end if\")\n\t\t\tnewLines.push(\"return module.exports\")\n\t\t\tnewLines.push(\"end function\")\n\t\t\tmodules[moduleName] = newLines\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tnewLines = []\n\t\n\tnewLines.push(\"NEW_LINE_OPERATOR = \"\"\\\"\"+\"\"n\"\"\")\n\tnewLines.push(\"MODULES = {}\")\n\tnewLines.push(\"__require = function(r)\")\n\tnewLines.push(\"return MODULES[r]\")\n\tnewLines.push(\"end function\")\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines.push(\"MAIN = function()\")\n\tnewLines = newLines + mainDependency.ast.lines\n\tnewLines.push(\"end function\")\n\tnewLines.push(\"MAIN()\")\n\t\n\treturn newLines.join(NEW_LINE_OPERATOR)\nend function \n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n",
        "ID": "18da30bfa0c280f580130be0b370a732",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nAireplayHelper.getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nAireplayHelper.clearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\n\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()",
        "ID": "4bccdbbef7e1ef2561b51604e8a21c88",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\n//NetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nAireplayHelper.getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nAireplayHelper.clearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\n\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()",
        "ID": "3b739a20ffe0b655ddb2817dde66eed7",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\ntest = function()\n\tprint(1)\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\ttest()\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nAireplayHelper.getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nAireplayHelper.clearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\n\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()",
        "ID": "391e2c473a2e59640d6a795ab8fd49e5",
        "refCount": 1
    },
    {
        "Content": "NetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\n",
        "ID": "eb7a0973d4318eb312f555a29f143c79",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nAireplayHelper.getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nAireplayHelper.clearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\n\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\ntest = function()\n\tprint(Argv)\nend function\n\ntest()\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n",
        "ID": "b9db28d7b4c2d80f47de654124df193a",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nAireplayHelper.getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nAireplayHelper.clearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\n\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\ntest = {}\ntest.was = function()\n\tprint(Argv)\nend function\n\na = new test\na.was()\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n",
        "ID": "236374c34cf3660dfbca3f6321535784",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tprint(NetworkDevice)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nAireplayHelper.getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nAireplayHelper.clearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\n\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n",
        "ID": "6e04ec4a2ba86e3ffc6243c2d9976b9b",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\\"+\"n\"\nMODULES = {}\n__require = function(r)\nreturn MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\n\nend if\nreturn module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\nmodule = {}\nif (module.hasIndex(\"exports\") == false) then\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nAireplayHelper.getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nAireplayHelper.clearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\n\nend if\nreturn module.exports\nend function\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __require(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __require(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __require(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __require(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()",
        "ID": "90220b3368ad5e438ec2e79b7a01c006",
        "refCount": 1
    },
    {
        "Content": "COMMAND_START = \"#\"\nNEW_LINE_OPERATOR = \"\\n\"\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(\"/home/$0/compiler\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(COMMAND_START)) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"/boilerplate/header.src\")).get_content\n\tmoduleBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"/boilerplate/module.src\")).get_content\n\tmainBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"/boilerplate/module.src\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tmodules[moduleName] = (new String).constructor(moduleBoilderplate).parse([moduleName, item.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tnewLines = headerBoilderplate\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines = newLines + (new String).constructor(mainBoilderplate).parse([mainDependency.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\n\treturn newLines\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "51171bec9aa51632dea9b71c28763e78",
        "refCount": 1
    },
    {
        "Content": "COMMAND_START = \"#\"\nNEW_LINE_OPERATOR = \"\\n\"\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(\"/home/$0/compiler\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(COMMAND_START)) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"/boilerplates/header.src\")).get_content\n\tmoduleBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"/boilerplates/module.src\")).get_content\n\tmainBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"/boilerplates/module.src\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tmodules[moduleName] = (new String).constructor(moduleBoilderplate).parse([moduleName, item.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tnewLines = headerBoilderplate\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines = newLines + (new String).constructor(mainBoilderplate).parse([mainDependency.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\n\treturn newLines\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "b8e4c381932931e9c89707892dbbd541",
        "refCount": 1
    },
    {
        "Content": "COMMAND_START = \"#\"\nNEW_LINE_OPERATOR = \"\\n\"\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(\"/home/$0/compiler\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(COMMAND_START)) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tprint(pathHelper.join(Config.getCompilerFolder(), \"/boilerplates/header.src\"))\n\theaderBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"/boilerplates/header.src\")).get_content\n\tmoduleBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"/boilerplates/module.src\")).get_content\n\tmainBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"/boilerplates/module.src\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tmodules[moduleName] = (new String).constructor(moduleBoilderplate).parse([moduleName, item.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tnewLines = headerBoilderplate\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines = newLines + (new String).constructor(mainBoilderplate).parse([mainDependency.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\n\treturn newLines\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "ebb064538b90e87144aa3cf9060d8c26",
        "refCount": 1
    },
    {
        "Content": "COMMAND_START = \"#\"\nNEW_LINE_OPERATOR = \"\\n\"\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(\"/home/$0/compiler\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(COMMAND_START)) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\tprint(pathHelper.join(Config.getCompilerFolder(), \"boilerplates/header.src\"))\n\theaderBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"boilerplates/header.src\")).get_content\n\tmoduleBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"boilerplates/module.src\")).get_content\n\tmainBoilderplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"boilerplates/module.src\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tmodules[moduleName] = (new String).constructor(moduleBoilderplate).parse([moduleName, item.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tnewLines = headerBoilderplate\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines = newLines + (new String).constructor(mainBoilderplate).parse([mainDependency.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\n\treturn newLines\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "8afb3abbee5011aaf9a416b14b5e6aa1",
        "refCount": 1
    },
    {
        "Content": "COMMAND_START = \"#\"\nNEW_LINE_OPERATOR = \"\\n\"\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(\"/home/$0/compiler\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(COMMAND_START)) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"boilerplates/header.src\")).get_content\n\tmoduleBoilerplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"boilerplates/module.src\")).get_content\n\tmainBoilerplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"boilerplates/main.src\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __require(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tmodules[moduleName] = (new String).constructor(moduleBoilerplate).parse([moduleName, item.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tnewLines = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines = newLines + (new String).constructor(mainBoilerplate).parse([mainDependency.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\n\treturn newLines\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "e9c176f5f20e95fe0dfae76daf450ada",
        "refCount": 1
    },
    {
        "Content": "COMMAND_START = \"#\"\nNEW_LINE_OPERATOR = \"\\n\"\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(\"/home/$0/scripts\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(\"/home/$0/tmp\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(\"/home/$0/compiler\")\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn \"src\"\nend function\n\nConfig.getTempExtension = function()\n\treturn \"tmp\"\nend function\n\nConfig.getBinFolder = function()\n\treturn \"/usr/bin\"\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(COMMAND_START)) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"boilerplates/header.src\")).get_content\n\tmoduleBoilerplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"boilerplates/module.src\")).get_content\n\tmainBoilerplate = self.computer.File(pathHelper.join(Config.getCompilerFolder(), \"boilerplates/main.src\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tmodules[moduleName] = (new String).constructor(moduleBoilerplate).parse([moduleName, item.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tnewLines = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines = newLines + (new String).constructor(mainBoilerplate).parse([mainDependency.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\n\treturn newLines\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "d4e678fe19841023e25303d8a76931f5",
        "refCount": 1
    },
    {
        "Content": "BACK_SLASH_CHAR = \"\\\"\nNEW_LINE_OPERATOR = BACK_SLASH_CHAR + \"n\"\nMODULES = {}\n\n__REQUIRE = function(r)\n  if (MODULES.hasIndex(r) == false) then\n    exit(\"Module \" + r + \" cannot be found...\")\n  end if\n  return MODULES[r]\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function()\n  module = {}\n\n  if (module.hasIndex(\"exports\") == false) then\n    Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\n  end if\n\n  return module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function()\n  module = {}\n\n  if (module.hasIndex(\"exports\") == false) then\n    NetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\n  end if\n\n  return module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function()\n  module = {}\n\n  if (module.hasIndex(\"exports\") == false) then\n    NetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\n\n  end if\n\n  return module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function()\n  module = {}\n\n  if (module.hasIndex(\"exports\") == false) then\n    AireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nAireplayHelper.getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nAireplayHelper.clearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\n\n  end if\n\n  return module.exports\nend function\nMAIN = function()\n  crypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __REQUIRE(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __REQUIRE(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __REQUIRE(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n",
        "ID": "b363a35d1e97568b54a2d93113c7deab",
        "refCount": 1
    },
    {
        "Content": "COMMAND_START = \"#\"\nNEW_LINE_OPERATOR = \"\\n\"\n\nSCRIPT_FOLDER = \"/home/$0/scripts\"\nTEMP_FOLDER = \"/home/$0/scripts\"\nCOMPILER_FOLDER = \"/home/$0/compiler\"\nBOILERPLATE_FOLDER = \"boilerplates/$0.src\"\nBIN_FOLDER = \"/usr/bin\"\n\nSCRIPT_EXTENSION = \"src\"\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nConfig = {}\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(SCRIPT_FOLDER)\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(TEMP_FOLDER)\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(COMPILER_FOLDER)\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn SCRIPT_EXTENSION\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(BOILERPLATE_FOLDER)\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn BIN_FOLDER\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(COMMAND_START)) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\tdefId = md5(command.action.file.path)\n\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\n\t\t\titem.ast.transform(command.line, code.toString())\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\tmodules[moduleName] = (new String).constructor(moduleBoilerplate).parse([moduleName, item.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tnewLines = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tnewLines = newLines + module\n\tend for\n\t\n\tnewLines = newLines + (new String).constructor(mainBoilerplate).parse([mainDependency.ast.lines.join(NEW_LINE_OPERATOR)]).toString()\n\t\n\treturn newLines\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "3cfb9adc235347e86ed5db2d5e50e7de",
        "refCount": 1
    },
    {
        "Content": "\ns = get_shell\nc = s.host_computer\nh = home_dir\nprint(\"Create compiler folder...\")\nc.createFolder(h, \"compiler\")\nc.touch(h + \"/compiler\", \"compile.src\")\nc.createFolder(h + \"/compiler\", \"boilerplates\")\nc.touch(h + \"/compiler/boilerplates\", \"header.src\")\nc.touch(h + \"/compiler/boilerplates\", \"main.src\")\nc.touch(h + \"/compiler/boilerplates\", \"module.src\")\nprint(\"Create config file...\")\nconfig = c.touch(h + \"/Config\", \"compile.conf\")\nclines = []\nclines.push(\"COMMAND_START=#\")\nclines.push(\"SCRIPT_FOLDER=/home/$0/scripts\")\nclines.push(\"TEMP_FOLDER=/home/$0/tmp\")\nclines.push(\"COMPILER_FOLDER=/home/$0/compiler\")\nclines.push(\"BOILERPLATE_FOLDER=boilerplates/$0.src\")\nclines.push(\"BIN_FOLDER=/usr/bin\")\nclines.push(\"SCRIPT_EXTENSION=src\")\nclines.push(\"VERSION=1.0.0.0\")\n\n",
        "ID": "ea600da29368c4cf994c03fb5a4bff7d",
        "refCount": 1
    },
    {
        "Content": "\ns = get_shell\nc = s.host_computer\nh = home_dir\nprint(\"Create compiler folder...\")\nc.create_folder(h, \"compiler\")\nc.touch(h + \"/compiler\", \"compile.src\")\nc.create_folder(h + \"/compiler\", \"boilerplates\")\nc.touch(h + \"/compiler/boilerplates\", \"header.src\")\nc.touch(h + \"/compiler/boilerplates\", \"main.src\")\nc.touch(h + \"/compiler/boilerplates\", \"module.src\")\nprint(\"Create config file...\")\nconfig = c.touch(h + \"/Config\", \"compile.conf\")\nclines = []\nclines.push(\"COMMAND_START=#\")\nclines.push(\"SCRIPT_FOLDER=/home/$0/scripts\")\nclines.push(\"TEMP_FOLDER=/home/$0/tmp\")\nclines.push(\"COMPILER_FOLDER=/home/$0/compiler\")\nclines.push(\"BOILERPLATE_FOLDER=boilerplates/$0.src\")\nclines.push(\"BIN_FOLDER=/usr/bin\")\nclines.push(\"SCRIPT_EXTENSION=src\")\nclines.push(\"VERSION=1.0.0.0\")\n\n",
        "ID": "49d4f3855b372fe8906802044a3c02de",
        "refCount": 1
    },
    {
        "Content": "\ns = get_shell\nc = s.host_computer\nh = home_dir\nprint(\"Create compiler folder...\")\nc.create_folder(h, \"compiler\")\nc.touch(h + \"/compiler\", \"compile.src\")\nc.create_folder(h + \"/compiler\", \"boilerplates\")\nc.touch(h + \"/compiler/boilerplates\", \"header.src\")\nc.touch(h + \"/compiler/boilerplates\", \"main.src\")\nc.touch(h + \"/compiler/boilerplates\", \"module.src\")\nprint(\"Create config file...\")\nconfig = c.touch(h + \"/Config\", \"compile.conf\")\nclines = []\nclines.push(\"COMMAND_START=#\")\nclines.push(\"SCRIPT_FOLDER=/home/$0/scripts\")\nclines.push(\"TEMP_FOLDER=/home/$0/tmp\")\nclines.push(\"COMPILER_FOLDER=/home/$0/compiler\")\nclines.push(\"BOILERPLATE_FOLDER=boilerplates/$0.src\")\nclines.push(\"BIN_FOLDER=/usr/bin\")\nclines.push(\"SCRIPT_EXTENSION=src\")\nclines.push(\"VERSION=1.0.0.0\")\nconfig.set_content(clines.join(\"\\n\"))\n\n",
        "ID": "b24b70828967f917d1168413ca4ba4fa",
        "refCount": 1
    },
    {
        "Content": "\ns = get_shell\nc = s.host_computer\nh = home_dir\nprint(\"Create compiler folder...\")\nc.create_folder(h, \"compiler\")\nc.touch(h + \"/compiler\", \"compile.src\")\nc.create_folder(h + \"/compiler\", \"boilerplates\")\nc.touch(h + \"/compiler/boilerplates\", \"header.src\")\nc.touch(h + \"/compiler/boilerplates\", \"main.src\")\nc.touch(h + \"/compiler/boilerplates\", \"module.src\")\nprint(\"Create config file...\")\nc.touch(h + \"/Config\", \"compile.conf\")\nconfig = c.File(h + \"/Config/compile.conf\")\nclines = []\nclines.push(\"COMMAND_START=#\")\nclines.push(\"SCRIPT_FOLDER=/home/$0/scripts\")\nclines.push(\"TEMP_FOLDER=/home/$0/tmp\")\nclines.push(\"COMPILER_FOLDER=/home/$0/compiler\")\nclines.push(\"BOILERPLATE_FOLDER=boilerplates/$0.src\")\nclines.push(\"BIN_FOLDER=/usr/bin\")\nclines.push(\"SCRIPT_EXTENSION=src\")\nclines.push(\"VERSION=1.0.0.0\")\nconfig.set_content(clines.join(\"\\n\"))\n\n",
        "ID": "a6bb4bc32d6e7850d357b07833a8d75c",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn newLines\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "aea37b23d28527e818760d6b04c5f1e0",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tprint(1)\n\tpath = path.parse([home_dir]).toString()\n\tprint(2)\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn newLines\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "04cc632674ebdab0cff0c26419631160",
        "refCount": 2
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn newLines\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nConfig.load()\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "088ff1da5a5c4847700d7e099b3f0992",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\", [index]).throw()\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nargv = new Argv\n\nConfig.load()\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "3489b64bd55c517a98442667a290d3d9",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.set = function(key, value)\n\tif (self.hasIndex(\"map\") and value != null) then\n\t\tself.map[key] = value\n\tend if\n\treturn self\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\n\tvalue = Config.get(\"DEBUG\")\n\tif (typeof(value) == \"string\") then\n\t\treturn value == \"true\"\n\tend if\n\treturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\n\tif (Config.isDebugMode()) then\n\t\tprint(msg)\n\tend if\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\n\tself.shortcut = shortcut\n\tself.command = command\n\tself.type = type\n\tself.description = description\n\treturn self\nend function\n\nArg.toString = function()\n\tstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\n\treturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\n\tself.args = params\n\tself.listed = {}\n\tself.unlisted = []\n\tself.defs = defs\n\tself.help = help\n\treturn self\nend function\n\nArgv.parse = function()\n\targs = self.args\n\tdefs = self.defs\n\tlisted = {}\n\tunlisted = []\n\tindex = 0\n\tmaxIndex = args.len\n\tfindDef = function(arg)\n\t\tfor def in defs\n\t\t\tif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\n\t\t\t\treturn def\n\t\t\tend if\n\t\tend for\n\t\treturn null\n\tend function\n\t\n\twhile index < maxIndex\n\t\titem = args[index].trim()\n\t\tdef = findDef(item)\n\t\tif (def == null) then\n\t\t\tunlisted.push(item)\n\t\telse\n\t\t\tif (def.type == ArgType.VALUE) then\n\t\t\t\tindex = index + 1\n\t\t\t\tvalue = item[index]\n\t\t\t\tlisted[def.command] = value\n\t\t\telse if (def.type == ArgType.FLAG) then\n\t\t\t\tlisted[def.command] = true\n\t\t\tend if\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\tself.listed = listed\n\tself.unlisted = unlisted\n\t\n\treturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\n\tif self.unlisted.hasIndex(index) then\n\t\treturn self.unlisted[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\\n\\n$1\", [index, self.help]).throw()\n\tend if\n\treturn null\nend function\n\nArgv.getWithKey = function(key)\n\tif self.listed.hasIndex(key) then\n\t\treturn self.listed[key]\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tdebug(\"Analyzing AST...\")\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tdebug(\"Finding dependencies...\")\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tdebug(\"Run preprocessor...\")\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tdebug(\"Start processing...\")\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\n\thelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(\"\\n\")\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\n\texit(help)\nend if\n\nfor argDefinition in argDefinitions\n\tkey = argDefinition.command.upper.replace(\"-\", \"_\")\n\tvalue = argv.getWithKey(argDefinition.command)\n\tConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "ccdfdc9e08752ee37789a616943c5600",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.set = function(key, value)\n\tif (self.hasIndex(\"map\") and value != null) then\n\t\tself.map[key] = value\n\tend if\n\treturn self\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\n\tvalue = Config.get(\"DEBUG\")\n\tif (typeof(value) == \"string\") then\n\t\treturn value == \"true\"\n\tend if\n\treturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\n\tif (Config.isDebugMode()) then\n\t\tprint(msg)\n\tend if\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\n\tself.shortcut = shortcut\n\tself.command = command\n\tself.type = type\n\tself.description = description\n\treturn self\nend function\n\nArg.toString = function()\n\tstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\n\treturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\n\tself.args = params\n\tself.listed = {}\n\tself.unlisted = []\n\tself.defs = defs\n\tself.help = help\n\treturn self\nend function\n\nArgv.parse = function()\n\targs = self.args\n\tdefs = self.defs\n\tlisted = {}\n\tunlisted = []\n\tindex = 0\n\tmaxIndex = args.len\n\tfindDef = function(arg)\n\t\tfor def in defs\n\t\t\tif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\n\t\t\t\treturn def\n\t\t\tend if\n\t\tend for\n\t\treturn null\n\tend function\n\t\n\twhile index < maxIndex\n\t\titem = args[index].trim()\n\t\tdef = findDef(item)\n\t\tif (def == null) then\n\t\t\tunlisted.push(item)\n\t\telse\n\t\t\tif (def.type == ArgType.VALUE) then\n\t\t\t\tindex = index + 1\n\t\t\t\tvalue = args[index]\n\t\t\t\tlisted[def.command] = value\n\t\t\telse if (def.type == ArgType.FLAG) then\n\t\t\t\tlisted[def.command] = true\n\t\t\tend if\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\tself.listed = listed\n\tself.unlisted = unlisted\n\t\n\treturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\n\tif self.unlisted.hasIndex(index) then\n\t\treturn self.unlisted[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\\n\\n$1\", [index, self.help]).throw()\n\tend if\n\treturn null\nend function\n\nArgv.getWithKey = function(key)\n\tif self.listed.hasIndex(key) then\n\t\treturn self.listed[key]\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tdebug(\"Analyzing AST...\")\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tdebug(\"Finding dependencies...\")\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tdebug(\"Run preprocessor...\")\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tdebug(\"Start processing...\")\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\n\thelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(\"\\n\")\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\n\texit(help)\nend if\n\nfor argDefinition in argDefinitions\n\tkey = argDefinition.command.upper.replace(\"-\", \"_\")\n\tvalue = argv.getWithKey(argDefinition.command)\n\tConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "c428548695812e5157d19949b06e44b5",
        "refCount": 1
    },
    {
        "Content": "BACK_SLASH_CHAR = \"\\\"\nNEW_LINE_OPERATOR = BACK_SLASH_CHAR + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\n  if (MODULES.hasIndex(r) == false) then\n    exit(\"Module \" + r + \" cannot be found...\")\nend if\n\tmodule = MODULES[r]\n  return module(r)\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    NetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    NetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    AireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nAireplayHelper.getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nAireplayHelper.clearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMAIN = function()\n  crypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __REQUIRE(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __REQUIRE(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __REQUIRE(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()\n\n",
        "ID": "df19e71cc3aa570148a2f5c316f52c65",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.set = function(key, value)\n\tif (self.hasIndex(\"map\") and value != null) then\n\t\tself.map[key] = value\n\tend if\n\treturn self\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\n\tvalue = Config.get(\"DEBUG\")\n\tif (typeof(value) == \"string\") then\n\t\treturn value == \"true\"\n\tend if\n\treturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\n\tif (Config.isDebugMode()) then\n\t\tprint(msg)\n\tend if\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\n\tself.shortcut = shortcut\n\tself.command = command\n\tself.type = type\n\tself.description = description\n\treturn self\nend function\n\nArg.toString = function()\n\tstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\n\treturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\n\tself.args = params\n\tself.listed = {}\n\tself.unlisted = []\n\tself.defs = defs\n\tself.help = help\n\treturn self\nend function\n\nArgv.parse = function()\n\targs = self.args\n\tdefs = self.defs\n\tlisted = {}\n\tunlisted = []\n\tindex = 0\n\tmaxIndex = args.len\n\tfindDef = function(arg)\n\t\tfor def in defs\n\t\t\tif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\n\t\t\t\treturn def\n\t\t\tend if\n\t\tend for\n\t\treturn null\n\tend function\n\t\n\twhile index < maxIndex\n\t\titem = args[index].trim()\n\t\tdef = findDef(item)\n\t\tif (def == null) then\n\t\t\tunlisted.push(item)\n\t\telse\n\t\t\tif (def.type == ArgType.VALUE) then\n\t\t\t\tindex = index + 1\n\t\t\t\tvalue = args[index]\n\t\t\t\tlisted[def.command] = value\n\t\t\telse if (def.type == ArgType.FLAG) then\n\t\t\t\tlisted[def.command] = true\n\t\t\tend if\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\tself.listed = listed\n\tself.unlisted = unlisted\n\t\n\treturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\n\tif self.unlisted.hasIndex(index) then\n\t\treturn self.unlisted[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\\n\\n$1\", [index, self.help]).throw()\n\tend if\n\treturn null\nend function\n\nArgv.getWithKey = function(key)\n\tif self.listed.hasIndex(key) then\n\t\treturn self.listed[key]\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\tif (b.indexOf(\"/\") == 0) then\n\t\tb = b[1:]\n\tend if\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tdebug(\"Analyzing AST...\")\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tdebug(\"Finding dependencies...\")\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tdebug(\"Run preprocessor...\")\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tdebug(\"Start processing...\")\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\n\thelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(\"\\n\")\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\n\texit(help)\nend if\n\nfor argDefinition in argDefinitions\n\tkey = argDefinition.command.upper.replace(\"-\", \"_\")\n\tvalue = argv.getWithKey(argDefinition.command)\n\tConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n",
        "ID": "032c6137ca596dbd876c178a1d153dc8",
        "refCount": 1
    },
    {
        "Content": "Path = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n",
        "ID": "bb0f1cb2a0d81935127674ffb79d53a7",
        "refCount": 1
    },
    {
        "Content": "#import Path from path;\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n",
        "ID": "afc84232a9d4f6320381bdbe3e8f5db9",
        "refCount": 1
    },
    {
        "Content": "BACK_SLASH_CHAR = \"\\\"\nNEW_LINE_OPERATOR = BACK_SLASH_CHAR + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\n  if (MODULES.hasIndex(r) == false) then\n    exit(\"Module \" + r + \" cannot be found...\")\n  end if\n  module = MODULES[r]\n  return module(r)\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    FS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\n\n\n\n\n\n\n\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    Path = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    Path = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMAIN = function()\n  Argv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nkey = argv.get(0, true)\npassword = argv.get(1, true)\noverride = argv.get(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nentry = new PasswordEntry\nentry.constructor(key, password)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tpasswordManager.setPasswordByKey(entry)\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tpasswordManager.passwordList.push(entry)\nend if\n\nprint(\"Saving password...\")\npasswordManager.savePasswordFile()\n\n\n\n\n\nend function\nMAIN()\n",
        "ID": "7066bec3eb1a41d56ee9564d53a80f16",
        "refCount": 1
    },
    {
        "Content": "#import FS from ../fs;\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nmodule.exports = PasswordFile",
        "ID": "6d71c0a9b8d4d277c1d79dfe4449b782",
        "refCount": 1
    },
    {
        "Content": "PasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nmodule.exports = PasswordEntry",
        "ID": "a805762a434b298f612b454d83c52683",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.set = function(key, value)\n\tif (self.hasIndex(\"map\") and value != null) then\n\t\tself.map[key] = value\n\tend if\n\treturn self\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\n\tvalue = Config.get(\"DEBUG\")\n\tif (typeof(value) == \"string\") then\n\t\treturn value == \"true\"\n\tend if\n\treturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\n\tif (Config.isDebugMode()) then\n\t\tprint(msg)\n\tend if\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\n\tself.shortcut = shortcut\n\tself.command = command\n\tself.type = type\n\tself.description = description\n\treturn self\nend function\n\nArg.toString = function()\n\tstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\n\treturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\n\tself.args = params\n\tself.listed = {}\n\tself.unlisted = []\n\tself.defs = defs\n\tself.help = help\n\treturn self\nend function\n\nArgv.parse = function()\n\targs = self.args\n\tdefs = self.defs\n\tlisted = {}\n\tunlisted = []\n\tindex = 0\n\tmaxIndex = args.len\n\tfindDef = function(arg)\n\t\tfor def in defs\n\t\t\tif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\n\t\t\t\treturn def\n\t\t\tend if\n\t\tend for\n\t\treturn null\n\tend function\n\t\n\twhile index < maxIndex\n\t\titem = args[index].trim()\n\t\tdef = findDef(item)\n\t\tif (def == null) then\n\t\t\tunlisted.push(item)\n\t\telse\n\t\t\tif (def.type == ArgType.VALUE) then\n\t\t\t\tindex = index + 1\n\t\t\t\tvalue = args[index]\n\t\t\t\tlisted[def.command] = value\n\t\t\telse if (def.type == ArgType.FLAG) then\n\t\t\t\tlisted[def.command] = true\n\t\t\tend if\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\tself.listed = listed\n\tself.unlisted = unlisted\n\t\n\treturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\n\tif self.unlisted.hasIndex(index) then\n\t\treturn self.unlisted[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\\n\\n$1\", [index, self.help]).throw()\n\tend if\n\treturn null\nend function\n\nArgv.getWithKey = function(key)\n\tif self.listed.hasIndex(key) then\n\t\treturn self.listed[key]\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.join = function(a, b)\n\tif (b.indexOf(\"/\") == 0) then\n\t\tb = b[1:]\n\tend if\n\treturn [a, b].join(\"/\")\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tdebug(\"Analyzing AST...\")\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tdebug(\"Finding dependencies...\")\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\tdebug(\"Looking for file in \" + filePath + \"...\")\n\t\t\t\n\t\t\tif (file == null) then\n\t\t\t\t(new Error).constructor(\"Cannot find $0...\", [filePath]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tdebug(\"Run preprocessor...\")\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tdebug(\"Start processing...\")\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\n\thelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(\"\\n\")\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\n\texit(help)\nend if\n\nfor argDefinition in argDefinitions\n\tkey = argDefinition.command.upper.replace(\"-\", \"_\")\n\tvalue = argv.getWithKey(argDefinition.command)\n\tConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n",
        "ID": "98c6d3215ef6161a75172cac513b24a9",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.set = function(key, value)\n\tif (self.hasIndex(\"map\") and value != null) then\n\t\tself.map[key] = value\n\tend if\n\treturn self\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\n\tvalue = Config.get(\"DEBUG\")\n\tif (typeof(value) == \"string\") then\n\t\treturn value == \"true\"\n\tend if\n\treturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\n\tif (Config.isDebugMode()) then\n\t\tprint(msg)\n\tend if\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\n\tself.shortcut = shortcut\n\tself.command = command\n\tself.type = type\n\tself.description = description\n\treturn self\nend function\n\nArg.toString = function()\n\tstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\n\treturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\n\tself.args = params\n\tself.listed = {}\n\tself.unlisted = []\n\tself.defs = defs\n\tself.help = help\n\treturn self\nend function\n\nArgv.parse = function()\n\targs = self.args\n\tdefs = self.defs\n\tlisted = {}\n\tunlisted = []\n\tindex = 0\n\tmaxIndex = args.len\n\tfindDef = function(arg)\n\t\tfor def in defs\n\t\t\tif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\n\t\t\t\treturn def\n\t\t\tend if\n\t\tend for\n\t\treturn null\n\tend function\n\t\n\twhile index < maxIndex\n\t\titem = args[index].trim()\n\t\tdef = findDef(item)\n\t\tif (def == null) then\n\t\t\tunlisted.push(item)\n\t\telse\n\t\t\tif (def.type == ArgType.VALUE) then\n\t\t\t\tindex = index + 1\n\t\t\t\tvalue = args[index]\n\t\t\t\tlisted[def.command] = value\n\t\t\telse if (def.type == ArgType.FLAG) then\n\t\t\t\tlisted[def.command] = true\n\t\t\tend if\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\tself.listed = listed\n\tself.unlisted = unlisted\n\t\n\treturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\n\tif self.unlisted.hasIndex(index) then\n\t\treturn self.unlisted[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\\n\\n$1\", [index, self.help]).throw()\n\tend if\n\treturn null\nend function\n\nArgv.getWithKey = function(key)\n\tif self.listed.hasIndex(key) then\n\t\treturn self.listed[key]\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.resolve = function(a)\n\tparts = a.split(\"/\")\n\tresult = []\n\t\n\tfor part in parts\n\t\tif (part == \"..\") then\n\t\t\tresult.pop()\n\t\telse if (part != \"\" and part != \".\") then\n\t\t\tresult.push(part)\n\t\tend if\n\tend for\n\n\treturn result.join(\"/\")\nend function\n\nPath.join = function(a, b)\n\tif (b.indexOf(\"/\") == 0) then\n\t\tb = b[1:]\n\tend if\n\treturn Path.resolve([a, b].join(\"/\"))\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tdebug(\"Analyzing AST...\")\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tdebug(\"Finding dependencies...\")\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\tdebug(\"Looking for file in \" + filePath + \"...\")\n\t\t\t\n\t\t\tif (file == null) then\n\t\t\t\t(new Error).constructor(\"Cannot find $0...\", [filePath]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tdebug(\"Run preprocessor...\")\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tdebug(\"Start processing...\")\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\n\thelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(\"\\n\")\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\n\texit(help)\nend if\n\nfor argDefinition in argDefinitions\n\tkey = argDefinition.command.upper.replace(\"-\", \"_\")\n\tvalue = argv.getWithKey(argDefinition.command)\n\tConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n",
        "ID": "8987145f2fcdea2d188b9ef1c343564a",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.set = function(key, value)\n\tif (self.hasIndex(\"map\") and value != null) then\n\t\tself.map[key] = value\n\tend if\n\treturn self\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\n\tvalue = Config.get(\"DEBUG\")\n\tif (typeof(value) == \"string\") then\n\t\treturn value == \"true\"\n\tend if\n\treturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\n\tif (Config.isDebugMode()) then\n\t\tprint(msg)\n\tend if\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\n\tself.shortcut = shortcut\n\tself.command = command\n\tself.type = type\n\tself.description = description\n\treturn self\nend function\n\nArg.toString = function()\n\tstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\n\treturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\n\tself.args = params\n\tself.listed = {}\n\tself.unlisted = []\n\tself.defs = defs\n\tself.help = help\n\treturn self\nend function\n\nArgv.parse = function()\n\targs = self.args\n\tdefs = self.defs\n\tlisted = {}\n\tunlisted = []\n\tindex = 0\n\tmaxIndex = args.len\n\tfindDef = function(arg)\n\t\tfor def in defs\n\t\t\tif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\n\t\t\t\treturn def\n\t\t\tend if\n\t\tend for\n\t\treturn null\n\tend function\n\t\n\twhile index < maxIndex\n\t\titem = args[index].trim()\n\t\tdef = findDef(item)\n\t\tif (def == null) then\n\t\t\tunlisted.push(item)\n\t\telse\n\t\t\tif (def.type == ArgType.VALUE) then\n\t\t\t\tindex = index + 1\n\t\t\t\tvalue = args[index]\n\t\t\t\tlisted[def.command] = value\n\t\t\telse if (def.type == ArgType.FLAG) then\n\t\t\t\tlisted[def.command] = true\n\t\t\tend if\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\tself.listed = listed\n\tself.unlisted = unlisted\n\t\n\treturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\n\tif self.unlisted.hasIndex(index) then\n\t\treturn self.unlisted[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\\n\\n$1\", [index, self.help]).throw()\n\tend if\n\treturn null\nend function\n\nArgv.getWithKey = function(key)\n\tif self.listed.hasIndex(key) then\n\t\treturn self.listed[key]\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.resolve = function(a)\n\tparts = a.split(\"/\")\n\tresult = []\n\t\n\tfor part in parts\n\t\tif (part == \"..\") then\n\t\t\tresult.pop()\n\t\telse if (part != \"\" and part != \".\") then\n\t\t\tresult.push(part)\n\t\tend if\n\tend for\n\n\treturn result.join(\"/\")\nend function\n\nPath.join = function(a, b)\n\tif (b.indexOf(\"/\") == 0) then\n\t\tb = b[1:]\n\tend if\n\treturn Path.resolve([a, b].join(\"/\"))\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tdebug(\"Analyzing AST...\")\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tdebug(\"Finding dependencies...\")\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\tdebug(\"Looking for file in \" + filePath + \"...\")\n\t\t\t\n\t\t\tif (file == null) then\n\t\t\t\t(new Error).constructor(\"Cannot find $0...\", [filePath]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tdebug(\"Run preprocessor...\")\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tprint(self.getFullScriptFilePath())\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tdebug(\"Start processing...\")\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\n\thelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(\"\\n\")\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\n\texit(help)\nend if\n\nfor argDefinition in argDefinitions\n\tkey = argDefinition.command.upper.replace(\"-\", \"_\")\n\tvalue = argv.getWithKey(argDefinition.command)\n\tConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n",
        "ID": "6cad97fc58f2905bc31aa44e41e71a43",
        "refCount": 2
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.set = function(key, value)\n\tif (self.hasIndex(\"map\") and value != null) then\n\t\tself.map[key] = value\n\tend if\n\treturn self\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\n\tvalue = Config.get(\"DEBUG\")\n\tif (typeof(value) == \"string\") then\n\t\treturn value == \"true\"\n\tend if\n\treturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\n\tif (Config.isDebugMode()) then\n\t\tprint(msg)\n\tend if\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\n\tself.shortcut = shortcut\n\tself.command = command\n\tself.type = type\n\tself.description = description\n\treturn self\nend function\n\nArg.toString = function()\n\tstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\n\treturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\n\tself.args = params\n\tself.listed = {}\n\tself.unlisted = []\n\tself.defs = defs\n\tself.help = help\n\treturn self\nend function\n\nArgv.parse = function()\n\targs = self.args\n\tdefs = self.defs\n\tlisted = {}\n\tunlisted = []\n\tindex = 0\n\tmaxIndex = args.len\n\tfindDef = function(arg)\n\t\tfor def in defs\n\t\t\tif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\n\t\t\t\treturn def\n\t\t\tend if\n\t\tend for\n\t\treturn null\n\tend function\n\t\n\twhile index < maxIndex\n\t\titem = args[index].trim()\n\t\tdef = findDef(item)\n\t\tif (def == null) then\n\t\t\tunlisted.push(item)\n\t\telse\n\t\t\tif (def.type == ArgType.VALUE) then\n\t\t\t\tindex = index + 1\n\t\t\t\tvalue = args[index]\n\t\t\t\tlisted[def.command] = value\n\t\t\telse if (def.type == ArgType.FLAG) then\n\t\t\t\tlisted[def.command] = true\n\t\t\tend if\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\tself.listed = listed\n\tself.unlisted = unlisted\n\t\n\treturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\n\tif self.unlisted.hasIndex(index) then\n\t\treturn self.unlisted[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\\n\\n$1\", [index, self.help]).throw()\n\tend if\n\treturn null\nend function\n\nArgv.getWithKey = function(key)\n\tif self.listed.hasIndex(key) then\n\t\treturn self.listed[key]\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.resolve = function(a)\n\tparts = a.split(\"/\")\n\tresult = []\n\t\n\tfor part in parts\n\t\tif (part == \"..\") then\n\t\t\tresult.pop()\n\t\telse if (part != \"\" and part != \".\") then\n\t\t\tresult.push(part)\n\t\tend if\n\tend for\n\n\tresolved = result.join(\"/\")\n\t\n\tif (a.indexOf(\"/\")) then\n\t\tresolved = \"/\" + resolved\n\tend if\n\n\treturn resolved\nend function\n\nPath.join = function(a, b)\n\tif (b.indexOf(\"/\") == 0) then\n\t\tb = b[1:]\n\tend if\n\treturn Path.resolve([a, b].join(\"/\"))\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tdebug(\"Analyzing AST...\")\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tdebug(\"Finding dependencies...\")\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\tdebug(\"Looking for file in \" + filePath + \"...\")\n\t\t\t\n\t\t\tif (file == null) then\n\t\t\t\t(new Error).constructor(\"Cannot find $0...\", [filePath]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tdebug(\"Run preprocessor...\")\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tdebug(\"Start processing...\")\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\n\thelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(\"\\n\")\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\n\texit(help)\nend if\n\nfor argDefinition in argDefinitions\n\tkey = argDefinition.command.upper.replace(\"-\", \"_\")\n\tvalue = argv.getWithKey(argDefinition.command)\n\tConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n",
        "ID": "9b9f7b86b8ac3d668557868c769f3fe2",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.set = function(key, value)\n\tif (self.hasIndex(\"map\") and value != null) then\n\t\tself.map[key] = value\n\tend if\n\treturn self\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\n\tvalue = Config.get(\"DEBUG\")\n\tif (typeof(value) == \"string\") then\n\t\treturn value == \"true\"\n\tend if\n\treturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\n\tif (Config.isDebugMode()) then\n\t\tprint(msg)\n\tend if\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\n\tself.shortcut = shortcut\n\tself.command = command\n\tself.type = type\n\tself.description = description\n\treturn self\nend function\n\nArg.toString = function()\n\tstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\n\treturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\n\tself.args = params\n\tself.listed = {}\n\tself.unlisted = []\n\tself.defs = defs\n\tself.help = help\n\treturn self\nend function\n\nArgv.parse = function()\n\targs = self.args\n\tdefs = self.defs\n\tlisted = {}\n\tunlisted = []\n\tindex = 0\n\tmaxIndex = args.len\n\tfindDef = function(arg)\n\t\tfor def in defs\n\t\t\tif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\n\t\t\t\treturn def\n\t\t\tend if\n\t\tend for\n\t\treturn null\n\tend function\n\t\n\twhile index < maxIndex\n\t\titem = args[index].trim()\n\t\tdef = findDef(item)\n\t\tif (def == null) then\n\t\t\tunlisted.push(item)\n\t\telse\n\t\t\tif (def.type == ArgType.VALUE) then\n\t\t\t\tindex = index + 1\n\t\t\t\tvalue = args[index]\n\t\t\t\tlisted[def.command] = value\n\t\t\telse if (def.type == ArgType.FLAG) then\n\t\t\t\tlisted[def.command] = true\n\t\t\tend if\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\tself.listed = listed\n\tself.unlisted = unlisted\n\t\n\treturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\n\tif self.unlisted.hasIndex(index) then\n\t\treturn self.unlisted[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\\n\\n$1\", [index, self.help]).throw()\n\tend if\n\treturn null\nend function\n\nArgv.getWithKey = function(key)\n\tif self.listed.hasIndex(key) then\n\t\treturn self.listed[key]\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.resolve = function(a)\n\tparts = a.split(\"/\")\n\tresult = []\n\t\n\tfor part in parts\n\t\tif (part == \"..\") then\n\t\t\tresult.pop()\n\t\telse if (part != \"\" and part != \".\") then\n\t\t\tresult.push(part)\n\t\tend if\n\tend for\n\n\tresolved = result.join(\"/\")\n\t\n\tif (a.indexOf(\"/\")) then\n\t\tresolved = \"/\" + resolved\n\tend if\n\n\tprint(a)\n\tprint(resolved)\n\n\treturn resolved\nend function\n\nPath.join = function(a, b)\n\tif (b.indexOf(\"/\") == 0) then\n\t\tb = b[1:]\n\tend if\n\treturn Path.resolve([a, b].join(\"/\"))\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tdebug(\"Analyzing AST...\")\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tdebug(\"Finding dependencies...\")\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\tdebug(\"Looking for file in \" + filePath + \"...\")\n\t\t\t\n\t\t\tif (file == null) then\n\t\t\t\t(new Error).constructor(\"Cannot find $0...\", [filePath]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tdebug(\"Run preprocessor...\")\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tdebug(\"Start processing...\")\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\n\thelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(\"\\n\")\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\n\texit(help)\nend if\n\nfor argDefinition in argDefinitions\n\tkey = argDefinition.command.upper.replace(\"-\", \"_\")\n\tvalue = argv.getWithKey(argDefinition.command)\n\tConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n",
        "ID": "0da9a8648b524943db3042e2c1e9f515",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.set = function(key, value)\n\tif (self.hasIndex(\"map\") and value != null) then\n\t\tself.map[key] = value\n\tend if\n\treturn self\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\n\tvalue = Config.get(\"DEBUG\")\n\tif (typeof(value) == \"string\") then\n\t\treturn value == \"true\"\n\tend if\n\treturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\n\tif (Config.isDebugMode()) then\n\t\tprint(msg)\n\tend if\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\n\tself.shortcut = shortcut\n\tself.command = command\n\tself.type = type\n\tself.description = description\n\treturn self\nend function\n\nArg.toString = function()\n\tstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\n\treturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\n\tself.args = params\n\tself.listed = {}\n\tself.unlisted = []\n\tself.defs = defs\n\tself.help = help\n\treturn self\nend function\n\nArgv.parse = function()\n\targs = self.args\n\tdefs = self.defs\n\tlisted = {}\n\tunlisted = []\n\tindex = 0\n\tmaxIndex = args.len\n\tfindDef = function(arg)\n\t\tfor def in defs\n\t\t\tif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\n\t\t\t\treturn def\n\t\t\tend if\n\t\tend for\n\t\treturn null\n\tend function\n\t\n\twhile index < maxIndex\n\t\titem = args[index].trim()\n\t\tdef = findDef(item)\n\t\tif (def == null) then\n\t\t\tunlisted.push(item)\n\t\telse\n\t\t\tif (def.type == ArgType.VALUE) then\n\t\t\t\tindex = index + 1\n\t\t\t\tvalue = args[index]\n\t\t\t\tlisted[def.command] = value\n\t\t\telse if (def.type == ArgType.FLAG) then\n\t\t\t\tlisted[def.command] = true\n\t\t\tend if\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\tself.listed = listed\n\tself.unlisted = unlisted\n\t\n\treturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\n\tif self.unlisted.hasIndex(index) then\n\t\treturn self.unlisted[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\\n\\n$1\", [index, self.help]).throw()\n\tend if\n\treturn null\nend function\n\nArgv.getWithKey = function(key)\n\tif self.listed.hasIndex(key) then\n\t\treturn self.listed[key]\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.resolve = function(a)\n\tparts = a.split(\"/\")\n\tresult = []\n\t\n\tfor part in parts\n\t\tif (part == \"..\") then\n\t\t\tresult.pop()\n\t\telse if (part != \"\" and part != \".\") then\n\t\t\tresult.push(part)\n\t\tend if\n\tend for\n\n\tresolved = result.join(\"/\")\n\t\n\tif (a.indexOf(\"/\") == 0) then\n\t\tresolved = \"/\" + resolved\n\tend if\n\n\tprint(a)\n\tprint(resolved)\n\n\treturn resolved\nend function\n\nPath.join = function(a, b)\n\tif (b.indexOf(\"/\") == 0) then\n\t\tb = b[1:]\n\tend if\n\treturn Path.resolve([a, b].join(\"/\"))\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tdebug(\"Analyzing AST...\")\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tdebug(\"Finding dependencies...\")\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\tdebug(\"Looking for file in \" + filePath + \"...\")\n\t\t\t\n\t\t\tif (file == null) then\n\t\t\t\t(new Error).constructor(\"Cannot find $0...\", [filePath]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tdebug(\"Run preprocessor...\")\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tdebug(\"Start processing...\")\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\n\thelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(\"\\n\")\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\n\texit(help)\nend if\n\nfor argDefinition in argDefinitions\n\tkey = argDefinition.command.upper.replace(\"-\", \"_\")\n\tvalue = argv.getWithKey(argDefinition.command)\n\tConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n",
        "ID": "8c79f286676a3ff007cb87d3dfcdf159",
        "refCount": 1
    },
    {
        "Content": "BACK_SLASH_CHAR = \"\\\"\nNEW_LINE_OPERATOR = BACK_SLASH_CHAR + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\n  if (MODULES.hasIndex(r) == false) then\n    exit(\"Module \" + r + \" cannot be found...\")\n  end if\n  module = MODULES[r]\n  return module(r)\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    PasswordFile = __REQUIRE(\"e49bedd6fbfe36e5f135d4e838832d72\")\nPasswordEntry = __REQUIRE(\"7d4bd97d0894070e7ba1e9dbfc0cb0a8\")\n\nPasswordFileManager = {}\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\n\n\n\n\n\n\n\n\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"e49bedd6fbfe36e5f135d4e838832d72\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    FS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nmodule.exports = PasswordFile\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    Path = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    Path = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"7d4bd97d0894070e7ba1e9dbfc0cb0a8\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    PasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nmodule.exports = PasswordEntry\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMAIN = function()\n  Argv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nkey = argv.get(0, true)\npassword = argv.get(1, true)\noverride = argv.get(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nentry = new PasswordEntry\nentry.constructor(key, password)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tpasswordManager.setPasswordByKey(entry)\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tpasswordManager.passwordList.push(entry)\nend if\n\nprint(\"Saving password...\")\npasswordManager.savePasswordFile()\n\n\n\n\n\nend function\nMAIN()\n",
        "ID": "5f4540dd581dbf2d289f846d9f1e81e5",
        "refCount": 1
    },
    {
        "Content": "NEW_LINE_OPERATOR = \"\\n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\n\tpath = (new String).constructor(\"$0/Config/compile.conf\")\n\tpath = path.parse([home_dir]).toString()\n\tfile = get_shell.host_computer.File(path)\n\tif (file == null) then\n\t\t(new Error).constructor(\"No config in $0...\", [path]).throw()\n\tend if\n\tcontent = file.get_content\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tmap = {}\n\t\n\tfor line in lines\n\t\tdef = line.split(\"=\")\n\t\tname = def.pull()\n\t\tvalue = def.pull()\n\t\tmap[name] = value\n\tend for\n\t\n\tself.map = map\n\t\n\treturn map\nend function\n\nConfig.set = function(key, value)\n\tif (self.hasIndex(\"map\") and value != null) then\n\t\tself.map[key] = value\n\tend if\n\treturn self\nend function\n\nConfig.get = function(key)\n\tif (self.hasIndex(\"map\")) then\n\t\treturn self.map[key]\n\tend if\n\treturn null\nend function\n\nConfig.getScriptFolder = function()\n\tpath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\n\tpath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\n\tpath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\n\tuser = active_user\n\treturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\n\treturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\n\tvalue = Config.get(\"DEBUG\")\n\tif (typeof(value) == \"string\") then\n\t\treturn value == \"true\"\n\tend if\n\treturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\n\tpathHelper = new Path\n\tpath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\n\treturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\n\treturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\n\tif (Config.isDebugMode()) then\n\t\tprint(msg)\n\tend if\nend function\n\nString = {}\n\nString.constructor = function(str)\n\tself.str = str\n\treturn self\nend function\n\nString.parse = function(values)\n\tresult = self.str\n\tindex = 0\n\tmaxIndex = values.len\n\t\n\twhile index < maxIndex\n\t\tresult = result.replace(\"$\"+index, values[index])\n\t\tindex = index + 1\n\tend while\n\t\n\treturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\n\treturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\n\treturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\n\treturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\n\treturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\n\treturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\n\treturn self.str\nend function\n\nString.length = function()\n\treturn self.str.len\nend function\n\nString.split = function(seperator)\n\treturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\n\treturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\n\tself.message = message\n\tif (values != null) then\n\t\tself.message = (new String.constructor(message)).parse(values).toString()\n\tend if\n\treturn self\nend function\n\nError.throw = function()\n\texit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\n\tself.shortcut = shortcut\n\tself.command = command\n\tself.type = type\n\tself.description = description\n\treturn self\nend function\n\nArg.toString = function()\n\tstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\n\treturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\n\tself.args = params\n\tself.listed = {}\n\tself.unlisted = []\n\tself.defs = defs\n\tself.help = help\n\treturn self\nend function\n\nArgv.parse = function()\n\targs = self.args\n\tdefs = self.defs\n\tlisted = {}\n\tunlisted = []\n\tindex = 0\n\tmaxIndex = args.len\n\tfindDef = function(arg)\n\t\tfor def in defs\n\t\t\tif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\n\t\t\t\treturn def\n\t\t\tend if\n\t\tend for\n\t\treturn null\n\tend function\n\t\n\twhile index < maxIndex\n\t\titem = args[index].trim()\n\t\tdef = findDef(item)\n\t\tif (def == null) then\n\t\t\tunlisted.push(item)\n\t\telse\n\t\t\tif (def.type == ArgType.VALUE) then\n\t\t\t\tindex = index + 1\n\t\t\t\tvalue = args[index]\n\t\t\t\tlisted[def.command] = value\n\t\t\telse if (def.type == ArgType.FLAG) then\n\t\t\t\tlisted[def.command] = true\n\t\t\tend if\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\tself.listed = listed\n\tself.unlisted = unlisted\n\t\n\treturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\n\tif self.unlisted.hasIndex(index) then\n\t\treturn self.unlisted[index]\n\tend if\n\tif mandatory then\n\t\t(new Error).constructor(\"Error cannot find param[$0]\\n\\n$1\", [index, self.help]).throw()\n\tend if\n\treturn null\nend function\n\nArgv.getWithKey = function(key)\n\tif self.listed.hasIndex(key) then\n\t\treturn self.listed[key]\n\tend if\n\treturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\n\treturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\n\treturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\n\tmath = new Math\n\tchars = self.getChars()\n\t\n\tresult = []\n\tindexA = 0\n\tmaxA = 4\n\t\n\twhile indexA < maxA\n\t\tindexB = 0\n\t\tmaxB = 5\n\t\tcode = \"\"\n\t\t\n\t\twhile indexB < maxB\n\t\t\tcode = code + chars[math.random(0, chars.len - 1)]\n\t\t\t\n\t\t\tindexB = indexB + 1\n\t\tend while\n\t\t\n\t\tresult.push(code)\n\t\t\n\t\tindexA = indexA + 1\n\tend while\n\t\n\treturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.resolve = function(a)\n\tparts = a.split(\"/\")\n\tresult = []\n\t\n\tfor part in parts\n\t\tif (part == \"..\") then\n\t\t\tresult.pop()\n\t\telse if (part != \"\" and part != \".\") then\n\t\t\tresult.push(part)\n\t\tend if\n\tend for\n\n\tresolved = result.join(\"/\")\n\t\n\tif (a.indexOf(\"/\") == 0) then\n\t\tresolved = \"/\" + resolved\n\tend if\n\n\treturn resolved\nend function\n\nPath.join = function(a, b)\n\tif (b.indexOf(\"/\") == 0) then\n\t\tb = b[1:]\n\tend if\n\treturn Path.resolve([a, b].join(\"/\"))\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(path, name)\n\tself.computer.touch(path, name)\n\treturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\n\tself.file = file\n\treturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\n\tself.line = line\n\tself.str = str\n\tself.key = key\n\tself.action = action\n\treturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\n\tself.computer = computer\n\tself.file = file\n\tself.lines = []\n\tself.commands = []\n\treturn self\nend function\n\nAST.analyze = function()\n\tdebug(\"Analyzing AST...\")\n\tcontent = self.file.get_content\n\tcommands = []\n\tlines = content.split(NEW_LINE_OPERATOR)\n\tindex = 0\n\t\n\tfor line in lines\n\t\tstr = (new String).constructor(line)\n\t\t\n\t\tif (str.startsWith(Config.get(\"COMMAND_START\"))) then\n\t\t\tcommand = str.substr(1, str.indexOf(\" \"))\n\t\t\tkey = command.toString()\n\t\t\t\n\t\t\tif (ASTRegistry[key] == null) then\n\t\t\t\t(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\taction = ASTRegistry[key]\n\t\t\tentry = (new ASTCommand).constructor(index, str, key, new action)\n\t\t\tcommands.push(entry)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend for\n\t\n\tself.lines = lines\n\tself.commands = commands\n\t\n\treturn commands\nend function\n\nAST.transform = function(line, code)\n\tself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\t\n\treturn self.lines\nend function\n\nAST.getCommands = function()\n\treturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\n\tpathHelper = new Path\n\t\n\tself.computer = computer\n\tself.target = file\n\tself.basePath = file.parent.path\n\tself.ast = ast\n\tself.dependencies = []\n\t\n\tif self.target == null then\n\t\t(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\n\tend if\n\t\n\treturn self\nend function\n\nDependency.findDependencies = function()\n\tdebug(\"Finding dependencies...\")\n\tpathHelper = new Path\n\tcommands = self.ast.getCommands()\n\tresult = []\n\t\n\tfor command in commands\n\t\tif (command.key == \"import\") then\n\t\t\tpath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\t\t\t\n\t\t\tif (path == null) then\n\t\t\t\t(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\n\t\t\tfile = self.computer.File(filePath)\n\t\t\tdebug(\"Looking for file in \" + filePath + \"...\")\n\t\t\t\n\t\t\tif (file == null) then\n\t\t\t\t(new Error).constructor(\"Cannot find $0...\", [filePath]).throw()\n\t\t\tend if\n\t\t\t\n\t\t\tcommand.action.constructor(file)\n\t\t\t\n\t\t\tast = (new AST).constructor(self.computer, file)\n\t\t\tast.analyze()\n\t\t\t\n\t\t\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\t\t\tdependency.findDependencies()\n\t\t\t\n\t\t\tresult.push(dependency)\n\t\tend if\n\tend for\n\t\n\tself.dependencies = result\n\t\n\treturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\n\tself.computer = computer\n\tself.dependency = dependency\n\treturn self\nend function\n\nPreprocessor.run = function()\n\tdebug(\"Run preprocessor...\")\n\tpathHelper = new Path\n\tmainDependency = self.dependency\n\tmainModuleName = md5(mainDependency.target.path)\n\theaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\n\tmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\n\tmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\n\tmodules = {}\n\titerator = function(item)\n\t\tmoduleName = md5(item.target.path)\n\t\t\n\t\tif (modules.hasIndex(moduleName)) then\n\t\t\treturn\n\t\tend if\n\t\t\n\t\tcommands = item.ast.getCommands()\n\t\t\n\t\tfor command in commands\n\t\t\tif (command.key == \"import\") then\n\t\t\t\timportIndex = command.str.indexOf(\"import\")\n\t\t\t\tfromIndex = command.str.indexOf(\"from\")\n\t\t\t\tdefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\n\t\t\t\tdefId = md5(command.action.file.path)\n\t\t\t\tcode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\t\t\t\t\n\t\t\t\titem.ast.transform(command.line, code.toString())\n\t\t\tend if\n\t\tend for\n\t\t\n\t\tif (moduleName != mainModuleName) then\n\t\t\ttransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\n\t\t\tmoduleCode = (new String).constructor(moduleBoilerplate)\n\t\t\tmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\n\t\tend if\n\t\t\n\t\tfor dependency in item.dependencies\n\t\t\titerator(dependency)\n\t\tend for\n\tend function\n\t\n\titerator(mainDependency)\n\t\n\tprocessed = headerBoilerplate\n\t\n\tfor module in modules.values\n\t\tprocessed = processed + module\n\tend for\n\t\n\ttransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\n\tmoduleCode = (new String).constructor(mainBoilerplate)\n\tprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\t\n\treturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\n\tidGenerator = new IdGenerator\n\t\n\tself.buildId = idGenerator.get()\n\tself.name = name\n\tself.computer = computer\n\tself.target = computer.File(self.getFullScriptFilePath())\n\t\n\treturn self\nend function\n\nCompiler.isTargetExisting = function()\n\treturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\n\treturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\n\tpath = new Path\n\treturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\n\tdebug(\"Start processing...\")\n\tfile = self.computer.File(self.getFullScriptFilePath())\n\tast = (new AST).constructor(self.computer, file)\n\tast.analyze()\n\tdependency = (new Dependency).constructor(self.computer, file, ast)\n\tdependency.findDependencies()\n\tpreprocessor = (new Preprocessor).constructor(self.computer, dependency)\n\treturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\n\tpathHelper = new Path\n\tfs = (new FS).constructor(self.computer)\n\tbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\n\tbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\t\n\tself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\t\n\tprint(\"Build id: \" + self.buildId)\n\t\n\tnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\t\n\tif newFile == null then\n\t\texit(\"Unable to create file...\")\n\tend if\n\t\n\tcontent = self.preprocess()\n\t\n\tnewFile.set_content(content)\n\t\n\tprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\t\n\tbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\t\n\tcompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\n\tif self.computer.File(compiledBuildPathFull) == null then\n\t\t(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\n\tend if\nend function\n\nmain = function(name)\n\tmyShell = get_shell\n\tmyComputer = myShell.host_computer\n\t\n\tcompiler = (new Compiler).constructor(myComputer, name)\n\t\n\tif compiler.isTargetExisting == false then\n\t\t(new Error).constructor(\"Cannot find file.\").throw()\n\tend if\n\t\n\tcontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\n\thelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(\"\\n\")\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\n\texit(help)\nend if\n\nfor argDefinition in argDefinitions\n\tkey = argDefinition.command.upper.replace(\"-\", \"_\")\n\tvalue = argv.getWithKey(argDefinition.command)\n\tConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")\n\n\n",
        "ID": "8d14426cd215bd5782ce743a0730ee4e",
        "refCount": 1
    },
    {
        "Content": "BACK_SLASH_CHAR = \"\\\"\nNEW_LINE_OPERATOR = BACK_SLASH_CHAR + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\n  if (MODULES.hasIndex(r) == false) then\n    exit(\"Module \" + r + \" cannot be found...\")\n  end if\n  module = MODULES[r]\n  return module(r)\nend function\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    Argv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    PasswordFile = __REQUIRE(\"e49bedd6fbfe36e5f135d4e838832d72\")\nPasswordEntry = __REQUIRE(\"7d4bd97d0894070e7ba1e9dbfc0cb0a8\")\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\\n\")\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\n\n\n\n\n\n\n\n\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"e49bedd6fbfe36e5f135d4e838832d72\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    FS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\n\tself.file = passwordFile\n\n\treturn passwordFile\nend function\n\t\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nmodule.exports = PasswordFile\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    Path = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    Path = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMODULES[\"7d4bd97d0894070e7ba1e9dbfc0cb0a8\"] = function(r)\n  module = {}\n\n  if (EXPORTED.hasIndex(r)) then\n    module = EXPORTED[r]\n  end if\n\n  if (module.hasIndex(\"exports\") == false) then\n    PasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nmodule.exports = PasswordEntry\n  end if\n\n  EXPORTED[r] = module\n\n  return module.exports\nend function\nMAIN = function()\n  Argv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nkey = argv.get(0, true)\npassword = argv.get(1, true)\noverride = argv.get(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nentry = new PasswordEntry\nentry.constructor(key, password)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tpasswordManager.setPasswordByKey(entry)\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tpasswordManager.passwordList.push(entry)\nend if\n\nprint(\"Saving password...\")\npasswordManager.savePasswordFile()\n\n\n\n\n\nend function\nMAIN()\n\n",
        "ID": "c223ec4105360f45d4dac4351883c3f7",
        "refCount": 1
    },
    {
        "Content": "print(\"\\\".code)",
        "ID": "5b8352771ba2e2ead79d6e2ca795197a",
        "refCount": 1
    },
    {
        "Content": "print(\"\\\".code)\nprint(char(92))",
        "ID": "4232ef9d3e7cadb860bf1f9d61a54874",
        "refCount": 1
    },
    {
        "Content": "s = get_shell\nc = s.host_computer\nh = home_dir\nprint(\"Create compiler folder...\")\nc.create_folder(h, \"compiler\")\nc.create_folder(h, \"tmp\")\nc.touch(h + \"/compiler\", \"compile.src\")\nc.create_folder(h + \"/compiler\", \"boilderplates\")\nc.touch(h + \"/compiler/boilerplates\", \"header.src\")\nc.touch(h + \"/compiler/boilerplates\", \"main.src\")\nc.touch(h + \"/compiler/boilerplates\", \"module.src\")\nprint(\"Create config file...\")\nc.touch(h + \"/Config\", \"compile.conf\")\nprint(\"Write config file...\")\nfile = c.File(h + \"/Config/compile.conf\")\nlines = []\nlines.push(\"COMMAND_START=#\")\nlines.push(\"SCRIPT_FOLDER=/home/$0/scripts\")\nlines.push(\"TEMP_FOLDER=/home/$0/tmp\")\nlines.push(\"COMPILER_FOLDER=/home/$0/compiler\")\nlines.push(\"BOILERPLATE_FOLDER=boilerplates/$0.src\")\nlines.push(\"BIN_FOLDER=/usr/bin\")\nlines.push(\"SCRIPT_EXTENSION=src\")\nlines.push(\"DEBUG=false\")\nlines.push(\"VERSION=0.1.0.0\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write compiler file...\")\nfile = c.File(h + \"/compiler/compile.src\")\nlines = []\nlines.push(\"BACKSLASH_CODE = 92\")\nlines.push(\"NEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"\"n\"\"\")\nlines.push(\"ARGV_OPERATOR = \"\"-\"\"\")\nlines.push(\"\")\nlines.push(\"Config = {}\")\nlines.push(\"\")\nlines.push(\"Config.load = function()\")\nlines.push(\"path = (new String).constructor(\"\"$0/Config/compile.conf\"\")\")\nlines.push(\"path = path.parse([home_dir]).toString()\")\nlines.push(\"file = get_shell.host_computer.File(path)\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"No config in $0...\"\", [path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"content = file.get_content\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"map = {}\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"def = line.split(\"\"=\"\")\")\nlines.push(\"name = def.pull()\")\nlines.push(\"value = def.pull()\")\nlines.push(\"map[name] = value\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.map = map\")\nlines.push(\"\")\nlines.push(\"return map\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.set = function(key, value)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\") and value != null) then\")\nlines.push(\"self.map[key] = value\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.get = function(key)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\")) then\")\nlines.push(\"return self.map[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getScriptFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"SCRIPT_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getTempFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"TEMP_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getCompilerFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"COMPILER_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getExtension = function()\")\nlines.push(\"return Config.get(\"\"SCRIPT_EXTENSION\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.isDebugMode = function()\")\nlines.push(\"value = Config.get(\"\"DEBUG\"\")\")\nlines.push(\"if (typeof(value) == \"\"string\"\") then\")\nlines.push(\"return value == \"\"true\"\"\")\nlines.push(\"end if\")\nlines.push(\"return value\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBoilerplateFile = function(boilerplate)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"BOILERPLATE_FOLDER\"\"))\")\nlines.push(\"return pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBinFolder = function()\")\nlines.push(\"return Config.get(\"\"BIN_FOLDER\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"debug = function(msg)\")\nlines.push(\"if (Config.isDebugMode()) then\")\nlines.push(\"print(msg)\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String = {}\")\nlines.push(\"\")\nlines.push(\"String.constructor = function(str)\")\nlines.push(\"self.str = str\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.parse = function(values)\")\nlines.push(\"result = self.str\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = values.len\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"result = result.replace(\"\"$\"\"+index, values[index])\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return (new String).constructor(result)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.startsWith = function(str)\")\nlines.push(\"return self.str.indexOf(str) == 0\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.substr = function(startIndex, endIndex)\")\nlines.push(\"return (new String).constructor(slice(self.str, startIndex, endIndex))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.indexOf = function(str)\")\nlines.push(\"return self.str.indexOf(str)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.replace = function(str, newStr)\")\nlines.push(\"return (new String).constructor(self.str.replace(str, newStr))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.remove = function(str)\")\nlines.push(\"return (new String).constructor(self.str.remove(str))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.toString = function()\")\nlines.push(\"return self.str\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.length = function()\")\nlines.push(\"return self.str.len\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.split = function(seperator)\")\nlines.push(\"return self.str.split(seperator)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.trim = function(seperator)\")\nlines.push(\"return (new String).constructor(self.str.trim())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error = {}\")\nlines.push(\"\")\nlines.push(\"Error.constructor = function(message, values)\")\nlines.push(\"self.message = message\")\nlines.push(\"if (values != null) then\")\nlines.push(\"self.message = (new String.constructor(message)).parse(values).toString()\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error.throw = function()\")\nlines.push(\"exit(\"\"<color=#ff0000>\"\" + self.message + \"\"</color>\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ArgType = {}\")\nlines.push(\"\")\nlines.push(\"ArgType.FLAG = \"\"FLAG\"\"\")\nlines.push(\"ArgType.VALUE = \"\"VALUE\"\"\")\nlines.push(\"\")\nlines.push(\"Arg = {}\")\nlines.push(\"\")\nlines.push(\"Arg.constructor = function(shortcut, command, type, description)\")\nlines.push(\"self.shortcut = shortcut\")\nlines.push(\"self.command = command\")\nlines.push(\"self.type = type\")\nlines.push(\"self.description = description\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Arg.toString = function()\")\nlines.push(\"str = (new String).constructor(\"\"-$0 --$1 - <b>$2</b>\"\")\")\nlines.push(\"return str.parse([self.shortcut, self.command, self.description]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv = {}\")\nlines.push(\"\")\nlines.push(\"Argv.constructor = function(defs, help)\")\nlines.push(\"self.args = params\")\nlines.push(\"self.listed = {}\")\nlines.push(\"self.unlisted = []\")\nlines.push(\"self.defs = defs\")\nlines.push(\"self.help = help\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.parse = function()\")\nlines.push(\"args = self.args\")\nlines.push(\"defs = self.defs\")\nlines.push(\"listed = {}\")\nlines.push(\"unlisted = []\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = args.len\")\nlines.push(\"findDef = function(arg)\")\nlines.push(\"for def in defs\")\nlines.push(\"if (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\")\nlines.push(\"return def\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"item = args[index].trim()\")\nlines.push(\"def = findDef(item)\")\nlines.push(\"if (def == null) then\")\nlines.push(\"unlisted.push(item)\")\nlines.push(\"else\")\nlines.push(\"if (def.type == ArgType.VALUE) then\")\nlines.push(\"index = index + 1\")\nlines.push(\"value = args[index]\")\nlines.push(\"listed[def.command] = value\")\nlines.push(\"else if (def.type == ArgType.FLAG) then\")\nlines.push(\"listed[def.command] = true\")\nlines.push(\"end if\")\nlines.push(\"end if\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"self.listed = listed\")\nlines.push(\"self.unlisted = unlisted\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.get = function(index = 0, mandatory = false)\")\nlines.push(\"if self.unlisted.hasIndex(index) then\")\nlines.push(\"return self.unlisted[index]\")\nlines.push(\"end if\")\nlines.push(\"if mandatory then\")\nlines.push(\"(new Error).constructor(\"\"Error cannot find param[$0]$1$2$3\"\", [index, NEW_LINE_OPERATOR, NEW_LINE_OPERATOR, self.help]).throw()\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.getWithKey = function(key)\")\nlines.push(\"if self.listed.hasIndex(key) then\")\nlines.push(\"return self.listed[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Math = {}\")\nlines.push(\"\")\nlines.push(\"Math.random = function(min, max)\")\nlines.push(\"return floor((rnd * max) + min)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator = {}\")\nlines.push(\"\")\nlines.push(\"IdGenerator.getChars = function()\")\nlines.push(\"return \"\"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\"\";\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator.get = function()\")\nlines.push(\"math = new Math\")\nlines.push(\"chars = self.getChars()\")\nlines.push(\"\")\nlines.push(\"result = []\")\nlines.push(\"indexA = 0\")\nlines.push(\"maxA = 4\")\nlines.push(\"\")\nlines.push(\"while indexA < maxA\")\nlines.push(\"indexB = 0\")\nlines.push(\"maxB = 5\")\nlines.push(\"code = \"\"\"\"\")\nlines.push(\"\")\nlines.push(\"while indexB < maxB\")\nlines.push(\"code = code + chars[math.random(0, chars.len - 1)]\")\nlines.push(\"\")\nlines.push(\"indexB = indexB + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"result.push(code)\")\nlines.push(\"\")\nlines.push(\"indexA = indexA + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return result.join(\"\"\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path = {}\")\nlines.push(\"\")\nlines.push(\"Path.resolve = function(a)\")\nlines.push(\"parts = a.split(\"\"/\"\")\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for part in parts\")\nlines.push(\"if (part == \"\"..\"\") then\")\nlines.push(\"result.pop()\")\nlines.push(\"else if (part != \"\"\"\" and part != \"\".\"\") then\")\nlines.push(\"result.push(part)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"resolved = result.join(\"\"/\"\")\")\nlines.push(\"\")\nlines.push(\"if (a.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"resolved = \"\"/\"\" + resolved\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return resolved\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path.join = function(a, b)\")\nlines.push(\"if (b.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"b = b[1:]\")\nlines.push(\"end if\")\nlines.push(\"return Path.resolve([a, b].join(\"\"/\"\"))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS = {}\")\nlines.push(\"\")\nlines.push(\"FS.constructor = function(computer)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS.createFile = function(path, name)\")\nlines.push(\"self.computer.touch(path, name)\")\nlines.push(\"return self.computer.File(Path.join(path, name))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand.constructor = function(file)\")\nlines.push(\"self.file = file\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTCommand.constructor = function(line, str, key, action)\")\nlines.push(\"self.line = line\")\nlines.push(\"self.str = str\")\nlines.push(\"self.key = key\")\nlines.push(\"self.action = action\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTRegistry = {}\")\nlines.push(\"\")\nlines.push(\"ASTRegistry.import = ASTImportCommand\")\nlines.push(\"\")\nlines.push(\"AST = {}\")\nlines.push(\"\")\nlines.push(\"AST.constructor = function(computer, file)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.file = file\")\nlines.push(\"self.lines = []\")\nlines.push(\"self.commands = []\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.analyze = function()\")\nlines.push(\"debug(\"\"Analyzing AST...\"\")\")\nlines.push(\"content = self.file.get_content\")\nlines.push(\"commands = []\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"index = 0\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"str = (new String).constructor(line)\")\nlines.push(\"\")\nlines.push(\"if (str.startsWith(Config.get(\"\"COMMAND_START\"\"))) then\")\nlines.push(\"command = str.substr(1, str.indexOf(\"\" \"\"))\")\nlines.push(\"key = command.toString()\")\nlines.push(\"\")\nlines.push(\"if (ASTRegistry[key] == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid command $0 on line $1\"\", [key, index]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"action = ASTRegistry[key]\")\nlines.push(\"entry = (new ASTCommand).constructor(index, str, key, new action)\")\nlines.push(\"commands.push(entry)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"index = index + 1\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.lines = lines\")\nlines.push(\"self.commands = commands\")\nlines.push(\"\")\nlines.push(\"return commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.transform = function(line, code)\")\nlines.push(\"self.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\")\nlines.push(\"\")\nlines.push(\"return self.lines\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.getCommands = function()\")\nlines.push(\"return self.commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency = {}\")\nlines.push(\"\")\nlines.push(\"Dependency.constructor = function(computer, file, ast)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = file\")\nlines.push(\"self.basePath = file.parent.path\")\nlines.push(\"self.ast = ast\")\nlines.push(\"self.dependencies = []\")\nlines.push(\"\")\nlines.push(\"if self.target == null then\")\nlines.push(\"(new Error).constructor(\"\"Dependency $0 does not exist...\"\", [file.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency.findDependencies = function()\")\nlines.push(\"debug(\"\"Finding dependencies...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"commands = self.ast.getCommands()\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"path = command.str.substr(command.str.indexOf(\"\"from\"\") + 4, command.str.indexOf(\"\";\"\")).toString()\")\nlines.push(\"\")\nlines.push(\"if (path == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid import on line $0 in $1...\"\", [command.line, self.target.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"filePath = pathHelper.join(self.basePath, path.trim() + \"\".\"\" + Config.getExtension())\")\nlines.push(\"file = self.computer.File(filePath)\")\nlines.push(\"debug(\"\"Looking for file in \"\" + filePath + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find $0...\"\", [filePath]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"command.action.constructor(file)\")\nlines.push(\"\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"\")\nlines.push(\"result.push(dependency)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.dependencies = result\")\nlines.push(\"\")\nlines.push(\"return result\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor = {}\")\nlines.push(\"\")\nlines.push(\"Preprocessor.constructor = function(computer, dependency)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.dependency = dependency\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor.run = function()\")\nlines.push(\"debug(\"\"Run preprocessor...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"mainDependency = self.dependency\")\nlines.push(\"mainModuleName = md5(mainDependency.target.path)\")\nlines.push(\"headerBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"header\"\")).get_content\")\nlines.push(\"moduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"module\"\")).get_content\")\nlines.push(\"mainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"main\"\")).get_content\")\nlines.push(\"modules = {}\")\nlines.push(\"iterator = function(item)\")\nlines.push(\"moduleName = md5(item.target.path)\")\nlines.push(\"\")\nlines.push(\"if (modules.hasIndex(moduleName)) then\")\nlines.push(\"return\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"commands = item.ast.getCommands()\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"importIndex = command.str.indexOf(\"\"import\"\")\")\nlines.push(\"fromIndex = command.str.indexOf(\"\"from\"\")\")\nlines.push(\"defVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\")\nlines.push(\"defId = md5(command.action.file.path)\")\nlines.push(\"code = (new String).constructor(\"\"$0 = __REQUIRE(\"\"\"\"$1\"\"\"\")\"\").parse([defVar, defId])\")\nlines.push(\"\")\nlines.push(\"item.ast.transform(command.line, code.toString())\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"if (moduleName != mainModuleName) then\")\nlines.push(\"transformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(moduleBoilerplate)\")\nlines.push(\"modules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for dependency in item.dependencies\")\nlines.push(\"iterator(dependency)\")\nlines.push(\"end for\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"iterator(mainDependency)\")\nlines.push(\"\")\nlines.push(\"processed = headerBoilerplate\")\nlines.push(\"\")\nlines.push(\"for module in modules.values\")\nlines.push(\"processed = processed + module\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"transformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(mainBoilerplate)\")\nlines.push(\"processed = processed + moduleCode.parse([transformedCode]).toString()\")\nlines.push(\"\")\nlines.push(\"return processed\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler = {}\")\nlines.push(\"\")\nlines.push(\"Compiler.constructor = function(computer, name)\")\nlines.push(\"idGenerator = new IdGenerator\")\nlines.push(\"\")\nlines.push(\"self.buildId = idGenerator.get()\")\nlines.push(\"self.name = name\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = computer.File(self.getFullScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.isTargetExisting = function()\")\nlines.push(\"return self.target != null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getScriptFilePath = function()\")\nlines.push(\"return self.name + \"\".\"\" + Config.getExtension()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullScriptFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getScriptFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullTempFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getTempFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.preprocess = function()\")\nlines.push(\"debug(\"\"Start processing...\"\")\")\nlines.push(\"file = self.computer.File(self.getFullScriptFilePath())\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"preprocessor = (new Preprocessor).constructor(self.computer, dependency)\")\nlines.push(\"return preprocessor.run()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.compile = function(shell)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"fs = (new FS).constructor(self.computer)\")\nlines.push(\"buildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\")\nlines.push(\"buildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"self.computer.create_folder(Config.getTempFolder(), self.buildId)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Build id: \"\" + self.buildId)\")\nlines.push(\"\")\nlines.push(\"newFile = fs.createFile(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"if newFile == null then\")\nlines.push(\"exit(\"\"Unable to create file...\"\")\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = self.preprocess()\")\nlines.push(\"\")\nlines.push(\"newFile.set_content(content)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Building in \"\" + Config.getBinFolder() + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"buildReport = shell.build(buildPathFull, Config.getBinFolder())\")\nlines.push(\"\")\nlines.push(\"compiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\")\nlines.push(\"if self.computer.File(compiledBuildPathFull) == null then\")\nlines.push(\"(new Error).constructor(\"\"Built failed: $0\"\", [buildReport]).throw()\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"main = function(name)\")\nlines.push(\"myShell = get_shell\")\nlines.push(\"myComputer = myShell.host_computer\")\nlines.push(\"\")\nlines.push(\"compiler = (new Compiler).constructor(myComputer, name)\")\nlines.push(\"\")\nlines.push(\"if compiler.isTargetExisting == false then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find file.\"\").throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = compiler.compile(myShell)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.load()\")\nlines.push(\"\")\nlines.push(\"argDefinitions = []\")\nlines.push(\"\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"h\"\", \"\"help\"\", ArgType.FLAG, \"\"Print help\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"d\"\", \"\"debug\"\", ArgType.FLAG, \"\"Activate debug mode\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"cs\"\", \"\"command-start\"\", ArgType.VALUE, \"\"Command starting operator\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"s\"\", \"\"script-folder\"\", ArgType.VALUE, \"\"Script folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"t\"\", \"\"temp-folder\"\", ArgType.VALUE, \"\"Temporary folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"c\"\", \"\"compiler-folder\"\", ArgType.VALUE, \"\"Compiler folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"b\"\", \"\"bin-folder\"\", ArgType.VALUE, \"\"Bin folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"se\"\", \"\"script-extension\"\", ArgType.VALUE, \"\"Script extension\"\"))\")\nlines.push(\"\")\nlines.push(\"helpBlock = []\")\nlines.push(\"\")\nlines.push(\"helpBlock.push(\"\"Compiler CLI\"\")\")\nlines.push(\"helpBlock.push(\"\"Version: \"\" + Config.get(\"\"VERSION\"\"))\")\nlines.push(\"helpBlock.push(\"\"Example: <b>compile myscriptfile</b>\"\")\")\nlines.push(\"helpBlock.push(\"\"\"\")\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"helpBlock.push(argDefinition.toString())\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"help = helpBlock.join(NEW_LINE_OPERATOR)\")\nlines.push(\"\")\nlines.push(\"argv = (new Argv).constructor(argDefinitions, help)\")\nlines.push(\"\")\nlines.push(\"argv.parse()\")\nlines.push(\"\")\nlines.push(\"if (argv.getWithKey(\"\"help\"\") == true) then\")\nlines.push(\"exit(help)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"key = argDefinition.command.upper.replace(\"\"-\"\", \"\"_\"\")\")\nlines.push(\"value = argv.getWithKey(argDefinition.command)\")\nlines.push(\"Config.set(key, value)\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"debug(\"\"Start compiling...\"\")\")\nlines.push(\"main(argv.get(0, true))\")\nlines.push(\"exit(\"\"Done compiling...\"\")\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates header file...\")\nfile = c.File(h + \"/compiler/boilderplate/header.src\")\nlines = []\nlines.push(\"BACK_SLASH_CHAR = \"\"\"\"\")\nlines.push(\"NEW_LINE_OPERATOR = BACK_SLASH_CHAR + \"\"n\"\"\")\nlines.push(\"MODULES = {}\")\nlines.push(\"EXPORTED = {}\")\nlines.push(\"\")\nlines.push(\"__REQUIRE = function(r)\")\nlines.push(\"if (MODULES.hasIndex(r) == false) then\")\nlines.push(\"exit(\"\"Module \"\" + r + \"\" cannot be found...\"\")\")\nlines.push(\"end if\")\nlines.push(\"module = MODULES[r]\")\nlines.push(\"return module(r)\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates module file...\")\nfile = c.File(h + \"/compiler/boilderplate/module.src\")\nlines = []\nlines.push(\"MODULES[\"\"$0\"\"] = function(r)\")\nlines.push(\"module = {}\")\nlines.push(\"\")\nlines.push(\"if (EXPORTED.hasIndex(r)) then\")\nlines.push(\"module = EXPORTED[r]\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"if (module.hasIndex(\"\"exports\"\") == false) then\")\nlines.push(\"$1\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"EXPORTED[r] = module\")\nlines.push(\"\")\nlines.push(\"return module.exports\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates main file...\")\nfile = c.File(h + \"/compiler/boilderplate/main.src\")\nlines = []\nlines.push(\"MAIN = function()\")\nlines.push(\"$0\")\nlines.push(\"end function\")\nlines.push(\"MAIN()\")\nfile.set_content(lines.join(\"\\n\"))\n\n",
        "ID": "d41a528d8b6a556e623c09cc4347a007",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\npath = (new String).constructor(\"$0/Config/compile.conf\")\npath = path.parse([home_dir]).toString()\nfile = get_shell.host_computer.File(path)\nif (file == null) then\n(new Error).constructor(\"No config in $0...\", [path]).throw()\nend if\ncontent = file.get_content\nlines = content.split(NEW_LINE_OPERATOR)\nmap = {}\n\nfor line in lines\ndef = line.split(\"=\")\nname = def.pull()\nvalue = def.pull()\nmap[name] = value\nend for\n\nself.map = map\n\nreturn map\nend function\n\nConfig.set = function(key, value)\nif (self.hasIndex(\"map\") and value != null) then\nself.map[key] = value\nend if\nreturn self\nend function\n\nConfig.get = function(key)\nif (self.hasIndex(\"map\")) then\nreturn self.map[key]\nend if\nreturn null\nend function\n\nConfig.getScriptFolder = function()\npath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\nuser = active_user\nreturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\npath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\nuser = active_user\nreturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\npath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\nuser = active_user\nreturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\nreturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\nvalue = Config.get(\"DEBUG\")\nif (typeof(value) == \"string\") then\nreturn value == \"true\"\nend if\nreturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\npathHelper = new Path\npath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\nreturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\nreturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\nif (Config.isDebugMode()) then\nprint(msg)\nend if\nend function\n\nString = {}\n\nString.constructor = function(str)\nself.str = str\nreturn self\nend function\n\nString.parse = function(values)\nresult = self.str\nindex = 0\nmaxIndex = values.len\n\nwhile index < maxIndex\nresult = result.replace(\"$\"+index, values[index])\nindex = index + 1\nend while\n\nreturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\nreturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\nreturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\nreturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\nreturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\nreturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\nreturn self.str\nend function\n\nString.length = function()\nreturn self.str.len\nend function\n\nString.split = function(seperator)\nreturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\nreturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\nself.message = message\nif (values != null) then\nself.message = (new String.constructor(message)).parse(values).toString()\nend if\nreturn self\nend function\n\nError.throw = function()\nexit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\nself.shortcut = shortcut\nself.command = command\nself.type = type\nself.description = description\nreturn self\nend function\n\nArg.toString = function()\nstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\nreturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\nself.args = params\nself.listed = {}\nself.unlisted = []\nself.defs = defs\nself.help = help\nreturn self\nend function\n\nArgv.parse = function()\nargs = self.args\ndefs = self.defs\nlisted = {}\nunlisted = []\nindex = 0\nmaxIndex = args.len\nfindDef = function(arg)\nfor def in defs\nif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\nreturn def\nend if\nend for\nreturn null\nend function\n\nwhile index < maxIndex\nitem = args[index].trim()\ndef = findDef(item)\nif (def == null) then\nunlisted.push(item)\nelse\nif (def.type == ArgType.VALUE) then\nindex = index + 1\nvalue = args[index]\nlisted[def.command] = value\nelse if (def.type == ArgType.FLAG) then\nlisted[def.command] = true\nend if\nend if\nindex = index + 1\nend while\n\nself.listed = listed\nself.unlisted = unlisted\n\nreturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\nif self.unlisted.hasIndex(index) then\nreturn self.unlisted[index]\nend if\nif mandatory then\n(new Error).constructor(\"Error cannot find param[$0]$1$2$3\", [index, NEW_LINE_OPERATOR, NEW_LINE_OPERATOR, self.help]).throw()\nend if\nreturn null\nend function\n\nArgv.getWithKey = function(key)\nif self.listed.hasIndex(key) then\nreturn self.listed[key]\nend if\nreturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\nreturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\nreturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\nmath = new Math\nchars = self.getChars()\n\nresult = []\nindexA = 0\nmaxA = 4\n\nwhile indexA < maxA\nindexB = 0\nmaxB = 5\ncode = \"\"\n\nwhile indexB < maxB\ncode = code + chars[math.random(0, chars.len - 1)]\n\nindexB = indexB + 1\nend while\n\nresult.push(code)\n\nindexA = indexA + 1\nend while\n\nreturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.resolve = function(a)\nparts = a.split(\"/\")\nresult = []\n\nfor part in parts\nif (part == \"..\") then\nresult.pop()\nelse if (part != \"\" and part != \".\") then\nresult.push(part)\nend if\nend for\n\nresolved = result.join(\"/\")\n\nif (a.indexOf(\"/\") == 0) then\nresolved = \"/\" + resolved\nend if\n\nreturn resolved\nend function\n\nPath.join = function(a, b)\nif (b.indexOf(\"/\") == 0) then\nb = b[1:]\nend if\nreturn Path.resolve([a, b].join(\"/\"))\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\nself.computer = computer\nreturn self\nend function\n\nFS.createFile = function(path, name)\nself.computer.touch(path, name)\nreturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\nself.file = file\nreturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\nself.line = line\nself.str = str\nself.key = key\nself.action = action\nreturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\nself.computer = computer\nself.file = file\nself.lines = []\nself.commands = []\nreturn self\nend function\n\nAST.analyze = function()\ndebug(\"Analyzing AST...\")\ncontent = self.file.get_content\ncommands = []\nlines = content.split(NEW_LINE_OPERATOR)\nindex = 0\n\nfor line in lines\nstr = (new String).constructor(line)\n\nif (str.startsWith(Config.get(\"COMMAND_START\"))) then\ncommand = str.substr(1, str.indexOf(\" \"))\nkey = command.toString()\n\nif (ASTRegistry[key] == null) then\n(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\nend if\n\naction = ASTRegistry[key]\nentry = (new ASTCommand).constructor(index, str, key, new action)\ncommands.push(entry)\nend if\n\nindex = index + 1\nend for\n\nself.lines = lines\nself.commands = commands\n\nreturn commands\nend function\n\nAST.transform = function(line, code)\nself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\nreturn self.lines\nend function\n\nAST.getCommands = function()\nreturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\npathHelper = new Path\n\nself.computer = computer\nself.target = file\nself.basePath = file.parent.path\nself.ast = ast\nself.dependencies = []\n\nif self.target == null then\n(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\nend if\n\nreturn self\nend function\n\nDependency.findDependencies = function()\ndebug(\"Finding dependencies...\")\npathHelper = new Path\ncommands = self.ast.getCommands()\nresult = []\n\nfor command in commands\nif (command.key == \"import\") then\npath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\nif (path == null) then\n(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\nend if\n\nfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\nfile = self.computer.File(filePath)\ndebug(\"Looking for file in \" + filePath + \"...\")\n\nif (file == null) then\n(new Error).constructor(\"Cannot find $0...\", [filePath]).throw()\nend if\n\ncommand.action.constructor(file)\n\nast = (new AST).constructor(self.computer, file)\nast.analyze()\n\ndependency = (new Dependency).constructor(self.computer, file, ast)\ndependency.findDependencies()\n\nresult.push(dependency)\nend if\nend for\n\nself.dependencies = result\n\nreturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\nself.computer = computer\nself.dependency = dependency\nreturn self\nend function\n\nPreprocessor.run = function()\ndebug(\"Run preprocessor...\")\npathHelper = new Path\nmainDependency = self.dependency\nmainModuleName = md5(mainDependency.target.path)\nheaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\nmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\nmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\nmodules = {}\niterator = function(item)\nmoduleName = md5(item.target.path)\n\nif (modules.hasIndex(moduleName)) then\nreturn\nend if\n\ncommands = item.ast.getCommands()\n\nfor command in commands\nif (command.key == \"import\") then\nimportIndex = command.str.indexOf(\"import\")\nfromIndex = command.str.indexOf(\"from\")\ndefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\ndefId = md5(command.action.file.path)\ncode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\nitem.ast.transform(command.line, code.toString())\nend if\nend for\n\nif (moduleName != mainModuleName) then\ntransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\nmoduleCode = (new String).constructor(moduleBoilerplate)\nmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\nend if\n\nfor dependency in item.dependencies\niterator(dependency)\nend for\nend function\n\niterator(mainDependency)\n\nprocessed = headerBoilerplate\n\nfor module in modules.values\nprocessed = processed + module\nend for\n\ntransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\nmoduleCode = (new String).constructor(mainBoilerplate)\nprocessed = processed + moduleCode.parse([transformedCode]).toString()\n\nreturn processed\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\nidGenerator = new IdGenerator\n\nself.buildId = idGenerator.get()\nself.name = name\nself.computer = computer\nself.target = computer.File(self.getFullScriptFilePath())\n\nreturn self\nend function\n\nCompiler.isTargetExisting = function()\nreturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\nreturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\npath = new Path\nreturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\npath = new Path\nreturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\ndebug(\"Start processing...\")\nfile = self.computer.File(self.getFullScriptFilePath())\nast = (new AST).constructor(self.computer, file)\nast.analyze()\ndependency = (new Dependency).constructor(self.computer, file, ast)\ndependency.findDependencies()\npreprocessor = (new Preprocessor).constructor(self.computer, dependency)\nreturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\npathHelper = new Path\nfs = (new FS).constructor(self.computer)\nbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\nbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\nself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\nprint(\"Build id: \" + self.buildId)\n\nnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\nif newFile == null then\nexit(\"Unable to create file...\")\nend if\n\ncontent = self.preprocess()\n\nnewFile.set_content(content)\n\nprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\nbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\ncompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\nif self.computer.File(compiledBuildPathFull) == null then\n(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\nend if\nend function\n\nmain = function(name)\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\ncompiler = (new Compiler).constructor(myComputer, name)\n\nif compiler.isTargetExisting == false then\n(new Error).constructor(\"Cannot find file.\").throw()\nend if\n\ncontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\nhelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(NEW_LINE_OPERATOR)\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\nexit(help)\nend if\n\nfor argDefinition in argDefinitions\nkey = argDefinition.command.upper.replace(\"-\", \"_\")\nvalue = argv.getWithKey(argDefinition.command)\nConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")",
        "ID": "e0cc88bfe0aa552927eb1b5a6cdc598a",
        "refCount": 1
    },
    {
        "Content": "s = get_shell\nc = s.host_computer\nh = home_dir\nprint(\"Create compiler folder...\")\nc.create_folder(h, \"compiler\")\nc.create_folder(h, \"tmp\")\nc.touch(h + \"/compiler\", \"compile.src\")\nc.create_folder(h + \"/compiler\", \"boilderplates\")\nc.touch(h + \"/compiler/boilerplates\", \"header.src\")\nc.touch(h + \"/compiler/boilerplates\", \"main.src\")\nc.touch(h + \"/compiler/boilerplates\", \"module.src\")\nprint(\"Create config file...\")\nc.touch(h + \"/Config\", \"compile.conf\")\nprint(\"Write config file...\")\nfile = c.File(h + \"/Config/compile.conf\")\nlines = []\nlines.push(\"COMMAND_START=#\")\nlines.push(\"SCRIPT_FOLDER=/home/$0/scripts\")\nlines.push(\"TEMP_FOLDER=/home/$0/tmp\")\nlines.push(\"COMPILER_FOLDER=/home/$0/compiler\")\nlines.push(\"BOILERPLATE_FOLDER=boilerplates/$0.src\")\nlines.push(\"BIN_FOLDER=/usr/bin\")\nlines.push(\"SCRIPT_EXTENSION=src\")\nlines.push(\"DEBUG=false\")\nlines.push(\"VERSION=0.1.0.0\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write compiler file...\")\nfile = c.File(h + \"/compiler/compile.src\")\nlines = []\nlines.push(\"BACKSLASH_CODE = 92\")\nlines.push(\"NEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"\"n\"\"\")\nlines.push(\"ARGV_OPERATOR = \"\"-\"\"\")\nlines.push(\"\")\nlines.push(\"Config = {}\")\nlines.push(\"\")\nlines.push(\"Config.load = function()\")\nlines.push(\"path = (new String).constructor(\"\"$0/Config/compile.conf\"\")\")\nlines.push(\"path = path.parse([home_dir]).toString()\")\nlines.push(\"file = get_shell.host_computer.File(path)\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"No config in $0...\"\", [path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"content = file.get_content\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"map = {}\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"def = line.split(\"\"=\"\")\")\nlines.push(\"name = def.pull()\")\nlines.push(\"value = def.pull()\")\nlines.push(\"map[name] = value\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.map = map\")\nlines.push(\"\")\nlines.push(\"return map\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.set = function(key, value)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\") and value != null) then\")\nlines.push(\"self.map[key] = value\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.get = function(key)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\")) then\")\nlines.push(\"return self.map[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getScriptFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"SCRIPT_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getTempFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"TEMP_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getCompilerFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"COMPILER_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getExtension = function()\")\nlines.push(\"return Config.get(\"\"SCRIPT_EXTENSION\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.isDebugMode = function()\")\nlines.push(\"value = Config.get(\"\"DEBUG\"\")\")\nlines.push(\"if (typeof(value) == \"\"string\"\") then\")\nlines.push(\"return value == \"\"true\"\"\")\nlines.push(\"end if\")\nlines.push(\"return value\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBoilerplateFile = function(boilerplate)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"BOILERPLATE_FOLDER\"\"))\")\nlines.push(\"return pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBinFolder = function()\")\nlines.push(\"return Config.get(\"\"BIN_FOLDER\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"debug = function(msg)\")\nlines.push(\"if (Config.isDebugMode()) then\")\nlines.push(\"print(msg)\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String = {}\")\nlines.push(\"\")\nlines.push(\"String.constructor = function(str)\")\nlines.push(\"self.str = str\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.parse = function(values)\")\nlines.push(\"result = self.str\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = values.len\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"result = result.replace(\"\"$\"\"+index, values[index])\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return (new String).constructor(result)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.startsWith = function(str)\")\nlines.push(\"return self.str.indexOf(str) == 0\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.substr = function(startIndex, endIndex)\")\nlines.push(\"return (new String).constructor(slice(self.str, startIndex, endIndex))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.indexOf = function(str)\")\nlines.push(\"return self.str.indexOf(str)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.replace = function(str, newStr)\")\nlines.push(\"return (new String).constructor(self.str.replace(str, newStr))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.remove = function(str)\")\nlines.push(\"return (new String).constructor(self.str.remove(str))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.toString = function()\")\nlines.push(\"return self.str\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.length = function()\")\nlines.push(\"return self.str.len\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.split = function(seperator)\")\nlines.push(\"return self.str.split(seperator)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.trim = function(seperator)\")\nlines.push(\"return (new String).constructor(self.str.trim())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error = {}\")\nlines.push(\"\")\nlines.push(\"Error.constructor = function(message, values)\")\nlines.push(\"self.message = message\")\nlines.push(\"if (values != null) then\")\nlines.push(\"self.message = (new String.constructor(message)).parse(values).toString()\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error.throw = function()\")\nlines.push(\"exit(\"\"<color=#ff0000>\"\" + self.message + \"\"</color>\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ArgType = {}\")\nlines.push(\"\")\nlines.push(\"ArgType.FLAG = \"\"FLAG\"\"\")\nlines.push(\"ArgType.VALUE = \"\"VALUE\"\"\")\nlines.push(\"\")\nlines.push(\"Arg = {}\")\nlines.push(\"\")\nlines.push(\"Arg.constructor = function(shortcut, command, type, description)\")\nlines.push(\"self.shortcut = shortcut\")\nlines.push(\"self.command = command\")\nlines.push(\"self.type = type\")\nlines.push(\"self.description = description\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Arg.toString = function()\")\nlines.push(\"str = (new String).constructor(\"\"-$0 --$1 - <b>$2</b>\"\")\")\nlines.push(\"return str.parse([self.shortcut, self.command, self.description]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv = {}\")\nlines.push(\"\")\nlines.push(\"Argv.constructor = function(defs, help)\")\nlines.push(\"self.args = params\")\nlines.push(\"self.listed = {}\")\nlines.push(\"self.unlisted = []\")\nlines.push(\"self.defs = defs\")\nlines.push(\"self.help = help\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.parse = function()\")\nlines.push(\"args = self.args\")\nlines.push(\"defs = self.defs\")\nlines.push(\"listed = {}\")\nlines.push(\"unlisted = []\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = args.len\")\nlines.push(\"findDef = function(arg)\")\nlines.push(\"for def in defs\")\nlines.push(\"if (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\")\nlines.push(\"return def\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"item = args[index].trim()\")\nlines.push(\"def = findDef(item)\")\nlines.push(\"if (def == null) then\")\nlines.push(\"unlisted.push(item)\")\nlines.push(\"else\")\nlines.push(\"if (def.type == ArgType.VALUE) then\")\nlines.push(\"index = index + 1\")\nlines.push(\"value = args[index]\")\nlines.push(\"listed[def.command] = value\")\nlines.push(\"else if (def.type == ArgType.FLAG) then\")\nlines.push(\"listed[def.command] = true\")\nlines.push(\"end if\")\nlines.push(\"end if\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"self.listed = listed\")\nlines.push(\"self.unlisted = unlisted\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.get = function(index = 0, mandatory = false)\")\nlines.push(\"if self.unlisted.hasIndex(index) then\")\nlines.push(\"return self.unlisted[index]\")\nlines.push(\"end if\")\nlines.push(\"if mandatory then\")\nlines.push(\"(new Error).constructor(\"\"Error cannot find param[$0]$1$2$3\"\", [index, NEW_LINE_OPERATOR, NEW_LINE_OPERATOR, self.help]).throw()\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.getWithKey = function(key)\")\nlines.push(\"if self.listed.hasIndex(key) then\")\nlines.push(\"return self.listed[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Math = {}\")\nlines.push(\"\")\nlines.push(\"Math.random = function(min, max)\")\nlines.push(\"return floor((rnd * max) + min)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator = {}\")\nlines.push(\"\")\nlines.push(\"IdGenerator.getChars = function()\")\nlines.push(\"return \"\"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\"\";\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator.get = function()\")\nlines.push(\"math = new Math\")\nlines.push(\"chars = self.getChars()\")\nlines.push(\"\")\nlines.push(\"result = []\")\nlines.push(\"indexA = 0\")\nlines.push(\"maxA = 4\")\nlines.push(\"\")\nlines.push(\"while indexA < maxA\")\nlines.push(\"indexB = 0\")\nlines.push(\"maxB = 5\")\nlines.push(\"code = \"\"\"\"\")\nlines.push(\"\")\nlines.push(\"while indexB < maxB\")\nlines.push(\"code = code + chars[math.random(0, chars.len - 1)]\")\nlines.push(\"\")\nlines.push(\"indexB = indexB + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"result.push(code)\")\nlines.push(\"\")\nlines.push(\"indexA = indexA + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return result.join(\"\"\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path = {}\")\nlines.push(\"\")\nlines.push(\"Path.resolve = function(a)\")\nlines.push(\"parts = a.split(\"\"/\"\")\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for part in parts\")\nlines.push(\"if (part == \"\"..\"\") then\")\nlines.push(\"result.pop()\")\nlines.push(\"else if (part != \"\"\"\" and part != \"\".\"\") then\")\nlines.push(\"result.push(part)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"resolved = result.join(\"\"/\"\")\")\nlines.push(\"\")\nlines.push(\"if (a.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"resolved = \"\"/\"\" + resolved\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return resolved\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path.join = function(a, b)\")\nlines.push(\"if (b.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"b = b[1:]\")\nlines.push(\"end if\")\nlines.push(\"return Path.resolve([a, b].join(\"\"/\"\"))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS = {}\")\nlines.push(\"\")\nlines.push(\"FS.constructor = function(computer)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS.createFile = function(path, name)\")\nlines.push(\"self.computer.touch(path, name)\")\nlines.push(\"return self.computer.File(Path.join(path, name))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand.constructor = function(file)\")\nlines.push(\"self.file = file\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTCommand.constructor = function(line, str, key, action)\")\nlines.push(\"self.line = line\")\nlines.push(\"self.str = str\")\nlines.push(\"self.key = key\")\nlines.push(\"self.action = action\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTRegistry = {}\")\nlines.push(\"\")\nlines.push(\"ASTRegistry.import = ASTImportCommand\")\nlines.push(\"\")\nlines.push(\"AST = {}\")\nlines.push(\"\")\nlines.push(\"AST.constructor = function(computer, file)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.file = file\")\nlines.push(\"self.lines = []\")\nlines.push(\"self.commands = []\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.analyze = function()\")\nlines.push(\"debug(\"\"Analyzing AST...\"\")\")\nlines.push(\"content = self.file.get_content\")\nlines.push(\"commands = []\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"index = 0\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"str = (new String).constructor(line)\")\nlines.push(\"\")\nlines.push(\"if (str.startsWith(Config.get(\"\"COMMAND_START\"\"))) then\")\nlines.push(\"command = str.substr(1, str.indexOf(\"\" \"\"))\")\nlines.push(\"key = command.toString()\")\nlines.push(\"\")\nlines.push(\"if (ASTRegistry[key] == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid command $0 on line $1\"\", [key, index]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"action = ASTRegistry[key]\")\nlines.push(\"entry = (new ASTCommand).constructor(index, str, key, new action)\")\nlines.push(\"commands.push(entry)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"index = index + 1\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.lines = lines\")\nlines.push(\"self.commands = commands\")\nlines.push(\"\")\nlines.push(\"return commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.transform = function(line, code)\")\nlines.push(\"self.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\")\nlines.push(\"\")\nlines.push(\"return self.lines\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.getCommands = function()\")\nlines.push(\"return self.commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency = {}\")\nlines.push(\"\")\nlines.push(\"Dependency.constructor = function(computer, file, ast)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = file\")\nlines.push(\"self.basePath = file.parent.path\")\nlines.push(\"self.ast = ast\")\nlines.push(\"self.dependencies = []\")\nlines.push(\"\")\nlines.push(\"if self.target == null then\")\nlines.push(\"(new Error).constructor(\"\"Dependency $0 does not exist...\"\", [file.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency.findDependencies = function()\")\nlines.push(\"debug(\"\"Finding dependencies...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"commands = self.ast.getCommands()\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"path = command.str.substr(command.str.indexOf(\"\"from\"\") + 4, command.str.indexOf(\"\";\"\")).toString()\")\nlines.push(\"\")\nlines.push(\"if (path == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid import on line $0 in $1...\"\", [command.line, self.target.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"filePath = pathHelper.join(self.basePath, path.trim() + \"\".\"\" + Config.getExtension())\")\nlines.push(\"file = self.computer.File(filePath)\")\nlines.push(\"debug(\"\"Looking for file in \"\" + filePath + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find $0...\"\", [filePath]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"command.action.constructor(file)\")\nlines.push(\"\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"\")\nlines.push(\"result.push(dependency)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.dependencies = result\")\nlines.push(\"\")\nlines.push(\"return result\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor = {}\")\nlines.push(\"\")\nlines.push(\"Preprocessor.constructor = function(computer, dependency)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.dependency = dependency\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor.run = function()\")\nlines.push(\"debug(\"\"Run preprocessor...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"mainDependency = self.dependency\")\nlines.push(\"mainModuleName = md5(mainDependency.target.path)\")\nlines.push(\"headerBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"header\"\")).get_content\")\nlines.push(\"moduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"module\"\")).get_content\")\nlines.push(\"mainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"main\"\")).get_content\")\nlines.push(\"modules = {}\")\nlines.push(\"iterator = function(item)\")\nlines.push(\"moduleName = md5(item.target.path)\")\nlines.push(\"\")\nlines.push(\"if (modules.hasIndex(moduleName)) then\")\nlines.push(\"return\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"commands = item.ast.getCommands()\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"importIndex = command.str.indexOf(\"\"import\"\")\")\nlines.push(\"fromIndex = command.str.indexOf(\"\"from\"\")\")\nlines.push(\"defVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\")\nlines.push(\"defId = md5(command.action.file.path)\")\nlines.push(\"code = (new String).constructor(\"\"$0 = __REQUIRE(\"\"\"\"$1\"\"\"\")\"\").parse([defVar, defId])\")\nlines.push(\"\")\nlines.push(\"item.ast.transform(command.line, code.toString())\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"if (moduleName != mainModuleName) then\")\nlines.push(\"transformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(moduleBoilerplate)\")\nlines.push(\"modules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for dependency in item.dependencies\")\nlines.push(\"iterator(dependency)\")\nlines.push(\"end for\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"iterator(mainDependency)\")\nlines.push(\"\")\nlines.push(\"processed = headerBoilerplate\")\nlines.push(\"\")\nlines.push(\"for module in modules.values\")\nlines.push(\"processed = processed + module\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"transformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(mainBoilerplate)\")\nlines.push(\"processed = processed + moduleCode.parse([transformedCode]).toString()\")\nlines.push(\"\")\nlines.push(\"return processed\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler = {}\")\nlines.push(\"\")\nlines.push(\"Compiler.constructor = function(computer, name)\")\nlines.push(\"idGenerator = new IdGenerator\")\nlines.push(\"\")\nlines.push(\"self.buildId = idGenerator.get()\")\nlines.push(\"self.name = name\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = computer.File(self.getFullScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.isTargetExisting = function()\")\nlines.push(\"return self.target != null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getScriptFilePath = function()\")\nlines.push(\"return self.name + \"\".\"\" + Config.getExtension()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullScriptFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getScriptFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullTempFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getTempFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.preprocess = function()\")\nlines.push(\"debug(\"\"Start processing...\"\")\")\nlines.push(\"file = self.computer.File(self.getFullScriptFilePath())\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"preprocessor = (new Preprocessor).constructor(self.computer, dependency)\")\nlines.push(\"return preprocessor.run()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.compile = function(shell)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"fs = (new FS).constructor(self.computer)\")\nlines.push(\"buildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\")\nlines.push(\"buildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"self.computer.create_folder(Config.getTempFolder(), self.buildId)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Build id: \"\" + self.buildId)\")\nlines.push(\"\")\nlines.push(\"newFile = fs.createFile(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"if newFile == null then\")\nlines.push(\"exit(\"\"Unable to create file...\"\")\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = self.preprocess()\")\nlines.push(\"\")\nlines.push(\"newFile.set_content(content)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Building in \"\" + Config.getBinFolder() + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"buildReport = shell.build(buildPathFull, Config.getBinFolder())\")\nlines.push(\"\")\nlines.push(\"compiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\")\nlines.push(\"if self.computer.File(compiledBuildPathFull) == null then\")\nlines.push(\"(new Error).constructor(\"\"Built failed: $0\"\", [buildReport]).throw()\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"main = function(name)\")\nlines.push(\"myShell = get_shell\")\nlines.push(\"myComputer = myShell.host_computer\")\nlines.push(\"\")\nlines.push(\"compiler = (new Compiler).constructor(myComputer, name)\")\nlines.push(\"\")\nlines.push(\"if compiler.isTargetExisting == false then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find file.\"\").throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = compiler.compile(myShell)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.load()\")\nlines.push(\"\")\nlines.push(\"argDefinitions = []\")\nlines.push(\"\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"h\"\", \"\"help\"\", ArgType.FLAG, \"\"Print help\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"d\"\", \"\"debug\"\", ArgType.FLAG, \"\"Activate debug mode\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"cs\"\", \"\"command-start\"\", ArgType.VALUE, \"\"Command starting operator\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"s\"\", \"\"script-folder\"\", ArgType.VALUE, \"\"Script folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"t\"\", \"\"temp-folder\"\", ArgType.VALUE, \"\"Temporary folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"c\"\", \"\"compiler-folder\"\", ArgType.VALUE, \"\"Compiler folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"b\"\", \"\"bin-folder\"\", ArgType.VALUE, \"\"Bin folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"se\"\", \"\"script-extension\"\", ArgType.VALUE, \"\"Script extension\"\"))\")\nlines.push(\"\")\nlines.push(\"helpBlock = []\")\nlines.push(\"\")\nlines.push(\"helpBlock.push(\"\"Compiler CLI\"\")\")\nlines.push(\"helpBlock.push(\"\"Version: \"\" + Config.get(\"\"VERSION\"\"))\")\nlines.push(\"helpBlock.push(\"\"Example: <b>compile myscriptfile</b>\"\")\")\nlines.push(\"helpBlock.push(\"\"\"\")\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"helpBlock.push(argDefinition.toString())\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"help = helpBlock.join(NEW_LINE_OPERATOR)\")\nlines.push(\"\")\nlines.push(\"argv = (new Argv).constructor(argDefinitions, help)\")\nlines.push(\"\")\nlines.push(\"argv.parse()\")\nlines.push(\"\")\nlines.push(\"if (argv.getWithKey(\"\"help\"\") == true) then\")\nlines.push(\"exit(help)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"key = argDefinition.command.upper.replace(\"\"-\"\", \"\"_\"\")\")\nlines.push(\"value = argv.getWithKey(argDefinition.command)\")\nlines.push(\"Config.set(key, value)\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"debug(\"\"Start compiling...\"\")\")\nlines.push(\"main(argv.get(0, true))\")\nlines.push(\"exit(\"\"Done compiling...\"\")\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates header file...\")\nfile = c.File(h + \"/compiler/boilerplate/header.src\")\nlines = []\nlines.push(\"BACK_SLASH_CHAR = \"\"\"\"\")\nlines.push(\"NEW_LINE_OPERATOR = BACK_SLASH_CHAR + \"\"n\"\"\")\nlines.push(\"MODULES = {}\")\nlines.push(\"EXPORTED = {}\")\nlines.push(\"\")\nlines.push(\"__REQUIRE = function(r)\")\nlines.push(\"if (MODULES.hasIndex(r) == false) then\")\nlines.push(\"exit(\"\"Module \"\" + r + \"\" cannot be found...\"\")\")\nlines.push(\"end if\")\nlines.push(\"module = MODULES[r]\")\nlines.push(\"return module(r)\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates module file...\")\nfile = c.File(h + \"/compiler/boilerplate/module.src\")\nlines = []\nlines.push(\"MODULES[\"\"$0\"\"] = function(r)\")\nlines.push(\"module = {}\")\nlines.push(\"\")\nlines.push(\"if (EXPORTED.hasIndex(r)) then\")\nlines.push(\"module = EXPORTED[r]\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"if (module.hasIndex(\"\"exports\"\") == false) then\")\nlines.push(\"$1\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"EXPORTED[r] = module\")\nlines.push(\"\")\nlines.push(\"return module.exports\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates main file...\")\nfile = c.File(h + \"/compiler/boilerplate/main.src\")\nlines = []\nlines.push(\"MAIN = function()\")\nlines.push(\"$0\")\nlines.push(\"end function\")\nlines.push(\"MAIN()\")\nfile.set_content(lines.join(\"\\n\"))\n\n",
        "ID": "16b939cf3a0f8e7c8ff30b65a7ba6c60",
        "refCount": 1
    },
    {
        "Content": "s = get_shell\nc = s.host_computer\nh = home_dir\nprint(\"Create compiler folder...\")\nc.create_folder(h, \"compiler\")\nc.create_folder(h, \"tmp\")\nc.touch(h + \"/compiler\", \"compile.src\")\nc.create_folder(h + \"/compiler\", \"boilerplates\")\nc.touch(h + \"/compiler/boilerplates\", \"header.src\")\nc.touch(h + \"/compiler/boilerplates\", \"main.src\")\nc.touch(h + \"/compiler/boilerplates\", \"module.src\")\nprint(\"Create config file...\")\nc.touch(h + \"/Config\", \"compile.conf\")\nprint(\"Write config file...\")\nfile = c.File(h + \"/Config/compile.conf\")\nlines = []\nlines.push(\"COMMAND_START=#\")\nlines.push(\"SCRIPT_FOLDER=/home/$0/scripts\")\nlines.push(\"TEMP_FOLDER=/home/$0/tmp\")\nlines.push(\"COMPILER_FOLDER=/home/$0/compiler\")\nlines.push(\"BOILERPLATE_FOLDER=boilerplates/$0.src\")\nlines.push(\"BIN_FOLDER=/usr/bin\")\nlines.push(\"SCRIPT_EXTENSION=src\")\nlines.push(\"DEBUG=false\")\nlines.push(\"VERSION=0.1.0.0\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write compiler file...\")\nfile = c.File(h + \"/compiler/compile.src\")\nlines = []\nlines.push(\"BACKSLASH_CODE = 92\")\nlines.push(\"NEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"\"n\"\"\")\nlines.push(\"ARGV_OPERATOR = \"\"-\"\"\")\nlines.push(\"\")\nlines.push(\"Config = {}\")\nlines.push(\"\")\nlines.push(\"Config.load = function()\")\nlines.push(\"path = (new String).constructor(\"\"$0/Config/compile.conf\"\")\")\nlines.push(\"path = path.parse([home_dir]).toString()\")\nlines.push(\"file = get_shell.host_computer.File(path)\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"No config in $0...\"\", [path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"content = file.get_content\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"map = {}\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"def = line.split(\"\"=\"\")\")\nlines.push(\"name = def.pull()\")\nlines.push(\"value = def.pull()\")\nlines.push(\"map[name] = value\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.map = map\")\nlines.push(\"\")\nlines.push(\"return map\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.set = function(key, value)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\") and value != null) then\")\nlines.push(\"self.map[key] = value\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.get = function(key)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\")) then\")\nlines.push(\"return self.map[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getScriptFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"SCRIPT_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getTempFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"TEMP_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getCompilerFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"COMPILER_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getExtension = function()\")\nlines.push(\"return Config.get(\"\"SCRIPT_EXTENSION\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.isDebugMode = function()\")\nlines.push(\"value = Config.get(\"\"DEBUG\"\")\")\nlines.push(\"if (typeof(value) == \"\"string\"\") then\")\nlines.push(\"return value == \"\"true\"\"\")\nlines.push(\"end if\")\nlines.push(\"return value\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBoilerplateFile = function(boilerplate)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"BOILERPLATE_FOLDER\"\"))\")\nlines.push(\"return pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBinFolder = function()\")\nlines.push(\"return Config.get(\"\"BIN_FOLDER\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"debug = function(msg)\")\nlines.push(\"if (Config.isDebugMode()) then\")\nlines.push(\"print(msg)\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String = {}\")\nlines.push(\"\")\nlines.push(\"String.constructor = function(str)\")\nlines.push(\"self.str = str\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.parse = function(values)\")\nlines.push(\"result = self.str\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = values.len\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"result = result.replace(\"\"$\"\"+index, values[index])\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return (new String).constructor(result)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.startsWith = function(str)\")\nlines.push(\"return self.str.indexOf(str) == 0\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.substr = function(startIndex, endIndex)\")\nlines.push(\"return (new String).constructor(slice(self.str, startIndex, endIndex))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.indexOf = function(str)\")\nlines.push(\"return self.str.indexOf(str)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.replace = function(str, newStr)\")\nlines.push(\"return (new String).constructor(self.str.replace(str, newStr))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.remove = function(str)\")\nlines.push(\"return (new String).constructor(self.str.remove(str))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.toString = function()\")\nlines.push(\"return self.str\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.length = function()\")\nlines.push(\"return self.str.len\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.split = function(seperator)\")\nlines.push(\"return self.str.split(seperator)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.trim = function(seperator)\")\nlines.push(\"return (new String).constructor(self.str.trim())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error = {}\")\nlines.push(\"\")\nlines.push(\"Error.constructor = function(message, values)\")\nlines.push(\"self.message = message\")\nlines.push(\"if (values != null) then\")\nlines.push(\"self.message = (new String.constructor(message)).parse(values).toString()\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error.throw = function()\")\nlines.push(\"exit(\"\"<color=#ff0000>\"\" + self.message + \"\"</color>\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ArgType = {}\")\nlines.push(\"\")\nlines.push(\"ArgType.FLAG = \"\"FLAG\"\"\")\nlines.push(\"ArgType.VALUE = \"\"VALUE\"\"\")\nlines.push(\"\")\nlines.push(\"Arg = {}\")\nlines.push(\"\")\nlines.push(\"Arg.constructor = function(shortcut, command, type, description)\")\nlines.push(\"self.shortcut = shortcut\")\nlines.push(\"self.command = command\")\nlines.push(\"self.type = type\")\nlines.push(\"self.description = description\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Arg.toString = function()\")\nlines.push(\"str = (new String).constructor(\"\"-$0 --$1 - <b>$2</b>\"\")\")\nlines.push(\"return str.parse([self.shortcut, self.command, self.description]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv = {}\")\nlines.push(\"\")\nlines.push(\"Argv.constructor = function(defs, help)\")\nlines.push(\"self.args = params\")\nlines.push(\"self.listed = {}\")\nlines.push(\"self.unlisted = []\")\nlines.push(\"self.defs = defs\")\nlines.push(\"self.help = help\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.parse = function()\")\nlines.push(\"args = self.args\")\nlines.push(\"defs = self.defs\")\nlines.push(\"listed = {}\")\nlines.push(\"unlisted = []\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = args.len\")\nlines.push(\"findDef = function(arg)\")\nlines.push(\"for def in defs\")\nlines.push(\"if (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\")\nlines.push(\"return def\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"item = args[index].trim()\")\nlines.push(\"def = findDef(item)\")\nlines.push(\"if (def == null) then\")\nlines.push(\"unlisted.push(item)\")\nlines.push(\"else\")\nlines.push(\"if (def.type == ArgType.VALUE) then\")\nlines.push(\"index = index + 1\")\nlines.push(\"value = args[index]\")\nlines.push(\"listed[def.command] = value\")\nlines.push(\"else if (def.type == ArgType.FLAG) then\")\nlines.push(\"listed[def.command] = true\")\nlines.push(\"end if\")\nlines.push(\"end if\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"self.listed = listed\")\nlines.push(\"self.unlisted = unlisted\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.get = function(index = 0, mandatory = false)\")\nlines.push(\"if self.unlisted.hasIndex(index) then\")\nlines.push(\"return self.unlisted[index]\")\nlines.push(\"end if\")\nlines.push(\"if mandatory then\")\nlines.push(\"(new Error).constructor(\"\"Error cannot find param[$0]$1$2$3\"\", [index, NEW_LINE_OPERATOR, NEW_LINE_OPERATOR, self.help]).throw()\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.getWithKey = function(key)\")\nlines.push(\"if self.listed.hasIndex(key) then\")\nlines.push(\"return self.listed[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Math = {}\")\nlines.push(\"\")\nlines.push(\"Math.random = function(min, max)\")\nlines.push(\"return floor((rnd * max) + min)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator = {}\")\nlines.push(\"\")\nlines.push(\"IdGenerator.getChars = function()\")\nlines.push(\"return \"\"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\"\";\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator.get = function()\")\nlines.push(\"math = new Math\")\nlines.push(\"chars = self.getChars()\")\nlines.push(\"\")\nlines.push(\"result = []\")\nlines.push(\"indexA = 0\")\nlines.push(\"maxA = 4\")\nlines.push(\"\")\nlines.push(\"while indexA < maxA\")\nlines.push(\"indexB = 0\")\nlines.push(\"maxB = 5\")\nlines.push(\"code = \"\"\"\"\")\nlines.push(\"\")\nlines.push(\"while indexB < maxB\")\nlines.push(\"code = code + chars[math.random(0, chars.len - 1)]\")\nlines.push(\"\")\nlines.push(\"indexB = indexB + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"result.push(code)\")\nlines.push(\"\")\nlines.push(\"indexA = indexA + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return result.join(\"\"\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path = {}\")\nlines.push(\"\")\nlines.push(\"Path.resolve = function(a)\")\nlines.push(\"parts = a.split(\"\"/\"\")\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for part in parts\")\nlines.push(\"if (part == \"\"..\"\") then\")\nlines.push(\"result.pop()\")\nlines.push(\"else if (part != \"\"\"\" and part != \"\".\"\") then\")\nlines.push(\"result.push(part)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"resolved = result.join(\"\"/\"\")\")\nlines.push(\"\")\nlines.push(\"if (a.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"resolved = \"\"/\"\" + resolved\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return resolved\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path.join = function(a, b)\")\nlines.push(\"if (b.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"b = b[1:]\")\nlines.push(\"end if\")\nlines.push(\"return Path.resolve([a, b].join(\"\"/\"\"))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS = {}\")\nlines.push(\"\")\nlines.push(\"FS.constructor = function(computer)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS.createFile = function(path, name)\")\nlines.push(\"self.computer.touch(path, name)\")\nlines.push(\"return self.computer.File(Path.join(path, name))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand.constructor = function(file)\")\nlines.push(\"self.file = file\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTCommand.constructor = function(line, str, key, action)\")\nlines.push(\"self.line = line\")\nlines.push(\"self.str = str\")\nlines.push(\"self.key = key\")\nlines.push(\"self.action = action\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTRegistry = {}\")\nlines.push(\"\")\nlines.push(\"ASTRegistry.import = ASTImportCommand\")\nlines.push(\"\")\nlines.push(\"AST = {}\")\nlines.push(\"\")\nlines.push(\"AST.constructor = function(computer, file)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.file = file\")\nlines.push(\"self.lines = []\")\nlines.push(\"self.commands = []\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.analyze = function()\")\nlines.push(\"debug(\"\"Analyzing AST...\"\")\")\nlines.push(\"content = self.file.get_content\")\nlines.push(\"commands = []\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"index = 0\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"str = (new String).constructor(line)\")\nlines.push(\"\")\nlines.push(\"if (str.startsWith(Config.get(\"\"COMMAND_START\"\"))) then\")\nlines.push(\"command = str.substr(1, str.indexOf(\"\" \"\"))\")\nlines.push(\"key = command.toString()\")\nlines.push(\"\")\nlines.push(\"if (ASTRegistry[key] == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid command $0 on line $1\"\", [key, index]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"action = ASTRegistry[key]\")\nlines.push(\"entry = (new ASTCommand).constructor(index, str, key, new action)\")\nlines.push(\"commands.push(entry)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"index = index + 1\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.lines = lines\")\nlines.push(\"self.commands = commands\")\nlines.push(\"\")\nlines.push(\"return commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.transform = function(line, code)\")\nlines.push(\"self.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\")\nlines.push(\"\")\nlines.push(\"return self.lines\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.getCommands = function()\")\nlines.push(\"return self.commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency = {}\")\nlines.push(\"\")\nlines.push(\"Dependency.constructor = function(computer, file, ast)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = file\")\nlines.push(\"self.basePath = file.parent.path\")\nlines.push(\"self.ast = ast\")\nlines.push(\"self.dependencies = []\")\nlines.push(\"\")\nlines.push(\"if self.target == null then\")\nlines.push(\"(new Error).constructor(\"\"Dependency $0 does not exist...\"\", [file.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency.findDependencies = function()\")\nlines.push(\"debug(\"\"Finding dependencies...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"commands = self.ast.getCommands()\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"path = command.str.substr(command.str.indexOf(\"\"from\"\") + 4, command.str.indexOf(\"\";\"\")).toString()\")\nlines.push(\"\")\nlines.push(\"if (path == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid import on line $0 in $1...\"\", [command.line, self.target.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"filePath = pathHelper.join(self.basePath, path.trim() + \"\".\"\" + Config.getExtension())\")\nlines.push(\"file = self.computer.File(filePath)\")\nlines.push(\"debug(\"\"Looking for file in \"\" + filePath + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find $0...\"\", [filePath]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"command.action.constructor(file)\")\nlines.push(\"\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"\")\nlines.push(\"result.push(dependency)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.dependencies = result\")\nlines.push(\"\")\nlines.push(\"return result\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor = {}\")\nlines.push(\"\")\nlines.push(\"Preprocessor.constructor = function(computer, dependency)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.dependency = dependency\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor.run = function()\")\nlines.push(\"debug(\"\"Run preprocessor...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"mainDependency = self.dependency\")\nlines.push(\"mainModuleName = md5(mainDependency.target.path)\")\nlines.push(\"headerBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"header\"\")).get_content\")\nlines.push(\"moduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"module\"\")).get_content\")\nlines.push(\"mainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"main\"\")).get_content\")\nlines.push(\"modules = {}\")\nlines.push(\"iterator = function(item)\")\nlines.push(\"moduleName = md5(item.target.path)\")\nlines.push(\"\")\nlines.push(\"if (modules.hasIndex(moduleName)) then\")\nlines.push(\"return\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"commands = item.ast.getCommands()\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"importIndex = command.str.indexOf(\"\"import\"\")\")\nlines.push(\"fromIndex = command.str.indexOf(\"\"from\"\")\")\nlines.push(\"defVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\")\nlines.push(\"defId = md5(command.action.file.path)\")\nlines.push(\"code = (new String).constructor(\"\"$0 = __REQUIRE(\"\"\"\"$1\"\"\"\")\"\").parse([defVar, defId])\")\nlines.push(\"\")\nlines.push(\"item.ast.transform(command.line, code.toString())\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"if (moduleName != mainModuleName) then\")\nlines.push(\"transformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(moduleBoilerplate)\")\nlines.push(\"modules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for dependency in item.dependencies\")\nlines.push(\"iterator(dependency)\")\nlines.push(\"end for\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"iterator(mainDependency)\")\nlines.push(\"\")\nlines.push(\"processed = headerBoilerplate\")\nlines.push(\"\")\nlines.push(\"for module in modules.values\")\nlines.push(\"processed = processed + module\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"transformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(mainBoilerplate)\")\nlines.push(\"processed = processed + moduleCode.parse([transformedCode]).toString()\")\nlines.push(\"\")\nlines.push(\"return processed\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler = {}\")\nlines.push(\"\")\nlines.push(\"Compiler.constructor = function(computer, name)\")\nlines.push(\"idGenerator = new IdGenerator\")\nlines.push(\"\")\nlines.push(\"self.buildId = idGenerator.get()\")\nlines.push(\"self.name = name\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = computer.File(self.getFullScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.isTargetExisting = function()\")\nlines.push(\"return self.target != null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getScriptFilePath = function()\")\nlines.push(\"return self.name + \"\".\"\" + Config.getExtension()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullScriptFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getScriptFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullTempFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getTempFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.preprocess = function()\")\nlines.push(\"debug(\"\"Start processing...\"\")\")\nlines.push(\"file = self.computer.File(self.getFullScriptFilePath())\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"preprocessor = (new Preprocessor).constructor(self.computer, dependency)\")\nlines.push(\"return preprocessor.run()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.compile = function(shell)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"fs = (new FS).constructor(self.computer)\")\nlines.push(\"buildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\")\nlines.push(\"buildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"self.computer.create_folder(Config.getTempFolder(), self.buildId)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Build id: \"\" + self.buildId)\")\nlines.push(\"\")\nlines.push(\"newFile = fs.createFile(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"if newFile == null then\")\nlines.push(\"exit(\"\"Unable to create file...\"\")\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = self.preprocess()\")\nlines.push(\"\")\nlines.push(\"newFile.set_content(content)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Building in \"\" + Config.getBinFolder() + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"buildReport = shell.build(buildPathFull, Config.getBinFolder())\")\nlines.push(\"\")\nlines.push(\"compiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\")\nlines.push(\"if self.computer.File(compiledBuildPathFull) == null then\")\nlines.push(\"(new Error).constructor(\"\"Built failed: $0\"\", [buildReport]).throw()\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"main = function(name)\")\nlines.push(\"myShell = get_shell\")\nlines.push(\"myComputer = myShell.host_computer\")\nlines.push(\"\")\nlines.push(\"compiler = (new Compiler).constructor(myComputer, name)\")\nlines.push(\"\")\nlines.push(\"if compiler.isTargetExisting == false then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find file.\"\").throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = compiler.compile(myShell)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.load()\")\nlines.push(\"\")\nlines.push(\"argDefinitions = []\")\nlines.push(\"\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"h\"\", \"\"help\"\", ArgType.FLAG, \"\"Print help\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"d\"\", \"\"debug\"\", ArgType.FLAG, \"\"Activate debug mode\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"cs\"\", \"\"command-start\"\", ArgType.VALUE, \"\"Command starting operator\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"s\"\", \"\"script-folder\"\", ArgType.VALUE, \"\"Script folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"t\"\", \"\"temp-folder\"\", ArgType.VALUE, \"\"Temporary folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"c\"\", \"\"compiler-folder\"\", ArgType.VALUE, \"\"Compiler folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"b\"\", \"\"bin-folder\"\", ArgType.VALUE, \"\"Bin folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"se\"\", \"\"script-extension\"\", ArgType.VALUE, \"\"Script extension\"\"))\")\nlines.push(\"\")\nlines.push(\"helpBlock = []\")\nlines.push(\"\")\nlines.push(\"helpBlock.push(\"\"Compiler CLI\"\")\")\nlines.push(\"helpBlock.push(\"\"Version: \"\" + Config.get(\"\"VERSION\"\"))\")\nlines.push(\"helpBlock.push(\"\"Example: <b>compile myscriptfile</b>\"\")\")\nlines.push(\"helpBlock.push(\"\"\"\")\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"helpBlock.push(argDefinition.toString())\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"help = helpBlock.join(NEW_LINE_OPERATOR)\")\nlines.push(\"\")\nlines.push(\"argv = (new Argv).constructor(argDefinitions, help)\")\nlines.push(\"\")\nlines.push(\"argv.parse()\")\nlines.push(\"\")\nlines.push(\"if (argv.getWithKey(\"\"help\"\") == true) then\")\nlines.push(\"exit(help)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"key = argDefinition.command.upper.replace(\"\"-\"\", \"\"_\"\")\")\nlines.push(\"value = argv.getWithKey(argDefinition.command)\")\nlines.push(\"Config.set(key, value)\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"debug(\"\"Start compiling...\"\")\")\nlines.push(\"main(argv.get(0, true))\")\nlines.push(\"exit(\"\"Done compiling...\"\")\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates header file...\")\nfile = c.File(h + \"/compiler/boilerplate/header.src\")\nlines = []\nlines.push(\"BACK_SLASH_CHAR = \"\"\"\"\")\nlines.push(\"NEW_LINE_OPERATOR = BACK_SLASH_CHAR + \"\"n\"\"\")\nlines.push(\"MODULES = {}\")\nlines.push(\"EXPORTED = {}\")\nlines.push(\"\")\nlines.push(\"__REQUIRE = function(r)\")\nlines.push(\"if (MODULES.hasIndex(r) == false) then\")\nlines.push(\"exit(\"\"Module \"\" + r + \"\" cannot be found...\"\")\")\nlines.push(\"end if\")\nlines.push(\"module = MODULES[r]\")\nlines.push(\"return module(r)\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates module file...\")\nfile = c.File(h + \"/compiler/boilerplate/module.src\")\nlines = []\nlines.push(\"MODULES[\"\"$0\"\"] = function(r)\")\nlines.push(\"module = {}\")\nlines.push(\"\")\nlines.push(\"if (EXPORTED.hasIndex(r)) then\")\nlines.push(\"module = EXPORTED[r]\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"if (module.hasIndex(\"\"exports\"\") == false) then\")\nlines.push(\"$1\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"EXPORTED[r] = module\")\nlines.push(\"\")\nlines.push(\"return module.exports\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates main file...\")\nfile = c.File(h + \"/compiler/boilerplate/main.src\")\nlines = []\nlines.push(\"MAIN = function()\")\nlines.push(\"$0\")\nlines.push(\"end function\")\nlines.push(\"MAIN()\")\nfile.set_content(lines.join(\"\\n\"))\n\n",
        "ID": "d67e069a780f4857204330aa49b3d795",
        "refCount": 1
    },
    {
        "Content": "s = get_shell\nc = s.host_computer\nh = home_dir\nprint(\"Create compiler folder...\")\nc.create_folder(h, \"compiler\")\nc.create_folder(h, \"tmp\")\nc.touch(h + \"/compiler\", \"compile.src\")\nc.create_folder(h + \"/compiler\", \"boilerplates\")\nc.touch(h + \"/compiler/boilerplates\", \"header.src\")\nc.touch(h + \"/compiler/boilerplates\", \"main.src\")\nc.touch(h + \"/compiler/boilerplates\", \"module.src\")\nprint(\"Create config file...\")\nc.touch(h + \"/Config\", \"compile.conf\")\nprint(\"Write config file...\")\nfile = c.File(h + \"/Config/compile.conf\")\nlines = []\nlines.push(\"COMMAND_START=#\")\nlines.push(\"SCRIPT_FOLDER=/home/$0/scripts\")\nlines.push(\"TEMP_FOLDER=/home/$0/tmp\")\nlines.push(\"COMPILER_FOLDER=/home/$0/compiler\")\nlines.push(\"BOILERPLATE_FOLDER=boilerplates/$0.src\")\nlines.push(\"BIN_FOLDER=/usr/bin\")\nlines.push(\"SCRIPT_EXTENSION=src\")\nlines.push(\"DEBUG=false\")\nlines.push(\"VERSION=0.1.0.0\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write compiler file...\")\nfile = c.File(h + \"/compiler/compile.src\")\nlines = []\nlines.push(\"BACKSLASH_CODE = 92\")\nlines.push(\"NEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"\"n\"\"\")\nlines.push(\"ARGV_OPERATOR = \"\"-\"\"\")\nlines.push(\"\")\nlines.push(\"Config = {}\")\nlines.push(\"\")\nlines.push(\"Config.load = function()\")\nlines.push(\"path = (new String).constructor(\"\"$0/Config/compile.conf\"\")\")\nlines.push(\"path = path.parse([home_dir]).toString()\")\nlines.push(\"file = get_shell.host_computer.File(path)\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"No config in $0...\"\", [path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"content = file.get_content\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"map = {}\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"def = line.split(\"\"=\"\")\")\nlines.push(\"name = def.pull()\")\nlines.push(\"value = def.pull()\")\nlines.push(\"map[name] = value\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.map = map\")\nlines.push(\"\")\nlines.push(\"return map\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.set = function(key, value)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\") and value != null) then\")\nlines.push(\"self.map[key] = value\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.get = function(key)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\")) then\")\nlines.push(\"return self.map[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getScriptFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"SCRIPT_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getTempFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"TEMP_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getCompilerFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"COMPILER_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getExtension = function()\")\nlines.push(\"return Config.get(\"\"SCRIPT_EXTENSION\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.isDebugMode = function()\")\nlines.push(\"value = Config.get(\"\"DEBUG\"\")\")\nlines.push(\"if (typeof(value) == \"\"string\"\") then\")\nlines.push(\"return value == \"\"true\"\"\")\nlines.push(\"end if\")\nlines.push(\"return value\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBoilerplateFile = function(boilerplate)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"BOILERPLATE_FOLDER\"\"))\")\nlines.push(\"return pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBinFolder = function()\")\nlines.push(\"return Config.get(\"\"BIN_FOLDER\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"debug = function(msg)\")\nlines.push(\"if (Config.isDebugMode()) then\")\nlines.push(\"print(msg)\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String = {}\")\nlines.push(\"\")\nlines.push(\"String.constructor = function(str)\")\nlines.push(\"self.str = str\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.parse = function(values)\")\nlines.push(\"result = self.str\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = values.len\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"result = result.replace(\"\"$\"\"+index, values[index])\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return (new String).constructor(result)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.startsWith = function(str)\")\nlines.push(\"return self.str.indexOf(str) == 0\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.substr = function(startIndex, endIndex)\")\nlines.push(\"return (new String).constructor(slice(self.str, startIndex, endIndex))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.indexOf = function(str)\")\nlines.push(\"return self.str.indexOf(str)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.replace = function(str, newStr)\")\nlines.push(\"return (new String).constructor(self.str.replace(str, newStr))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.remove = function(str)\")\nlines.push(\"return (new String).constructor(self.str.remove(str))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.toString = function()\")\nlines.push(\"return self.str\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.length = function()\")\nlines.push(\"return self.str.len\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.split = function(seperator)\")\nlines.push(\"return self.str.split(seperator)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.trim = function(seperator)\")\nlines.push(\"return (new String).constructor(self.str.trim())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error = {}\")\nlines.push(\"\")\nlines.push(\"Error.constructor = function(message, values)\")\nlines.push(\"self.message = message\")\nlines.push(\"if (values != null) then\")\nlines.push(\"self.message = (new String.constructor(message)).parse(values).toString()\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error.throw = function()\")\nlines.push(\"exit(\"\"<color=#ff0000>\"\" + self.message + \"\"</color>\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ArgType = {}\")\nlines.push(\"\")\nlines.push(\"ArgType.FLAG = \"\"FLAG\"\"\")\nlines.push(\"ArgType.VALUE = \"\"VALUE\"\"\")\nlines.push(\"\")\nlines.push(\"Arg = {}\")\nlines.push(\"\")\nlines.push(\"Arg.constructor = function(shortcut, command, type, description)\")\nlines.push(\"self.shortcut = shortcut\")\nlines.push(\"self.command = command\")\nlines.push(\"self.type = type\")\nlines.push(\"self.description = description\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Arg.toString = function()\")\nlines.push(\"str = (new String).constructor(\"\"-$0 --$1 - <b>$2</b>\"\")\")\nlines.push(\"return str.parse([self.shortcut, self.command, self.description]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv = {}\")\nlines.push(\"\")\nlines.push(\"Argv.constructor = function(defs, help)\")\nlines.push(\"self.args = params\")\nlines.push(\"self.listed = {}\")\nlines.push(\"self.unlisted = []\")\nlines.push(\"self.defs = defs\")\nlines.push(\"self.help = help\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.parse = function()\")\nlines.push(\"args = self.args\")\nlines.push(\"defs = self.defs\")\nlines.push(\"listed = {}\")\nlines.push(\"unlisted = []\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = args.len\")\nlines.push(\"findDef = function(arg)\")\nlines.push(\"for def in defs\")\nlines.push(\"if (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\")\nlines.push(\"return def\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"item = args[index].trim()\")\nlines.push(\"def = findDef(item)\")\nlines.push(\"if (def == null) then\")\nlines.push(\"unlisted.push(item)\")\nlines.push(\"else\")\nlines.push(\"if (def.type == ArgType.VALUE) then\")\nlines.push(\"index = index + 1\")\nlines.push(\"value = args[index]\")\nlines.push(\"listed[def.command] = value\")\nlines.push(\"else if (def.type == ArgType.FLAG) then\")\nlines.push(\"listed[def.command] = true\")\nlines.push(\"end if\")\nlines.push(\"end if\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"self.listed = listed\")\nlines.push(\"self.unlisted = unlisted\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.get = function(index = 0, mandatory = false)\")\nlines.push(\"if self.unlisted.hasIndex(index) then\")\nlines.push(\"return self.unlisted[index]\")\nlines.push(\"end if\")\nlines.push(\"if mandatory then\")\nlines.push(\"(new Error).constructor(\"\"Error cannot find param[$0]$1$2$3\"\", [index, NEW_LINE_OPERATOR, NEW_LINE_OPERATOR, self.help]).throw()\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.getWithKey = function(key)\")\nlines.push(\"if self.listed.hasIndex(key) then\")\nlines.push(\"return self.listed[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Math = {}\")\nlines.push(\"\")\nlines.push(\"Math.random = function(min, max)\")\nlines.push(\"return floor((rnd * max) + min)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator = {}\")\nlines.push(\"\")\nlines.push(\"IdGenerator.getChars = function()\")\nlines.push(\"return \"\"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\"\";\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator.get = function()\")\nlines.push(\"math = new Math\")\nlines.push(\"chars = self.getChars()\")\nlines.push(\"\")\nlines.push(\"result = []\")\nlines.push(\"indexA = 0\")\nlines.push(\"maxA = 4\")\nlines.push(\"\")\nlines.push(\"while indexA < maxA\")\nlines.push(\"indexB = 0\")\nlines.push(\"maxB = 5\")\nlines.push(\"code = \"\"\"\"\")\nlines.push(\"\")\nlines.push(\"while indexB < maxB\")\nlines.push(\"code = code + chars[math.random(0, chars.len - 1)]\")\nlines.push(\"\")\nlines.push(\"indexB = indexB + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"result.push(code)\")\nlines.push(\"\")\nlines.push(\"indexA = indexA + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return result.join(\"\"\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path = {}\")\nlines.push(\"\")\nlines.push(\"Path.resolve = function(a)\")\nlines.push(\"parts = a.split(\"\"/\"\")\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for part in parts\")\nlines.push(\"if (part == \"\"..\"\") then\")\nlines.push(\"result.pop()\")\nlines.push(\"else if (part != \"\"\"\" and part != \"\".\"\") then\")\nlines.push(\"result.push(part)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"resolved = result.join(\"\"/\"\")\")\nlines.push(\"\")\nlines.push(\"if (a.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"resolved = \"\"/\"\" + resolved\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return resolved\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path.join = function(a, b)\")\nlines.push(\"if (b.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"b = b[1:]\")\nlines.push(\"end if\")\nlines.push(\"return Path.resolve([a, b].join(\"\"/\"\"))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS = {}\")\nlines.push(\"\")\nlines.push(\"FS.constructor = function(computer)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS.createFile = function(path, name)\")\nlines.push(\"self.computer.touch(path, name)\")\nlines.push(\"return self.computer.File(Path.join(path, name))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand.constructor = function(file)\")\nlines.push(\"self.file = file\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTCommand.constructor = function(line, str, key, action)\")\nlines.push(\"self.line = line\")\nlines.push(\"self.str = str\")\nlines.push(\"self.key = key\")\nlines.push(\"self.action = action\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTRegistry = {}\")\nlines.push(\"\")\nlines.push(\"ASTRegistry.import = ASTImportCommand\")\nlines.push(\"\")\nlines.push(\"AST = {}\")\nlines.push(\"\")\nlines.push(\"AST.constructor = function(computer, file)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.file = file\")\nlines.push(\"self.lines = []\")\nlines.push(\"self.commands = []\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.analyze = function()\")\nlines.push(\"debug(\"\"Analyzing AST...\"\")\")\nlines.push(\"content = self.file.get_content\")\nlines.push(\"commands = []\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"index = 0\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"str = (new String).constructor(line)\")\nlines.push(\"\")\nlines.push(\"if (str.startsWith(Config.get(\"\"COMMAND_START\"\"))) then\")\nlines.push(\"command = str.substr(1, str.indexOf(\"\" \"\"))\")\nlines.push(\"key = command.toString()\")\nlines.push(\"\")\nlines.push(\"if (ASTRegistry[key] == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid command $0 on line $1\"\", [key, index]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"action = ASTRegistry[key]\")\nlines.push(\"entry = (new ASTCommand).constructor(index, str, key, new action)\")\nlines.push(\"commands.push(entry)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"index = index + 1\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.lines = lines\")\nlines.push(\"self.commands = commands\")\nlines.push(\"\")\nlines.push(\"return commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.transform = function(line, code)\")\nlines.push(\"self.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\")\nlines.push(\"\")\nlines.push(\"return self.lines\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.getCommands = function()\")\nlines.push(\"return self.commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency = {}\")\nlines.push(\"\")\nlines.push(\"Dependency.constructor = function(computer, file, ast)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = file\")\nlines.push(\"self.basePath = file.parent.path\")\nlines.push(\"self.ast = ast\")\nlines.push(\"self.dependencies = []\")\nlines.push(\"\")\nlines.push(\"if self.target == null then\")\nlines.push(\"(new Error).constructor(\"\"Dependency $0 does not exist...\"\", [file.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency.findDependencies = function()\")\nlines.push(\"debug(\"\"Finding dependencies...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"commands = self.ast.getCommands()\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"path = command.str.substr(command.str.indexOf(\"\"from\"\") + 4, command.str.indexOf(\"\";\"\")).toString()\")\nlines.push(\"\")\nlines.push(\"if (path == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid import on line $0 in $1...\"\", [command.line, self.target.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"filePath = pathHelper.join(self.basePath, path.trim() + \"\".\"\" + Config.getExtension())\")\nlines.push(\"file = self.computer.File(filePath)\")\nlines.push(\"debug(\"\"Looking for file in \"\" + filePath + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find $0...\"\", [filePath]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"command.action.constructor(file)\")\nlines.push(\"\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"\")\nlines.push(\"result.push(dependency)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.dependencies = result\")\nlines.push(\"\")\nlines.push(\"return result\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor = {}\")\nlines.push(\"\")\nlines.push(\"Preprocessor.constructor = function(computer, dependency)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.dependency = dependency\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor.run = function()\")\nlines.push(\"debug(\"\"Run preprocessor...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"mainDependency = self.dependency\")\nlines.push(\"mainModuleName = md5(mainDependency.target.path)\")\nlines.push(\"headerBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"header\"\")).get_content\")\nlines.push(\"moduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"module\"\")).get_content\")\nlines.push(\"mainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"main\"\")).get_content\")\nlines.push(\"modules = {}\")\nlines.push(\"iterator = function(item)\")\nlines.push(\"moduleName = md5(item.target.path)\")\nlines.push(\"\")\nlines.push(\"if (modules.hasIndex(moduleName)) then\")\nlines.push(\"return\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"commands = item.ast.getCommands()\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"importIndex = command.str.indexOf(\"\"import\"\")\")\nlines.push(\"fromIndex = command.str.indexOf(\"\"from\"\")\")\nlines.push(\"defVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\")\nlines.push(\"defId = md5(command.action.file.path)\")\nlines.push(\"code = (new String).constructor(\"\"$0 = __REQUIRE(\"\"\"\"$1\"\"\"\")\"\").parse([defVar, defId])\")\nlines.push(\"\")\nlines.push(\"item.ast.transform(command.line, code.toString())\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"if (moduleName != mainModuleName) then\")\nlines.push(\"transformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(moduleBoilerplate)\")\nlines.push(\"modules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for dependency in item.dependencies\")\nlines.push(\"iterator(dependency)\")\nlines.push(\"end for\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"iterator(mainDependency)\")\nlines.push(\"\")\nlines.push(\"processed = headerBoilerplate\")\nlines.push(\"\")\nlines.push(\"for module in modules.values\")\nlines.push(\"processed = processed + module\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"transformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(mainBoilerplate)\")\nlines.push(\"processed = processed + moduleCode.parse([transformedCode]).toString()\")\nlines.push(\"\")\nlines.push(\"return processed\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler = {}\")\nlines.push(\"\")\nlines.push(\"Compiler.constructor = function(computer, name)\")\nlines.push(\"idGenerator = new IdGenerator\")\nlines.push(\"\")\nlines.push(\"self.buildId = idGenerator.get()\")\nlines.push(\"self.name = name\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = computer.File(self.getFullScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.isTargetExisting = function()\")\nlines.push(\"return self.target != null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getScriptFilePath = function()\")\nlines.push(\"return self.name + \"\".\"\" + Config.getExtension()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullScriptFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getScriptFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullTempFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getTempFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.preprocess = function()\")\nlines.push(\"debug(\"\"Start processing...\"\")\")\nlines.push(\"file = self.computer.File(self.getFullScriptFilePath())\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"preprocessor = (new Preprocessor).constructor(self.computer, dependency)\")\nlines.push(\"return preprocessor.run()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.compile = function(shell)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"fs = (new FS).constructor(self.computer)\")\nlines.push(\"buildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\")\nlines.push(\"buildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"self.computer.create_folder(Config.getTempFolder(), self.buildId)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Build id: \"\" + self.buildId)\")\nlines.push(\"\")\nlines.push(\"newFile = fs.createFile(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"if newFile == null then\")\nlines.push(\"exit(\"\"Unable to create file...\"\")\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = self.preprocess()\")\nlines.push(\"\")\nlines.push(\"newFile.set_content(content)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Building in \"\" + Config.getBinFolder() + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"buildReport = shell.build(buildPathFull, Config.getBinFolder())\")\nlines.push(\"\")\nlines.push(\"compiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\")\nlines.push(\"if self.computer.File(compiledBuildPathFull) == null then\")\nlines.push(\"(new Error).constructor(\"\"Built failed: $0\"\", [buildReport]).throw()\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"main = function(name)\")\nlines.push(\"myShell = get_shell\")\nlines.push(\"myComputer = myShell.host_computer\")\nlines.push(\"\")\nlines.push(\"compiler = (new Compiler).constructor(myComputer, name)\")\nlines.push(\"\")\nlines.push(\"if compiler.isTargetExisting == false then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find file.\"\").throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = compiler.compile(myShell)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.load()\")\nlines.push(\"\")\nlines.push(\"argDefinitions = []\")\nlines.push(\"\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"h\"\", \"\"help\"\", ArgType.FLAG, \"\"Print help\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"d\"\", \"\"debug\"\", ArgType.FLAG, \"\"Activate debug mode\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"cs\"\", \"\"command-start\"\", ArgType.VALUE, \"\"Command starting operator\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"s\"\", \"\"script-folder\"\", ArgType.VALUE, \"\"Script folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"t\"\", \"\"temp-folder\"\", ArgType.VALUE, \"\"Temporary folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"c\"\", \"\"compiler-folder\"\", ArgType.VALUE, \"\"Compiler folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"b\"\", \"\"bin-folder\"\", ArgType.VALUE, \"\"Bin folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"se\"\", \"\"script-extension\"\", ArgType.VALUE, \"\"Script extension\"\"))\")\nlines.push(\"\")\nlines.push(\"helpBlock = []\")\nlines.push(\"\")\nlines.push(\"helpBlock.push(\"\"Compiler CLI\"\")\")\nlines.push(\"helpBlock.push(\"\"Version: \"\" + Config.get(\"\"VERSION\"\"))\")\nlines.push(\"helpBlock.push(\"\"Example: <b>compile myscriptfile</b>\"\")\")\nlines.push(\"helpBlock.push(\"\"\"\")\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"helpBlock.push(argDefinition.toString())\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"help = helpBlock.join(NEW_LINE_OPERATOR)\")\nlines.push(\"\")\nlines.push(\"argv = (new Argv).constructor(argDefinitions, help)\")\nlines.push(\"\")\nlines.push(\"argv.parse()\")\nlines.push(\"\")\nlines.push(\"if (argv.getWithKey(\"\"help\"\") == true) then\")\nlines.push(\"exit(help)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"key = argDefinition.command.upper.replace(\"\"-\"\", \"\"_\"\")\")\nlines.push(\"value = argv.getWithKey(argDefinition.command)\")\nlines.push(\"Config.set(key, value)\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"debug(\"\"Start compiling...\"\")\")\nlines.push(\"main(argv.get(0, true))\")\nlines.push(\"exit(\"\"Done compiling...\"\")\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates header file...\")\nfile = c.File(h + \"/compiler/boilerplates/header.src\")\nlines = []\nlines.push(\"BACK_SLASH_CHAR = \"\"\"\"\")\nlines.push(\"NEW_LINE_OPERATOR = BACK_SLASH_CHAR + \"\"n\"\"\")\nlines.push(\"MODULES = {}\")\nlines.push(\"EXPORTED = {}\")\nlines.push(\"\")\nlines.push(\"__REQUIRE = function(r)\")\nlines.push(\"if (MODULES.hasIndex(r) == false) then\")\nlines.push(\"exit(\"\"Module \"\" + r + \"\" cannot be found...\"\")\")\nlines.push(\"end if\")\nlines.push(\"module = MODULES[r]\")\nlines.push(\"return module(r)\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates module file...\")\nfile = c.File(h + \"/compiler/boilerplates/module.src\")\nlines = []\nlines.push(\"MODULES[\"\"$0\"\"] = function(r)\")\nlines.push(\"module = {}\")\nlines.push(\"\")\nlines.push(\"if (EXPORTED.hasIndex(r)) then\")\nlines.push(\"module = EXPORTED[r]\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"if (module.hasIndex(\"\"exports\"\") == false) then\")\nlines.push(\"$1\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"EXPORTED[r] = module\")\nlines.push(\"\")\nlines.push(\"return module.exports\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates main file...\")\nfile = c.File(h + \"/compiler/boilerplates/main.src\")\nlines = []\nlines.push(\"MAIN = function()\")\nlines.push(\"$0\")\nlines.push(\"end function\")\nlines.push(\"MAIN()\")\nfile.set_content(lines.join(\"\\n\"))\n\n",
        "ID": "29bb4f009bd5444cb42f8c28e4d7f59c",
        "refCount": 1
    },
    {
        "Content": "MAIN = function()\n$0\nend function\nMAIN()",
        "ID": "09f926b9cf97c6654d0ccc255fabf6af",
        "refCount": 1
    },
    {
        "Content": "s = get_shell\nc = s.host_computer\nh = home_dir\nprint(\"Create compiler folder...\")\nc.create_folder(h, \"compiler\")\nc.create_folder(h, \"tmp\")\nc.touch(h + \"/compiler\", \"compile.src\")\nc.create_folder(h + \"/compiler\", \"boilerplates\")\nc.touch(h + \"/compiler/boilerplates\", \"header.src\")\nc.touch(h + \"/compiler/boilerplates\", \"main.src\")\nc.touch(h + \"/compiler/boilerplates\", \"module.src\")\nprint(\"Create config file...\")\nc.touch(h + \"/Config\", \"compile.conf\")\nprint(\"Write config file...\")\nfile = c.File(h + \"/Config/compile.conf\")\nlines = []\nlines.push(\"COMMAND_START=#\")\nlines.push(\"SCRIPT_FOLDER=/home/$0/scripts\")\nlines.push(\"TEMP_FOLDER=/home/$0/tmp\")\nlines.push(\"COMPILER_FOLDER=/home/$0/compiler\")\nlines.push(\"BOILERPLATE_FOLDER=boilerplates/$0.src\")\nlines.push(\"BIN_FOLDER=/usr/bin\")\nlines.push(\"SCRIPT_EXTENSION=src\")\nlines.push(\"DEBUG=false\")\nlines.push(\"VERSION=0.1.0.0\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write compiler file...\")\nfile = c.File(h + \"/compiler/compile.src\")\nlines = []\nlines.push(\"BACKSLASH_CODE = 92\")\nlines.push(\"NEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"\"n\"\"\")\nlines.push(\"ARGV_OPERATOR = \"\"-\"\"\")\nlines.push(\"\")\nlines.push(\"Config = {}\")\nlines.push(\"\")\nlines.push(\"Config.load = function()\")\nlines.push(\"path = (new String).constructor(\"\"$0/Config/compile.conf\"\")\")\nlines.push(\"path = path.parse([home_dir]).toString()\")\nlines.push(\"file = get_shell.host_computer.File(path)\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"No config in $0...\"\", [path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"content = file.get_content\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"map = {}\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"def = line.split(\"\"=\"\")\")\nlines.push(\"name = def.pull()\")\nlines.push(\"value = def.pull()\")\nlines.push(\"map[name] = value\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.map = map\")\nlines.push(\"\")\nlines.push(\"return map\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.set = function(key, value)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\") and value != null) then\")\nlines.push(\"self.map[key] = value\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.get = function(key)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\")) then\")\nlines.push(\"return self.map[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getScriptFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"SCRIPT_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getTempFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"TEMP_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getCompilerFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"COMPILER_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getExtension = function()\")\nlines.push(\"return Config.get(\"\"SCRIPT_EXTENSION\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.isDebugMode = function()\")\nlines.push(\"value = Config.get(\"\"DEBUG\"\")\")\nlines.push(\"if (typeof(value) == \"\"string\"\") then\")\nlines.push(\"return value == \"\"true\"\"\")\nlines.push(\"end if\")\nlines.push(\"return value\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBoilerplateFile = function(boilerplate)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"BOILERPLATE_FOLDER\"\"))\")\nlines.push(\"return pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBinFolder = function()\")\nlines.push(\"return Config.get(\"\"BIN_FOLDER\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"debug = function(msg)\")\nlines.push(\"if (Config.isDebugMode()) then\")\nlines.push(\"print(msg)\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String = {}\")\nlines.push(\"\")\nlines.push(\"String.constructor = function(str)\")\nlines.push(\"self.str = str\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.parse = function(values)\")\nlines.push(\"result = self.str\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = values.len\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"result = result.replace(\"\"$\"\"+index, values[index])\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return (new String).constructor(result)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.startsWith = function(str)\")\nlines.push(\"return self.str.indexOf(str) == 0\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.substr = function(startIndex, endIndex)\")\nlines.push(\"return (new String).constructor(slice(self.str, startIndex, endIndex))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.indexOf = function(str)\")\nlines.push(\"return self.str.indexOf(str)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.replace = function(str, newStr)\")\nlines.push(\"return (new String).constructor(self.str.replace(str, newStr))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.remove = function(str)\")\nlines.push(\"return (new String).constructor(self.str.remove(str))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.toString = function()\")\nlines.push(\"return self.str\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.length = function()\")\nlines.push(\"return self.str.len\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.split = function(seperator)\")\nlines.push(\"return self.str.split(seperator)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.trim = function(seperator)\")\nlines.push(\"return (new String).constructor(self.str.trim())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error = {}\")\nlines.push(\"\")\nlines.push(\"Error.constructor = function(message, values)\")\nlines.push(\"self.message = message\")\nlines.push(\"if (values != null) then\")\nlines.push(\"self.message = (new String.constructor(message)).parse(values).toString()\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error.throw = function()\")\nlines.push(\"exit(\"\"<color=#ff0000>\"\" + self.message + \"\"</color>\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ArgType = {}\")\nlines.push(\"\")\nlines.push(\"ArgType.FLAG = \"\"FLAG\"\"\")\nlines.push(\"ArgType.VALUE = \"\"VALUE\"\"\")\nlines.push(\"\")\nlines.push(\"Arg = {}\")\nlines.push(\"\")\nlines.push(\"Arg.constructor = function(shortcut, command, type, description)\")\nlines.push(\"self.shortcut = shortcut\")\nlines.push(\"self.command = command\")\nlines.push(\"self.type = type\")\nlines.push(\"self.description = description\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Arg.toString = function()\")\nlines.push(\"str = (new String).constructor(\"\"-$0 --$1 - <b>$2</b>\"\")\")\nlines.push(\"return str.parse([self.shortcut, self.command, self.description]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv = {}\")\nlines.push(\"\")\nlines.push(\"Argv.constructor = function(defs, help)\")\nlines.push(\"self.args = params\")\nlines.push(\"self.listed = {}\")\nlines.push(\"self.unlisted = []\")\nlines.push(\"self.defs = defs\")\nlines.push(\"self.help = help\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.parse = function()\")\nlines.push(\"args = self.args\")\nlines.push(\"defs = self.defs\")\nlines.push(\"listed = {}\")\nlines.push(\"unlisted = []\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = args.len\")\nlines.push(\"findDef = function(arg)\")\nlines.push(\"for def in defs\")\nlines.push(\"if (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\")\nlines.push(\"return def\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"item = args[index].trim()\")\nlines.push(\"def = findDef(item)\")\nlines.push(\"if (def == null) then\")\nlines.push(\"unlisted.push(item)\")\nlines.push(\"else\")\nlines.push(\"if (def.type == ArgType.VALUE) then\")\nlines.push(\"index = index + 1\")\nlines.push(\"value = args[index]\")\nlines.push(\"listed[def.command] = value\")\nlines.push(\"else if (def.type == ArgType.FLAG) then\")\nlines.push(\"listed[def.command] = true\")\nlines.push(\"end if\")\nlines.push(\"end if\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"self.listed = listed\")\nlines.push(\"self.unlisted = unlisted\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.get = function(index = 0, mandatory = false)\")\nlines.push(\"if self.unlisted.hasIndex(index) then\")\nlines.push(\"return self.unlisted[index]\")\nlines.push(\"end if\")\nlines.push(\"if mandatory then\")\nlines.push(\"(new Error).constructor(\"\"Error cannot find param[$0]$1$2$3\"\", [index, NEW_LINE_OPERATOR, NEW_LINE_OPERATOR, self.help]).throw()\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.getWithKey = function(key)\")\nlines.push(\"if self.listed.hasIndex(key) then\")\nlines.push(\"return self.listed[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Math = {}\")\nlines.push(\"\")\nlines.push(\"Math.random = function(min, max)\")\nlines.push(\"return floor((rnd * max) + min)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator = {}\")\nlines.push(\"\")\nlines.push(\"IdGenerator.getChars = function()\")\nlines.push(\"return \"\"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\"\";\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator.get = function()\")\nlines.push(\"math = new Math\")\nlines.push(\"chars = self.getChars()\")\nlines.push(\"\")\nlines.push(\"result = []\")\nlines.push(\"indexA = 0\")\nlines.push(\"maxA = 4\")\nlines.push(\"\")\nlines.push(\"while indexA < maxA\")\nlines.push(\"indexB = 0\")\nlines.push(\"maxB = 5\")\nlines.push(\"code = \"\"\"\"\")\nlines.push(\"\")\nlines.push(\"while indexB < maxB\")\nlines.push(\"code = code + chars[math.random(0, chars.len - 1)]\")\nlines.push(\"\")\nlines.push(\"indexB = indexB + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"result.push(code)\")\nlines.push(\"\")\nlines.push(\"indexA = indexA + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return result.join(\"\"\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path = {}\")\nlines.push(\"\")\nlines.push(\"Path.resolve = function(a)\")\nlines.push(\"parts = a.split(\"\"/\"\")\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for part in parts\")\nlines.push(\"if (part == \"\"..\"\") then\")\nlines.push(\"result.pop()\")\nlines.push(\"else if (part != \"\"\"\" and part != \"\".\"\") then\")\nlines.push(\"result.push(part)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"resolved = result.join(\"\"/\"\")\")\nlines.push(\"\")\nlines.push(\"if (a.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"resolved = \"\"/\"\" + resolved\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return resolved\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path.join = function(a, b)\")\nlines.push(\"if (b.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"b = b[1:]\")\nlines.push(\"end if\")\nlines.push(\"return Path.resolve([a, b].join(\"\"/\"\"))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS = {}\")\nlines.push(\"\")\nlines.push(\"FS.constructor = function(computer)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS.createFile = function(path, name)\")\nlines.push(\"self.computer.touch(path, name)\")\nlines.push(\"return self.computer.File(Path.join(path, name))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand.constructor = function(file)\")\nlines.push(\"self.file = file\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTCommand.constructor = function(line, str, key, action)\")\nlines.push(\"self.line = line\")\nlines.push(\"self.str = str\")\nlines.push(\"self.key = key\")\nlines.push(\"self.action = action\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTRegistry = {}\")\nlines.push(\"\")\nlines.push(\"ASTRegistry.import = ASTImportCommand\")\nlines.push(\"\")\nlines.push(\"AST = {}\")\nlines.push(\"\")\nlines.push(\"AST.constructor = function(computer, file)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.file = file\")\nlines.push(\"self.lines = []\")\nlines.push(\"self.commands = []\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.analyze = function()\")\nlines.push(\"debug(\"\"Analyzing AST...\"\")\")\nlines.push(\"content = self.file.get_content\")\nlines.push(\"commands = []\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"index = 0\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"str = (new String).constructor(line)\")\nlines.push(\"\")\nlines.push(\"if (str.startsWith(Config.get(\"\"COMMAND_START\"\"))) then\")\nlines.push(\"command = str.substr(1, str.indexOf(\"\" \"\"))\")\nlines.push(\"key = command.toString()\")\nlines.push(\"\")\nlines.push(\"if (ASTRegistry[key] == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid command $0 on line $1\"\", [key, index]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"action = ASTRegistry[key]\")\nlines.push(\"entry = (new ASTCommand).constructor(index, str, key, new action)\")\nlines.push(\"commands.push(entry)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"index = index + 1\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.lines = lines\")\nlines.push(\"self.commands = commands\")\nlines.push(\"\")\nlines.push(\"return commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.transform = function(line, code)\")\nlines.push(\"self.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\")\nlines.push(\"\")\nlines.push(\"return self.lines\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.getCommands = function()\")\nlines.push(\"return self.commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency = {}\")\nlines.push(\"\")\nlines.push(\"Dependency.constructor = function(computer, file, ast)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = file\")\nlines.push(\"self.basePath = file.parent.path\")\nlines.push(\"self.ast = ast\")\nlines.push(\"self.dependencies = []\")\nlines.push(\"\")\nlines.push(\"if self.target == null then\")\nlines.push(\"(new Error).constructor(\"\"Dependency $0 does not exist...\"\", [file.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency.findDependencies = function()\")\nlines.push(\"debug(\"\"Finding dependencies...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"commands = self.ast.getCommands()\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"path = command.str.substr(command.str.indexOf(\"\"from\"\") + 4, command.str.indexOf(\"\";\"\")).toString()\")\nlines.push(\"\")\nlines.push(\"if (path == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid import on line $0 in $1...\"\", [command.line, self.target.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"filePath = pathHelper.join(self.basePath, path.trim() + \"\".\"\" + Config.getExtension())\")\nlines.push(\"file = self.computer.File(filePath)\")\nlines.push(\"debug(\"\"Looking for file in \"\" + filePath + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find $0...\"\", [filePath]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"command.action.constructor(file)\")\nlines.push(\"\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"\")\nlines.push(\"result.push(dependency)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.dependencies = result\")\nlines.push(\"\")\nlines.push(\"return result\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor = {}\")\nlines.push(\"\")\nlines.push(\"Preprocessor.constructor = function(computer, dependency)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.dependency = dependency\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor.run = function()\")\nlines.push(\"debug(\"\"Run preprocessor...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"mainDependency = self.dependency\")\nlines.push(\"mainModuleName = md5(mainDependency.target.path)\")\nlines.push(\"headerBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"header\"\")).get_content\")\nlines.push(\"moduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"module\"\")).get_content\")\nlines.push(\"mainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"main\"\")).get_content\")\nlines.push(\"modules = {}\")\nlines.push(\"iterator = function(item)\")\nlines.push(\"moduleName = md5(item.target.path)\")\nlines.push(\"\")\nlines.push(\"if (modules.hasIndex(moduleName)) then\")\nlines.push(\"return\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"commands = item.ast.getCommands()\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"importIndex = command.str.indexOf(\"\"import\"\")\")\nlines.push(\"fromIndex = command.str.indexOf(\"\"from\"\")\")\nlines.push(\"defVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\")\nlines.push(\"defId = md5(command.action.file.path)\")\nlines.push(\"code = (new String).constructor(\"\"$0 = __REQUIRE(\"\"\"\"$1\"\"\"\")\"\").parse([defVar, defId])\")\nlines.push(\"\")\nlines.push(\"item.ast.transform(command.line, code.toString())\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"if (moduleName != mainModuleName) then\")\nlines.push(\"transformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(moduleBoilerplate)\")\nlines.push(\"modules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for dependency in item.dependencies\")\nlines.push(\"iterator(dependency)\")\nlines.push(\"end for\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"iterator(mainDependency)\")\nlines.push(\"\")\nlines.push(\"processed = [headerBoilerplate]\")\nlines.push(\"\")\nlines.push(\"for module in modules.values\")\nlines.push(\"processed.push(module)\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"transformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(mainBoilerplate)\")\nlines.push(\"processed.push(moduleCode.parse([transformedCode]).toString())\")\nlines.push(\"\")\nlines.push(\"return processed.join(NEW_LINE_OPERATOR + NEW_LINE_OPERATOR + NEW_LINE_OPERATOR + NEW_LINE_OPERATOR)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler = {}\")\nlines.push(\"\")\nlines.push(\"Compiler.constructor = function(computer, name)\")\nlines.push(\"idGenerator = new IdGenerator\")\nlines.push(\"\")\nlines.push(\"self.buildId = idGenerator.get()\")\nlines.push(\"self.name = name\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = computer.File(self.getFullScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.isTargetExisting = function()\")\nlines.push(\"return self.target != null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getScriptFilePath = function()\")\nlines.push(\"return self.name + \"\".\"\" + Config.getExtension()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullScriptFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getScriptFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullTempFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getTempFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.preprocess = function()\")\nlines.push(\"debug(\"\"Start processing...\"\")\")\nlines.push(\"file = self.computer.File(self.getFullScriptFilePath())\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"preprocessor = (new Preprocessor).constructor(self.computer, dependency)\")\nlines.push(\"return preprocessor.run()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.compile = function(shell)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"fs = (new FS).constructor(self.computer)\")\nlines.push(\"buildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\")\nlines.push(\"buildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"self.computer.create_folder(Config.getTempFolder(), self.buildId)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Build id: \"\" + self.buildId)\")\nlines.push(\"\")\nlines.push(\"newFile = fs.createFile(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"if newFile == null then\")\nlines.push(\"exit(\"\"Unable to create file...\"\")\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = self.preprocess()\")\nlines.push(\"\")\nlines.push(\"newFile.set_content(content)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Building in \"\" + Config.getBinFolder() + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"buildReport = shell.build(buildPathFull, Config.getBinFolder())\")\nlines.push(\"\")\nlines.push(\"compiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\")\nlines.push(\"if self.computer.File(compiledBuildPathFull) == null then\")\nlines.push(\"(new Error).constructor(\"\"Built failed: $0\"\", [buildReport]).throw()\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"main = function(name)\")\nlines.push(\"myShell = get_shell\")\nlines.push(\"myComputer = myShell.host_computer\")\nlines.push(\"\")\nlines.push(\"compiler = (new Compiler).constructor(myComputer, name)\")\nlines.push(\"\")\nlines.push(\"if compiler.isTargetExisting == false then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find file.\"\").throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = compiler.compile(myShell)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.load()\")\nlines.push(\"\")\nlines.push(\"argDefinitions = []\")\nlines.push(\"\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"h\"\", \"\"help\"\", ArgType.FLAG, \"\"Print help\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"d\"\", \"\"debug\"\", ArgType.FLAG, \"\"Activate debug mode\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"cs\"\", \"\"command-start\"\", ArgType.VALUE, \"\"Command starting operator\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"s\"\", \"\"script-folder\"\", ArgType.VALUE, \"\"Script folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"t\"\", \"\"temp-folder\"\", ArgType.VALUE, \"\"Temporary folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"c\"\", \"\"compiler-folder\"\", ArgType.VALUE, \"\"Compiler folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"b\"\", \"\"bin-folder\"\", ArgType.VALUE, \"\"Bin folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"se\"\", \"\"script-extension\"\", ArgType.VALUE, \"\"Script extension\"\"))\")\nlines.push(\"\")\nlines.push(\"helpBlock = []\")\nlines.push(\"\")\nlines.push(\"helpBlock.push(\"\"Compiler CLI\"\")\")\nlines.push(\"helpBlock.push(\"\"Version: \"\" + Config.get(\"\"VERSION\"\"))\")\nlines.push(\"helpBlock.push(\"\"Example: <b>compile myscriptfile</b>\"\")\")\nlines.push(\"helpBlock.push(\"\"\"\")\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"helpBlock.push(argDefinition.toString())\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"help = helpBlock.join(NEW_LINE_OPERATOR)\")\nlines.push(\"\")\nlines.push(\"argv = (new Argv).constructor(argDefinitions, help)\")\nlines.push(\"\")\nlines.push(\"argv.parse()\")\nlines.push(\"\")\nlines.push(\"if (argv.getWithKey(\"\"help\"\") == true) then\")\nlines.push(\"exit(help)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"key = argDefinition.command.upper.replace(\"\"-\"\", \"\"_\"\")\")\nlines.push(\"value = argv.getWithKey(argDefinition.command)\")\nlines.push(\"Config.set(key, value)\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"debug(\"\"Start compiling...\"\")\")\nlines.push(\"main(argv.get(0, true))\")\nlines.push(\"exit(\"\"Done compiling...\"\")\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates header file...\")\nfile = c.File(h + \"/compiler/boilerplates/header.src\")\nlines = []\nlines.push(\"BACKSLASH_CODE = 92\")\nlines.push(\"NEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"\"n\"\"\")\nlines.push(\"MODULES = {}\")\nlines.push(\"EXPORTED = {}\")\nlines.push(\"\")\nlines.push(\"__REQUIRE = function(r)\")\nlines.push(\"if (MODULES.hasIndex(r) == false) then\")\nlines.push(\"exit(\"\"Module \"\" + r + \"\" cannot be found...\"\")\")\nlines.push(\"end if\")\nlines.push(\"module = MODULES[r]\")\nlines.push(\"return module(r)\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates module file...\")\nfile = c.File(h + \"/compiler/boilerplates/module.src\")\nlines = []\nlines.push(\"MODULES[\"\"$0\"\"] = function(r)\")\nlines.push(\"module = {}\")\nlines.push(\"\")\nlines.push(\"if (EXPORTED.hasIndex(r)) then\")\nlines.push(\"module = EXPORTED[r]\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"if (module.hasIndex(\"\"exports\"\") == false) then\")\nlines.push(\"$1\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"EXPORTED[r] = module\")\nlines.push(\"\")\nlines.push(\"return module.exports\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates main file...\")\nfile = c.File(h + \"/compiler/boilerplates/main.src\")\nlines = []\nlines.push(\"MAIN = function()\")\nlines.push(\"$0\")\nlines.push(\"end function\")\nlines.push(\"MAIN()\")\nfile.set_content(lines.join(\"\\n\"))\n\n",
        "ID": "1826a750c9b67abb756396efbe238ab8",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\npath = (new String).constructor(\"$0/Config/compile.conf\")\npath = path.parse([home_dir]).toString()\nfile = get_shell.host_computer.File(path)\nif (file == null) then\n(new Error).constructor(\"No config in $0...\", [path]).throw()\nend if\ncontent = file.get_content\nlines = content.split(NEW_LINE_OPERATOR)\nmap = {}\n\nfor line in lines\ndef = line.split(\"=\")\nname = def.pull()\nvalue = def.pull()\nmap[name] = value\nend for\n\nself.map = map\n\nreturn map\nend function\n\nConfig.set = function(key, value)\nif (self.hasIndex(\"map\") and value != null) then\nself.map[key] = value\nend if\nreturn self\nend function\n\nConfig.get = function(key)\nif (self.hasIndex(\"map\")) then\nreturn self.map[key]\nend if\nreturn null\nend function\n\nConfig.getScriptFolder = function()\npath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\nuser = active_user\nreturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\npath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\nuser = active_user\nreturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\npath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\nuser = active_user\nreturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\nreturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\nvalue = Config.get(\"DEBUG\")\nif (typeof(value) == \"string\") then\nreturn value == \"true\"\nend if\nreturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\npathHelper = new Path\npath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\nreturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\nreturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\nif (Config.isDebugMode()) then\nprint(msg)\nend if\nend function\n\nString = {}\n\nString.constructor = function(str)\nself.str = str\nreturn self\nend function\n\nString.parse = function(values)\nresult = self.str\nindex = 0\nmaxIndex = values.len\n\nwhile index < maxIndex\nresult = result.replace(\"$\"+index, values[index])\nindex = index + 1\nend while\n\nreturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\nreturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\nreturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\nreturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\nreturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\nreturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\nreturn self.str\nend function\n\nString.length = function()\nreturn self.str.len\nend function\n\nString.split = function(seperator)\nreturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\nreturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\nself.message = message\nif (values != null) then\nself.message = (new String.constructor(message)).parse(values).toString()\nend if\nreturn self\nend function\n\nError.throw = function()\nexit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\nself.shortcut = shortcut\nself.command = command\nself.type = type\nself.description = description\nreturn self\nend function\n\nArg.toString = function()\nstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\nreturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\nself.args = params\nself.listed = {}\nself.unlisted = []\nself.defs = defs\nself.help = help\nreturn self\nend function\n\nArgv.parse = function()\nargs = self.args\ndefs = self.defs\nlisted = {}\nunlisted = []\nindex = 0\nmaxIndex = args.len\nfindDef = function(arg)\nfor def in defs\nif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\nreturn def\nend if\nend for\nreturn null\nend function\n\nwhile index < maxIndex\nitem = args[index].trim()\ndef = findDef(item)\nif (def == null) then\nunlisted.push(item)\nelse\nif (def.type == ArgType.VALUE) then\nindex = index + 1\nvalue = args[index]\nlisted[def.command] = value\nelse if (def.type == ArgType.FLAG) then\nlisted[def.command] = true\nend if\nend if\nindex = index + 1\nend while\n\nself.listed = listed\nself.unlisted = unlisted\n\nreturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\nif self.unlisted.hasIndex(index) then\nreturn self.unlisted[index]\nend if\nif mandatory then\n(new Error).constructor(\"Error cannot find param[$0]$1$2$3\", [index, NEW_LINE_OPERATOR, NEW_LINE_OPERATOR, self.help]).throw()\nend if\nreturn null\nend function\n\nArgv.getWithKey = function(key)\nif self.listed.hasIndex(key) then\nreturn self.listed[key]\nend if\nreturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\nreturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\nreturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\nmath = new Math\nchars = self.getChars()\n\nresult = []\nindexA = 0\nmaxA = 4\n\nwhile indexA < maxA\nindexB = 0\nmaxB = 5\ncode = \"\"\n\nwhile indexB < maxB\ncode = code + chars[math.random(0, chars.len - 1)]\n\nindexB = indexB + 1\nend while\n\nresult.push(code)\n\nindexA = indexA + 1\nend while\n\nreturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.resolve = function(a)\nparts = a.split(\"/\")\nresult = []\n\nfor part in parts\nif (part == \"..\") then\nresult.pop()\nelse if (part != \"\" and part != \".\") then\nresult.push(part)\nend if\nend for\n\nresolved = result.join(\"/\")\n\nif (a.indexOf(\"/\") == 0) then\nresolved = \"/\" + resolved\nend if\n\nreturn resolved\nend function\n\nPath.join = function(a, b)\nif (b.indexOf(\"/\") == 0) then\nb = b[1:]\nend if\nreturn Path.resolve([a, b].join(\"/\"))\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\nself.computer = computer\nreturn self\nend function\n\nFS.createFile = function(path, name)\nself.computer.touch(path, name)\nreturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\nself.file = file\nreturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\nself.line = line\nself.str = str\nself.key = key\nself.action = action\nreturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\nself.computer = computer\nself.file = file\nself.lines = []\nself.commands = []\nreturn self\nend function\n\nAST.analyze = function()\ndebug(\"Analyzing AST...\")\ncontent = self.file.get_content\ncommands = []\nlines = content.split(NEW_LINE_OPERATOR)\nindex = 0\n\nfor line in lines\nstr = (new String).constructor(line)\n\nif (str.startsWith(Config.get(\"COMMAND_START\"))) then\ncommand = str.substr(1, str.indexOf(\" \"))\nkey = command.toString()\n\nif (ASTRegistry[key] == null) then\n(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\nend if\n\naction = ASTRegistry[key]\nentry = (new ASTCommand).constructor(index, str, key, new action)\ncommands.push(entry)\nend if\n\nindex = index + 1\nend for\n\nself.lines = lines\nself.commands = commands\n\nreturn commands\nend function\n\nAST.transform = function(line, code)\nself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\nreturn self.lines\nend function\n\nAST.getCommands = function()\nreturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\npathHelper = new Path\n\nself.computer = computer\nself.target = file\nself.basePath = file.parent.path\nself.ast = ast\nself.dependencies = []\n\nif self.target == null then\n(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\nend if\n\nreturn self\nend function\n\nDependency.findDependencies = function()\ndebug(\"Finding dependencies...\")\npathHelper = new Path\ncommands = self.ast.getCommands()\nresult = []\n\nfor command in commands\nif (command.key == \"import\") then\npath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\nif (path == null) then\n(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\nend if\n\nfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\nfile = self.computer.File(filePath)\ndebug(\"Looking for file in \" + filePath + \"...\")\n\nif (file == null) then\n(new Error).constructor(\"Cannot find $0...\", [filePath]).throw()\nend if\n\ncommand.action.constructor(file)\n\nast = (new AST).constructor(self.computer, file)\nast.analyze()\n\ndependency = (new Dependency).constructor(self.computer, file, ast)\ndependency.findDependencies()\n\nresult.push(dependency)\nend if\nend for\n\nself.dependencies = result\n\nreturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\nself.computer = computer\nself.dependency = dependency\nreturn self\nend function\n\nPreprocessor.run = function()\ndebug(\"Run preprocessor...\")\npathHelper = new Path\nmainDependency = self.dependency\nmainModuleName = md5(mainDependency.target.path)\nheaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\nmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\nmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\nmodules = {}\niterator = function(item)\nmoduleName = md5(item.target.path)\n\nif (modules.hasIndex(moduleName)) then\nreturn\nend if\n\ncommands = item.ast.getCommands()\n\nfor command in commands\nif (command.key == \"import\") then\nimportIndex = command.str.indexOf(\"import\")\nfromIndex = command.str.indexOf(\"from\")\ndefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\ndefId = md5(command.action.file.path)\ncode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\nitem.ast.transform(command.line, code.toString())\nend if\nend for\n\nif (moduleName != mainModuleName) then\ntransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\nmoduleCode = (new String).constructor(moduleBoilerplate)\nmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\nend if\n\nfor dependency in item.dependencies\niterator(dependency)\nend for\nend function\n\niterator(mainDependency)\n\nprocessed = [headerBoilerplate]\n\nfor module in modules.values\nprocessed.push(module)\nend for\n\ntransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\nmoduleCode = (new String).constructor(mainBoilerplate)\nprocessed.push(moduleCode.parse([transformedCode]).toString())\n\nreturn processed.join(NEW_LINE_OPERATOR + NEW_LINE_OPERATOR + NEW_LINE_OPERATOR + NEW_LINE_OPERATOR)\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\nidGenerator = new IdGenerator\n\nself.buildId = idGenerator.get()\nself.name = name\nself.computer = computer\nself.target = computer.File(self.getFullScriptFilePath())\n\nreturn self\nend function\n\nCompiler.isTargetExisting = function()\nreturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\nreturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\npath = new Path\nreturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\npath = new Path\nreturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\ndebug(\"Start processing...\")\nfile = self.computer.File(self.getFullScriptFilePath())\nast = (new AST).constructor(self.computer, file)\nast.analyze()\ndependency = (new Dependency).constructor(self.computer, file, ast)\ndependency.findDependencies()\npreprocessor = (new Preprocessor).constructor(self.computer, dependency)\nreturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\npathHelper = new Path\nfs = (new FS).constructor(self.computer)\nbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\nbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\nself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\nprint(\"Build id: \" + self.buildId)\n\nnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\nif newFile == null then\nexit(\"Unable to create file...\")\nend if\n\ncontent = self.preprocess()\n\nnewFile.set_content(content)\n\nprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\nbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\ncompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\nif self.computer.File(compiledBuildPathFull) == null then\n(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\nend if\nend function\n\nmain = function(name)\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\ncompiler = (new Compiler).constructor(myComputer, name)\n\nif compiler.isTargetExisting == false then\n(new Error).constructor(\"Cannot find file.\").throw()\nend if\n\ncontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\nhelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(NEW_LINE_OPERATOR)\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\nexit(help)\nend if\n\nfor argDefinition in argDefinitions\nkey = argDefinition.command.upper.replace(\"-\", \"_\")\nvalue = argv.getWithKey(argDefinition.command)\nConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")",
        "ID": "67116b93824e6183b2976ee38b721acf",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function",
        "ID": "e0706e482a2076f3dd5f433daba7d70f",
        "refCount": 1
    },
    {
        "Content": "MODULES[\"$0\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\n$1\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function",
        "ID": "8545c690918c5c9947fde4cdea33a403",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"64a02618dbef26b25765feabdbece462\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nNetworkDevice = {}\n\nNetworkDevice.constructor = function(name, chipset, monitor)\n\tself.name = parsed[0]\n\tself.chipset = parsed[1]\n\tself.monitor = parsed[2]\n\t\n\treturn self\nend function\n\nNetworkDevice.createNetworkDeviceFromString = function(networkDeviceString)\n\tparsed = networkDeviceString.split(\" \")\n\t\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetworkDeviceManager = {}\n\nNetworkDeviceManager.NetworkDevice = NetworkDevice\n\nNetworkDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetworkDeviceManager.getNetworkDevices = function()\n\tnetworkDevices = self.computer.network_devices\n\tlist = networkDevices.split(NEW_LINE_OPERATOR)\n\n\tif list.len == 0 then\n\t\treturn []\n\tend if\n\n\tif list[list.len - 1] == \"\" then\n\t\tlist.pop()\n\tend if\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetworkDevice\n\t\titem = item.createNetworkDeviceFromString(list[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetworkDeviceManager.showNetworkDevices = function()\n\tlist = self.getNetworkDevices()\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.name)\n\t\tindex = index + 1\n\tend while\nend function\n\nNetworkDeviceManager.getNetworkDeviceByIndex = function(networkDeviceIndex = 0)\n\tlist = self.getNetworkDevices()\n\n\tif list.hasIndex(networkDeviceIndex) == 0 then\n\t\tprint(\"Error: No network device found with that index.\")\n\t\treturn null\n\tend if\n\n\tdevice = list.values[networkDeviceIndex]\n\n\tif device.monitor == \"false\" then\n\t\tprint(\"Error: Monitor mode is false.\")\n\t\treturn null\n\tend if\n\n\treturn device\nend function\n\nmodule.exports = NetworkDeviceManager\n\n\n\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"0592fdff0e7e0519c04395fd952ff580\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nNetDevice = {}\n\nNetDevice.constructor = function(bssid, pwr, essid)\n\tself.bssid = parsed[0]\n\tself.pwr = parsed[1]\n\tself.essid = parsed[2]\n\t\n\treturn self\nend function\n\nNetDevice.toString = function()\n\treturn [self.bssid,self.pwr,self.essid].join(\"/\")\nend function\n\nNetDevice.createNetDeviceFromString = function(netDeviceString)\n\tparsed = netDeviceString.split(\" \")\n\n\treturn self.constructor(parsed[0], parsed[1], parsed[2])\nend function\n\nNetDeviceManager = {}\n\nNetDeviceManager.NetDevice = NetDevice\n\nNetDeviceManager.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nNetDeviceManager.getNetDevices = function(networkDevice)\n\tnetDevices = self.computer.wifi_networks(networkDevice.name)\n\n\tresult = []\n\tindex = 0\n\tmaxIndex = netDevices.len\n\n\twhile index < maxIndex\n\t\titem = new self.NetDevice\n\t\titem = item.createNetDeviceFromString(netDevices[index])\n\t\tresult.push(item)\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nNetDeviceManager.showNetDevices = function(networkDevice)\n\tlist = self.getNetDevices(networkDevice)\n\n\tindex = 0\n\tmaxIndex = list.len\n\n\tprint(\"Select net device...\")\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\tprint(index + \".) \" + item.toString())\n\t\tindex = index + 1\n\tend while\nend function\n\nNetDeviceManager.getNetDeviceByIndex = function(networkDevice, netDeviceIndex = 0)\n\tlist = self.getNetDevices(networkDevice)\n\n\tif list.hasIndex(netDeviceIndex) == 0 then\n\t\tprint(\"Error: No net device found with that index.\")\n\t\treturn null\n\tend if\n\n\treturn list.values[netDeviceIndex]\nend function\n\nmodule.exports = NetDeviceManager\n\n\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"de3c218bbaa9dc4838ffacbdcdc19993\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nAireplayHelper = {}\n\nAireplayHelper.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nAireplayHelper.getAireplayFilePath = function()\n\treturn [current_path, \"file.cap\"].join(\"/\")\nend function\n\nAireplayHelper.clearAireplayFile = function()\n\tfile = self.computer.File(self.getAireplayFilePath())\n\n\tif file != null then\n\t\tfile.delete\n\tend if\nend function\n\nmodule.exports = AireplayHelper\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\ncrypto = include_lib(\"/lib/crypto.so\")\n\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nNewtworkDeviceManager = __REQUIRE(\"64a02618dbef26b25765feabdbece462\")\nNetDeviceManager = __REQUIRE(\"0592fdff0e7e0519c04395fd952ff580\")\nAireplayHelper = __REQUIRE(\"de3c218bbaa9dc4838ffacbdcdc19993\")\n\nargv = new Argv\n\nnetworkDeviceIndex = argv.get(0)\nnetDeviceIndex = argv.get(1)\nmaxAcks = argv.get(2)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\nnetworkDeviceManager = new NewtworkDeviceManager\nnetDeviceManager = new NetDeviceManager\naireplayHelper = new AireplayHelper\n\nnetworkDeviceManager.constructor(myComputer)\nnetDeviceManager.constructor(myComputer)\naireplayHelper.constructor(myComputer)\n\nif networkDeviceIndex == null then\n\tnetworkDeviceManager.showNetworkDevices()\nelse\n\tselectedNetworkDevice = networkDeviceManager.getNetworkDeviceByIndex(to_int(networkDeviceIndex))\n\t\n\tif selectedNetworkDevice == null then\n\t\texit(\"No network device\")\n\tend if\n\n\tif netDeviceIndex == null then\n\t\tnetDeviceManager.showNetDevices(selectedNetworkDevice)\n\telse\n\t\tselectedNetDevice = netDeviceManager.getNetDeviceByIndex(selectedNetworkDevice, to_int(netDeviceIndex))\n\n\t\tif selectedNetDevice == null then\n\t\t\texit(\"No net device\")\n\t\tend if\n\t\t\n\t\tif maxAcks == null then\n\t\t\tmaxAcks = 500\n\t\telse\n\t\t\tmaxAcks = to_int(maxAcks)\n\t\tend if\n\n\t\tprint(\"Looking for \" + selectedNetDevice.bssid + \"/\" + selectedNetDevice.essid + \" with \" + selectedNetworkDevice.name + \"... (\" + maxAcks + \")\")\n\n\t\taireplayHelper.clearAireplayFile()\n\t\tcrypto.aireplay(selectedNetDevice.bssid, selectedNetDevice.essid, maxAcks)\n\n\t\tfileCapPath = aireplayHelper.getAireplayFilePath()\n\t\tcapFile = myComputer.File(fileCapPath)\n\n\t\tif capFile == null then\n\t\t\texit(\"No cap file\")\n\t\tend if\n\n\t\tpassword = crypto.aircrack(fileCapPath)\n\t\tcapFile.delete\n\n\t\tif password == null then\n\t\t\texit(\"No password\")\n\t\tend if\n\n\t\texit(\"Found password: \" + password)\n\tend if\nend if\n\n\n\nend function\nMAIN()",
        "ID": "dc7f6d5acbbb8f9b716703e10db25002",
        "refCount": 1
    },
    {
        "Content": "print(\"\\\".code)\nprint(char(92))\n\nstr = \"/bin/usr/test/../was/..\"\n\nprint(str.replace(\"(/[A-Za-z\\-_]+/)..\"), \"\")\n",
        "ID": "dd1e1ad0a671a9916e34db09bc9257d8",
        "refCount": 1
    },
    {
        "Content": "print(\"\\\".code)\nprint(char(92))\n\nstr = \"/bin/usr/test/../was/..\"\n\nprint(str.replace(\"(/[A-Za-z\\-_]+/)..\", \"\"))\n",
        "ID": "77a1301a72b3080ac9905856dcdf9be7",
        "refCount": 2
    },
    {
        "Content": "Connection = {}\n\nConnection.constructor = function(shell, ip, port, username, password)\n\tself.parentShell = shell\n\tself.ip = ip\n\tself.port = port\n\tself.username = username\n\tself.password = password\n\tself.start()\n\t\n\treturn self\nend function\n\nConnection.start = function()\n\tself.shell = self.parentShell.connect_service(self.ip, self.port, self.username, self.password)\n\treturn self\nend function\n\nConnectionManager = {}\n\nConnectionManager.Connection = Connection\n\nConnectionManager.constructor = function(shell)\n\tself.shell = shell\n\tself.connections = []\n\treturn self\nend function\n\nConnectionManager.connect = function(ip, port, username, password)\n\tconnection = new self.Connection\n\tconnection.constructor(self.shell, ip, port, username, password)\n\tself.connections.push(connection)\n\treturn connection\nend function\n\nConnectionManager.disconnect = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\tmaxIndex = self.connections.len\n\t\n\tif index == null then\n\t\treturn self.connections\n\tend if\n\t\n\tif index == 0 then\n\t\tself.connections = slice(self.connections, 1, max)\n\telse if (index == max - 1) then\n\t\tself.connections = slice(self.connections, 0, max - 1)\n\telse\n\t\tbefore = slice(self.connections, 0, index)\n\t\tafter = slice(self.connections, index + 1, max)\n\t\tself.connections = before + after\n\tend if\n\t\n\treturn self.connections\nend function\n\nConnectionManager.findConnectionIndex = function(ip)\n\tindex = 0\n\tmaxIndex = self.connections.len\n\t\n\twhile index < maxIndex\n\t\titem = self.connections[index]\n\t\tif item.ip == ip then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nConnectionManager.findConnection = function(ip)\n\tindex = self.findConnectionIndex(ip)\n\t\n\tif index != null then\n\t\treturn self.connections[index]\n\tend if\n\n\treturn null\nend function\n\nConnectionManager.getOrConnect = function(ip, port, username, password)\n\tconnection = self.findConnection(ip)\n\t\n\tif connection == null then\n\t\tconnection = self.connect(ip, port, username, password)\n\tend if\n\n\treturn connection\nend function\n\nmodule.exports = ConnectionManager\n\n\n",
        "ID": "faf706bd6967f866e552a55f6125ce46",
        "refCount": 1
    },
    {
        "Content": "#import Argv from library/get-param;\n#import PasswordFileManager from library/password-manager;\n\nargv = new Argv\n\nkey = argv.get(0, true)\npassword = argv.get(1, true)\noverride = argv.get(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nentry = new PasswordFileManager.PasswordEntry\nentry.constructor(key, password)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tpasswordManager.setPasswordByKey(entry)\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tpasswordManager.passwordList.push(entry)\nend if\n\nprint(\"Saving password...\")\npasswordManager.savePasswordFile()\n\n\n\n\n\n",
        "ID": "16dd21c262fc7332d0b216af61d32743",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\n\n\n\n\n\n\n\n\n\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nkey = argv.get(0, true)\npassword = argv.get(1, true)\noverride = argv.get(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nentry = new PasswordFileManager.PasswordEntry\nentry.constructor(key, password)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tpasswordManager.setPasswordByKey(entry)\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tpasswordManager.passwordList.push(entry)\nend if\n\nprint(\"Saving password...\")\npasswordManager.savePasswordFile()\n\n\n\n\n\n\nend function\nMAIN()",
        "ID": "910de326cec1d105a72a0bcfb3bb3886",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\n\n\n\n\n\n\n\n\n\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nkey = argv.get(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry.password)\n\n\n\n\n\nend function\nMAIN()",
        "ID": "fd95d57be76461a73512bd2bc6165cbc",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\n\n\n\n\n\n\n\n\n\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nkey = argv.get(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\npasswordManager.removePasswordByKey(existingEntry)\n\nprint(\"Removing password...\")\npasswordManager.savePasswordFile()\n\npasswordManager.parsePasswordFile()\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Removing was a success\")\nend if\n\nexit(\"Something went wrong\")\n\n\n\n\nend function\nMAIN()",
        "ID": "17b91baba955e9baf2d5a0c429f4581d",
        "refCount": 1
    },
    {
        "Content": "#import Argv from library/get-param;\n#import PasswordFileManager from library/password-manager;\n\nargv = new Argv\n\nlistIndex = to_int(argv.get(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.passwordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Entry: \" + passwordManager.passwordList[listIndex].toString())\n\n\n\n\n\n",
        "ID": "771053ec4948bcca5cf586b0de26d9db",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\n\n\n\n\n\n\n\n\n\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nlistIndex = to_int(argv.get(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.passwordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Entry: \" + passwordManager.passwordList[listIndex].toString())\n\n\n\n\n\n\nend function\nMAIN()",
        "ID": "cd465f6c998762060689cfdbf24b1c55",
        "refCount": 1
    },
    {
        "Content": "#import Argv from library/get-param;\n#import PasswordFileManager from library/password-manager;\n\nargv = new Argv\n\nkey = argv.get(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry.password)\n\n\n\n\n\n",
        "ID": "12e9d2e5f7dc0767c377af822afb5445",
        "refCount": 1
    },
    {
        "Content": "#import Argv from library/get-param;\n#import PasswordFileManager from library/password-manager;\n\nargv = new Argv\n\nkey = argv.get(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\npasswordManager.removePasswordByKey(existingEntry)\n\nprint(\"Removing password...\")\npasswordManager.savePasswordFile()\n\npasswordManager.parsePasswordFile()\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Removing was a success\")\nend if\n\nexit(\"Something went wrong\")\n\n\n\n\n",
        "ID": "c2245dc9908011249c1d51dbfaf6867e",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\n\n\n\n\n\n\n\n\n\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nprint(passwordManager.passwordList.values)\n\n\n\n\n\n\nend function\nMAIN()",
        "ID": "ac54afb0e5e10fbae38521ebd6d32754",
        "refCount": 1
    },
    {
        "Content": "#import PasswordFileManager from library/password-manager;\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nfor value in passwordManager.passwordList.values\n\tprint(value.toString())\nend for\n\n\n\n\n\n",
        "ID": "856aee1fe387e1a76d388191df24223b",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(\"\n\")\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\n\twhile index < maxIndex\n\t\titem = list[index]\n\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\n\t\tindex = index + 1\n\tend while\n\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\n\tcontent = stringList.join(\"\n\")\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\n\n\n\n\n\n\n\n\n\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nfor value in passwordManager.passwordList.values\n\tprint(value.toString())\nend for\n\n\n\n\n\n\nend function\nMAIN()",
        "ID": "ba145eb4963b52585cb1cf1c4698d1b6",
        "refCount": 1
    },
    {
        "Content": "#import Argv from library/get-param;\n#import FS from library/fs;\n\nargv = new Argv\n\ntarget = argv.get(0, true)\n\nfs = new FS\nfs.constructor(get_shell.host_computer)\n\nif fs.doesFileExist(target) == false then\n\texit(\"File does not exist\")\nend if\n\nprompt = user_input(\"You are about to delete all folders in \" + target + \". Are you sure? (Y/n)\")\n\nif prompt != \"Y\" then\n\texit(\"Aborted...\")\nend if\n\nfolder = fs.getFilesInFolder(target)\n\nif folder == null then\n\texit(\"Could not find folder.\")\nend if\n\nfor file in folder\n\tprint(\"Deleting \" + file.path + \"...\")\n\tfile.delete\nend for\n\nexit(\"Done!\")\n\n",
        "ID": "5789c9ee4d7576780ec31f03811b5802",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nargv = new Argv\n\ntarget = argv.get(0, true)\n\nfs = new FS\nfs.constructor(get_shell.host_computer)\n\nif fs.doesFileExist(target) == false then\n\texit(\"File does not exist\")\nend if\n\nprompt = user_input(\"You are about to delete all folders in \" + target + \". Are you sure? (Y/n)\")\n\nif prompt != \"Y\" then\n\texit(\"Aborted...\")\nend if\n\nfolder = fs.getFilesInFolder(target)\n\nif folder == null then\n\texit(\"Could not find folder.\")\nend if\n\nfor file in folder\n\tprint(\"Deleting \" + file.path + \"...\")\n\tfile.delete\nend for\n\nexit(\"Done!\")\n\n\nend function\nMAIN()",
        "ID": "3149b62d89e9799b9fcf7e39ed9a6358",
        "refCount": 1
    },
    {
        "Content": "#import Argv from library/get-param;\n#import FS from library/fs;\n\nargv = new Argv\n\n//add args\nfilter = argv.get(0, true)\n\n//default variables\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\n//initialize fs\nfs = new FS\n\nfs.constructor(myComputer)\n\n//add code\nitems = fs.getTree(\"/\", filter)\n\nif items.len == 0 then\n\texit(\"Nothing found.\")\nend if\n\nfor item in items\n\tprint(\"Found \" + item.path + \"...\")\nend for\n\nexit(\"Done!\")\n\n",
        "ID": "450870d2f7cbda092e1926be5429bcbd",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nargv = new Argv\n\n//add args\nfilter = argv.get(0, true)\n\n//default variables\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\n//initialize fs\nfs = new FS\n\nfs.constructor(myComputer)\n\n//add code\nitems = fs.getTree(\"/\", filter)\n\nif items.len == 0 then\n\texit(\"Nothing found.\")\nend if\n\nfor item in items\n\tprint(\"Found \" + item.path + \"...\")\nend for\n\nexit(\"Done!\")\n\n\nend function\nMAIN()",
        "ID": "cdd7624900f14d89bb41af3ed8782718",
        "refCount": 2
    },
    {
        "Content": "#import FS from fs;\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(NEW_LINE_OPERATOR)\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\t\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\t\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\t\n\tcontent = stringList.join(NEW_LINE_OPERATOR)\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n",
        "ID": "a3ee1e1ab1adc94d1e8ff0745108121c",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(NEW_LINE_OPERATOR)\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\t\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\t\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\t\n\tcontent = stringList.join(NEW_LINE_OPERATOR)\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nkey = argv.get(0, true)\npassword = argv.get(1, true)\noverride = argv.get(2, false)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nentry = new PasswordFileManager.PasswordEntry\nentry.constructor(key, password)\n\nif existingEntry != null then\n\tif override == \"true\" then\n\t\tpasswordManager.setPasswordByKey(entry)\n\telse\n\t\texit(\"Key already exists. Use override.\")\n\tend if\nelse\n\tpasswordManager.passwordList.push(entry)\nend if\n\nprint(\"Saving password...\")\npasswordManager.savePasswordFile()\n\n\n\n\n\n\nend function\nMAIN()",
        "ID": "2cb09836d37e66e28d811932623d175f",
        "refCount": 2
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(NEW_LINE_OPERATOR)\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\t\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\t\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\t\n\tcontent = stringList.join(NEW_LINE_OPERATOR)\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nkey = argv.get(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\npasswordManager.removePasswordByKey(existingEntry)\n\nprint(\"Removing password...\")\npasswordManager.savePasswordFile()\n\npasswordManager.parsePasswordFile()\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Removing was a success\")\nend if\n\nexit(\"Something went wrong\")\n\n\n\n\n\nend function\nMAIN()",
        "ID": "3eec9fc1573a507ef3c16f33786364e8",
        "refCount": 2
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(NEW_LINE_OPERATOR)\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\t\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\t\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\t\n\tcontent = stringList.join(NEW_LINE_OPERATOR)\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nlistIndex = to_int(argv.get(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.passwordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Entry: \" + passwordManager.passwordList[listIndex].toString())\n\n\n\n\n\n\nend function\nMAIN()",
        "ID": "46595f35baa1e60e01bf8d9b80b97405",
        "refCount": 2
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(NEW_LINE_OPERATOR)\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\t\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\t\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\t\n\tcontent = stringList.join(NEW_LINE_OPERATOR)\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nkey = argv.get(0, true)\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.findPasswordByKey(key)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Password: \" + existingEntry.password)\n\n\n\n\n\n\nend function\nMAIN()",
        "ID": "5eae33281053b4c03eeadfe0496424e7",
        "refCount": 2
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\n\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(NEW_LINE_OPERATOR)\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\t\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\t\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\t\n\tcontent = stringList.join(NEW_LINE_OPERATOR)\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\n\n\nMAIN = function()\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nfor value in passwordManager.passwordList.values\n\tprint(value.toString())\nend for\n\n\n\n\n\n\nend function\nMAIN()",
        "ID": "978df05b30a5b27699bf87d73432e97c",
        "refCount": 2
    },
    {
        "Content": "B9:E6:FB:E2:5E:E9/Iltona;Admin\n3E:69:4F:8A:72:23/Urylandelu;guinsid\nemail;adwe342Ef\n8C:9B:4C:7D:56:95/Gardi;steral\n61:0A:09:14:7A:7F/Ovelecti_QYR;Chelpme\nbank;coolbeans\nbanknumber;NjSmaRkn\n168.42.167.182;Archery\nNersteini;Elandom\nggg;ggg\ntest;3",
        "ID": "ddacacbc79bd10b278721888e987430c",
        "refCount": 1
    },
    {
        "Content": "s = get_shell\nc = s.host_computer\nh = home_dir\nprint(\"Create compiler folder...\")\nc.create_folder(h, \"compiler\")\nc.create_folder(h, \"tmp\")\nc.touch(h + \"/compiler\", \"compile.src\")\nc.create_folder(h + \"/compiler\", \"boilerplates\")\nc.touch(h + \"/compiler/boilerplates\", \"header.src\")\nc.touch(h + \"/compiler/boilerplates\", \"main.src\")\nc.touch(h + \"/compiler/boilerplates\", \"module.src\")\nprint(\"Create config file...\")\nc.touch(h + \"/Config\", \"compile.conf\")\nprint(\"Write config file...\")\nfile = c.File(h + \"/Config/compile.conf\")\nlines = []\nlines.push(\"COMMAND_START=#\")\nlines.push(\"SCRIPT_FOLDER=/home/$0/scripts\")\nlines.push(\"TEMP_FOLDER=/home/$0/tmp\")\nlines.push(\"COMPILER_FOLDER=/home/$0/compiler\")\nlines.push(\"BOILERPLATE_FOLDER=boilerplates/$0.src\")\nlines.push(\"BIN_FOLDER=/usr/bin\")\nlines.push(\"SCRIPT_EXTENSION=src\")\nlines.push(\"DEBUG=false\")\nlines.push(\"VERSION=0.1.1.0\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write compiler file...\")\nfile = c.File(h + \"/compiler/compile.src\")\nlines = []\nlines.push(\"BACKSLASH_CODE = 92\")\nlines.push(\"NEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"\"n\"\"\")\nlines.push(\"ARGV_OPERATOR = \"\"-\"\"\")\nlines.push(\"\")\nlines.push(\"Config = {}\")\nlines.push(\"\")\nlines.push(\"Config.load = function()\")\nlines.push(\"path = (new String).constructor(\"\"$0/Config/compile.conf\"\")\")\nlines.push(\"path = path.parse([home_dir]).toString()\")\nlines.push(\"file = get_shell.host_computer.File(path)\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"No config in $0...\"\", [path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"content = file.get_content\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"map = {}\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"def = line.split(\"\"=\"\")\")\nlines.push(\"name = def.pull()\")\nlines.push(\"value = def.pull()\")\nlines.push(\"map[name] = value\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.map = map\")\nlines.push(\"\")\nlines.push(\"return map\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.set = function(key, value)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\") and value != null) then\")\nlines.push(\"self.map[key] = value\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.get = function(key)\")\nlines.push(\"if (self.hasIndex(\"\"map\"\")) then\")\nlines.push(\"return self.map[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getScriptFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"SCRIPT_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getTempFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"TEMP_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getCompilerFolder = function()\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"COMPILER_FOLDER\"\"))\")\nlines.push(\"user = active_user\")\nlines.push(\"return path.parse([user]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getExtension = function()\")\nlines.push(\"return Config.get(\"\"SCRIPT_EXTENSION\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.isDebugMode = function()\")\nlines.push(\"value = Config.get(\"\"DEBUG\"\")\")\nlines.push(\"if (typeof(value) == \"\"string\"\") then\")\nlines.push(\"return value == \"\"true\"\"\")\nlines.push(\"end if\")\nlines.push(\"return value\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBoilerplateFile = function(boilerplate)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"path = (new String).constructor(Config.get(\"\"BOILERPLATE_FOLDER\"\"))\")\nlines.push(\"return pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.getBinFolder = function()\")\nlines.push(\"return Config.get(\"\"BIN_FOLDER\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"debug = function(msg)\")\nlines.push(\"if (Config.isDebugMode()) then\")\nlines.push(\"print(msg)\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String = {}\")\nlines.push(\"\")\nlines.push(\"String.constructor = function(str)\")\nlines.push(\"self.str = str\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.parse = function(values)\")\nlines.push(\"result = self.str\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = values.len\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"result = result.replace(\"\"$\"\"+index, values[index])\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return (new String).constructor(result)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.startsWith = function(str)\")\nlines.push(\"return self.str.indexOf(str) == 0\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.substr = function(startIndex, endIndex)\")\nlines.push(\"return (new String).constructor(slice(self.str, startIndex, endIndex))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.indexOf = function(str)\")\nlines.push(\"return self.str.indexOf(str)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.replace = function(str, newStr)\")\nlines.push(\"return (new String).constructor(self.str.replace(str, newStr))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.remove = function(str)\")\nlines.push(\"return (new String).constructor(self.str.remove(str))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.toString = function()\")\nlines.push(\"return self.str\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.length = function()\")\nlines.push(\"return self.str.len\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.split = function(seperator)\")\nlines.push(\"return self.str.split(seperator)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"String.trim = function(seperator)\")\nlines.push(\"return (new String).constructor(self.str.trim())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error = {}\")\nlines.push(\"\")\nlines.push(\"Error.constructor = function(message, values)\")\nlines.push(\"self.message = message\")\nlines.push(\"if (values != null) then\")\nlines.push(\"self.message = (new String.constructor(message)).parse(values).toString()\")\nlines.push(\"end if\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Error.throw = function()\")\nlines.push(\"exit(\"\"<color=#ff0000>\"\" + self.message + \"\"</color>\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ArgType = {}\")\nlines.push(\"\")\nlines.push(\"ArgType.FLAG = \"\"FLAG\"\"\")\nlines.push(\"ArgType.VALUE = \"\"VALUE\"\"\")\nlines.push(\"\")\nlines.push(\"Arg = {}\")\nlines.push(\"\")\nlines.push(\"Arg.constructor = function(shortcut, command, type, description)\")\nlines.push(\"self.shortcut = shortcut\")\nlines.push(\"self.command = command\")\nlines.push(\"self.type = type\")\nlines.push(\"self.description = description\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Arg.toString = function()\")\nlines.push(\"str = (new String).constructor(\"\"-$0 --$1 - <b>$2</b>\"\")\")\nlines.push(\"return str.parse([self.shortcut, self.command, self.description]).toString()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv = {}\")\nlines.push(\"\")\nlines.push(\"Argv.constructor = function(defs, help)\")\nlines.push(\"self.args = params\")\nlines.push(\"self.listed = {}\")\nlines.push(\"self.unlisted = []\")\nlines.push(\"self.defs = defs\")\nlines.push(\"self.help = help\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.parse = function()\")\nlines.push(\"args = self.args\")\nlines.push(\"defs = self.defs\")\nlines.push(\"listed = {}\")\nlines.push(\"unlisted = []\")\nlines.push(\"index = 0\")\nlines.push(\"maxIndex = args.len\")\nlines.push(\"findDef = function(arg)\")\nlines.push(\"for def in defs\")\nlines.push(\"if (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\")\nlines.push(\"return def\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"while index < maxIndex\")\nlines.push(\"item = args[index].trim()\")\nlines.push(\"def = findDef(item)\")\nlines.push(\"if (def == null) then\")\nlines.push(\"unlisted.push(item)\")\nlines.push(\"else\")\nlines.push(\"if (def.type == ArgType.VALUE) then\")\nlines.push(\"index = index + 1\")\nlines.push(\"value = args[index]\")\nlines.push(\"listed[def.command] = value\")\nlines.push(\"else if (def.type == ArgType.FLAG) then\")\nlines.push(\"listed[def.command] = true\")\nlines.push(\"end if\")\nlines.push(\"end if\")\nlines.push(\"index = index + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"self.listed = listed\")\nlines.push(\"self.unlisted = unlisted\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.get = function(index = 0, mandatory = false)\")\nlines.push(\"if self.unlisted.hasIndex(index) then\")\nlines.push(\"return self.unlisted[index]\")\nlines.push(\"end if\")\nlines.push(\"if mandatory then\")\nlines.push(\"(new Error).constructor(\"\"Error cannot find param[$0]$1$2$3\"\", [index, NEW_LINE_OPERATOR, NEW_LINE_OPERATOR, self.help]).throw()\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Argv.getWithKey = function(key)\")\nlines.push(\"if self.listed.hasIndex(key) then\")\nlines.push(\"return self.listed[key]\")\nlines.push(\"end if\")\nlines.push(\"return null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Math = {}\")\nlines.push(\"\")\nlines.push(\"Math.random = function(min, max)\")\nlines.push(\"return floor((rnd * max) + min)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator = {}\")\nlines.push(\"\")\nlines.push(\"IdGenerator.getChars = function()\")\nlines.push(\"return \"\"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\"\";\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"IdGenerator.get = function()\")\nlines.push(\"math = new Math\")\nlines.push(\"chars = self.getChars()\")\nlines.push(\"\")\nlines.push(\"result = []\")\nlines.push(\"indexA = 0\")\nlines.push(\"maxA = 4\")\nlines.push(\"\")\nlines.push(\"while indexA < maxA\")\nlines.push(\"indexB = 0\")\nlines.push(\"maxB = 5\")\nlines.push(\"code = \"\"\"\"\")\nlines.push(\"\")\nlines.push(\"while indexB < maxB\")\nlines.push(\"code = code + chars[math.random(0, chars.len - 1)]\")\nlines.push(\"\")\nlines.push(\"indexB = indexB + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"result.push(code)\")\nlines.push(\"\")\nlines.push(\"indexA = indexA + 1\")\nlines.push(\"end while\")\nlines.push(\"\")\nlines.push(\"return result.join(\"\"\"\")\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path = {}\")\nlines.push(\"\")\nlines.push(\"Path.resolve = function(a)\")\nlines.push(\"parts = a.split(\"\"/\"\")\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for part in parts\")\nlines.push(\"if (part == \"\"..\"\") then\")\nlines.push(\"result.pop()\")\nlines.push(\"else if (part != \"\"\"\" and part != \"\".\"\") then\")\nlines.push(\"result.push(part)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"resolved = result.join(\"\"/\"\")\")\nlines.push(\"\")\nlines.push(\"if (a.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"resolved = \"\"/\"\" + resolved\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return resolved\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Path.join = function(a, b)\")\nlines.push(\"if (b.indexOf(\"\"/\"\") == 0) then\")\nlines.push(\"b = b[1:]\")\nlines.push(\"end if\")\nlines.push(\"return Path.resolve([a, b].join(\"\"/\"\"))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS = {}\")\nlines.push(\"\")\nlines.push(\"FS.constructor = function(computer)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"FS.createFile = function(path, name)\")\nlines.push(\"self.computer.touch(path, name)\")\nlines.push(\"return self.computer.File(Path.join(path, name))\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTImportCommand.constructor = function(file)\")\nlines.push(\"self.file = file\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTCommand = {}\")\nlines.push(\"\")\nlines.push(\"ASTCommand.constructor = function(line, str, key, action)\")\nlines.push(\"self.line = line\")\nlines.push(\"self.str = str\")\nlines.push(\"self.key = key\")\nlines.push(\"self.action = action\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"ASTRegistry = {}\")\nlines.push(\"\")\nlines.push(\"ASTRegistry.import = ASTImportCommand\")\nlines.push(\"\")\nlines.push(\"AST = {}\")\nlines.push(\"\")\nlines.push(\"AST.constructor = function(computer, file)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.file = file\")\nlines.push(\"self.lines = []\")\nlines.push(\"self.commands = []\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.analyze = function()\")\nlines.push(\"debug(\"\"Analyzing AST...\"\")\")\nlines.push(\"content = self.file.get_content\")\nlines.push(\"commands = []\")\nlines.push(\"lines = content.split(NEW_LINE_OPERATOR)\")\nlines.push(\"index = 0\")\nlines.push(\"\")\nlines.push(\"for line in lines\")\nlines.push(\"str = (new String).constructor(line)\")\nlines.push(\"\")\nlines.push(\"if (str.startsWith(Config.get(\"\"COMMAND_START\"\"))) then\")\nlines.push(\"command = str.substr(1, str.indexOf(\"\" \"\"))\")\nlines.push(\"key = command.toString()\")\nlines.push(\"\")\nlines.push(\"if (ASTRegistry[key] == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid command $0 on line $1\"\", [key, index]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"action = ASTRegistry[key]\")\nlines.push(\"entry = (new ASTCommand).constructor(index, str, key, new action)\")\nlines.push(\"commands.push(entry)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"index = index + 1\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.lines = lines\")\nlines.push(\"self.commands = commands\")\nlines.push(\"\")\nlines.push(\"return commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.transform = function(line, code)\")\nlines.push(\"self.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\")\nlines.push(\"\")\nlines.push(\"return self.lines\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"AST.getCommands = function()\")\nlines.push(\"return self.commands\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency = {}\")\nlines.push(\"\")\nlines.push(\"Dependency.constructor = function(computer, file, ast)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = file\")\nlines.push(\"self.basePath = file.parent.path\")\nlines.push(\"self.ast = ast\")\nlines.push(\"self.dependencies = []\")\nlines.push(\"\")\nlines.push(\"if self.target == null then\")\nlines.push(\"(new Error).constructor(\"\"Dependency $0 does not exist...\"\", [file.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Dependency.findDependencies = function()\")\nlines.push(\"debug(\"\"Finding dependencies...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"commands = self.ast.getCommands()\")\nlines.push(\"result = []\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"path = command.str.substr(command.str.indexOf(\"\"from\"\") + 4, command.str.indexOf(\"\";\"\")).toString()\")\nlines.push(\"\")\nlines.push(\"if (path == null) then\")\nlines.push(\"(new Error).constructor(\"\"Invalid import on line $0 in $1...\"\", [command.line, self.target.path]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"filePath = pathHelper.join(self.basePath, path.trim() + \"\".\"\" + Config.getExtension())\")\nlines.push(\"file = self.computer.File(filePath)\")\nlines.push(\"debug(\"\"Looking for file in \"\" + filePath + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"if (file == null) then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find $0...\"\", [filePath]).throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"command.action.constructor(file)\")\nlines.push(\"\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"\")\nlines.push(\"result.push(dependency)\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"self.dependencies = result\")\nlines.push(\"\")\nlines.push(\"return result\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor = {}\")\nlines.push(\"\")\nlines.push(\"Preprocessor.constructor = function(computer, dependency)\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.dependency = dependency\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Preprocessor.run = function()\")\nlines.push(\"debug(\"\"Run preprocessor...\"\")\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"mainDependency = self.dependency\")\nlines.push(\"mainModuleName = md5(mainDependency.target.path)\")\nlines.push(\"headerBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"header\"\")).get_content\")\nlines.push(\"moduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"module\"\")).get_content\")\nlines.push(\"mainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"\"main\"\")).get_content\")\nlines.push(\"modules = {}\")\nlines.push(\"iterator = function(item)\")\nlines.push(\"moduleName = md5(item.target.path)\")\nlines.push(\"\")\nlines.push(\"if (modules.hasIndex(moduleName)) then\")\nlines.push(\"return\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"commands = item.ast.getCommands()\")\nlines.push(\"\")\nlines.push(\"for command in commands\")\nlines.push(\"if (command.key == \"\"import\"\") then\")\nlines.push(\"importIndex = command.str.indexOf(\"\"import\"\")\")\nlines.push(\"fromIndex = command.str.indexOf(\"\"from\"\")\")\nlines.push(\"defVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\")\nlines.push(\"defId = md5(command.action.file.path)\")\nlines.push(\"code = (new String).constructor(\"\"$0 = __REQUIRE(\"\"\"\"$1\"\"\"\")\"\").parse([defVar, defId])\")\nlines.push(\"\")\nlines.push(\"item.ast.transform(command.line, code.toString())\")\nlines.push(\"end if\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"if (moduleName != mainModuleName) then\")\nlines.push(\"transformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(moduleBoilerplate)\")\nlines.push(\"modules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for dependency in item.dependencies\")\nlines.push(\"iterator(dependency)\")\nlines.push(\"end for\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"iterator(mainDependency)\")\nlines.push(\"\")\nlines.push(\"processed = [headerBoilerplate]\")\nlines.push(\"\")\nlines.push(\"for module in modules.values\")\nlines.push(\"processed.push(module)\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"transformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\")\nlines.push(\"moduleCode = (new String).constructor(mainBoilerplate)\")\nlines.push(\"processed.push(moduleCode.parse([transformedCode]).toString())\")\nlines.push(\"\")\nlines.push(\"return processed.join(NEW_LINE_OPERATOR + NEW_LINE_OPERATOR)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler = {}\")\nlines.push(\"\")\nlines.push(\"Compiler.constructor = function(computer, name)\")\nlines.push(\"idGenerator = new IdGenerator\")\nlines.push(\"\")\nlines.push(\"self.buildId = idGenerator.get()\")\nlines.push(\"self.name = name\")\nlines.push(\"self.computer = computer\")\nlines.push(\"self.target = computer.File(self.getFullScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"return self\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.isTargetExisting = function()\")\nlines.push(\"return self.target != null\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getScriptFilePath = function()\")\nlines.push(\"return self.name + \"\".\"\" + Config.getExtension()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullScriptFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getScriptFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.getFullTempFilePath = function()\")\nlines.push(\"path = new Path\")\nlines.push(\"return path.join(Config.getTempFolder(), self.getScriptFilePath())\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.preprocess = function()\")\nlines.push(\"debug(\"\"Start processing...\"\")\")\nlines.push(\"file = self.computer.File(self.getFullScriptFilePath())\")\nlines.push(\"ast = (new AST).constructor(self.computer, file)\")\nlines.push(\"ast.analyze()\")\nlines.push(\"dependency = (new Dependency).constructor(self.computer, file, ast)\")\nlines.push(\"dependency.findDependencies()\")\nlines.push(\"preprocessor = (new Preprocessor).constructor(self.computer, dependency)\")\nlines.push(\"return preprocessor.run()\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Compiler.compile = function(shell)\")\nlines.push(\"pathHelper = new Path\")\nlines.push(\"fs = (new FS).constructor(self.computer)\")\nlines.push(\"buildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\")\nlines.push(\"buildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"self.computer.create_folder(Config.getTempFolder(), self.buildId)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Build id: \"\" + self.buildId)\")\nlines.push(\"\")\nlines.push(\"newFile = fs.createFile(buildPath, self.getScriptFilePath())\")\nlines.push(\"\")\nlines.push(\"if newFile == null then\")\nlines.push(\"exit(\"\"Unable to create file...\"\")\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = self.preprocess()\")\nlines.push(\"\")\nlines.push(\"newFile.set_content(content)\")\nlines.push(\"\")\nlines.push(\"print(\"\"Building in \"\" + Config.getBinFolder() + \"\"...\"\")\")\nlines.push(\"\")\nlines.push(\"buildReport = shell.build(buildPathFull, Config.getBinFolder())\")\nlines.push(\"\")\nlines.push(\"compiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\")\nlines.push(\"if self.computer.File(compiledBuildPathFull) == null then\")\nlines.push(\"(new Error).constructor(\"\"Built failed: $0\"\", [buildReport]).throw()\")\nlines.push(\"end if\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"main = function(name)\")\nlines.push(\"myShell = get_shell\")\nlines.push(\"myComputer = myShell.host_computer\")\nlines.push(\"\")\nlines.push(\"compiler = (new Compiler).constructor(myComputer, name)\")\nlines.push(\"\")\nlines.push(\"if compiler.isTargetExisting == false then\")\nlines.push(\"(new Error).constructor(\"\"Cannot find file.\"\").throw()\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"content = compiler.compile(myShell)\")\nlines.push(\"end function\")\nlines.push(\"\")\nlines.push(\"Config.load()\")\nlines.push(\"\")\nlines.push(\"argDefinitions = []\")\nlines.push(\"\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"h\"\", \"\"help\"\", ArgType.FLAG, \"\"Print help\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"d\"\", \"\"debug\"\", ArgType.FLAG, \"\"Activate debug mode\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"cs\"\", \"\"command-start\"\", ArgType.VALUE, \"\"Command starting operator\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"s\"\", \"\"script-folder\"\", ArgType.VALUE, \"\"Script folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"t\"\", \"\"temp-folder\"\", ArgType.VALUE, \"\"Temporary folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"c\"\", \"\"compiler-folder\"\", ArgType.VALUE, \"\"Compiler folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"b\"\", \"\"bin-folder\"\", ArgType.VALUE, \"\"Bin folder\"\"))\")\nlines.push(\"argDefinitions.push((new Arg).constructor(\"\"se\"\", \"\"script-extension\"\", ArgType.VALUE, \"\"Script extension\"\"))\")\nlines.push(\"\")\nlines.push(\"helpBlock = []\")\nlines.push(\"\")\nlines.push(\"helpBlock.push(\"\"Compiler CLI\"\")\")\nlines.push(\"helpBlock.push(\"\"Version: \"\" + Config.get(\"\"VERSION\"\"))\")\nlines.push(\"helpBlock.push(\"\"Example: <b>compile myscriptfile</b>\"\")\")\nlines.push(\"helpBlock.push(\"\"\"\")\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"helpBlock.push(argDefinition.toString())\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"help = helpBlock.join(NEW_LINE_OPERATOR)\")\nlines.push(\"\")\nlines.push(\"argv = (new Argv).constructor(argDefinitions, help)\")\nlines.push(\"\")\nlines.push(\"argv.parse()\")\nlines.push(\"\")\nlines.push(\"if (argv.getWithKey(\"\"help\"\") == true) then\")\nlines.push(\"exit(help)\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"for argDefinition in argDefinitions\")\nlines.push(\"key = argDefinition.command.upper.replace(\"\"-\"\", \"\"_\"\")\")\nlines.push(\"value = argv.getWithKey(argDefinition.command)\")\nlines.push(\"Config.set(key, value)\")\nlines.push(\"end for\")\nlines.push(\"\")\nlines.push(\"debug(\"\"Start compiling...\"\")\")\nlines.push(\"main(argv.get(0, true))\")\nlines.push(\"exit(\"\"Done compiling...\"\")\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates header file...\")\nfile = c.File(h + \"/compiler/boilerplates/header.src\")\nlines = []\nlines.push(\"BACKSLASH_CODE = 92\")\nlines.push(\"NEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"\"n\"\"\")\nlines.push(\"MODULES = {}\")\nlines.push(\"EXPORTED = {}\")\nlines.push(\"\")\nlines.push(\"__REQUIRE = function(r)\")\nlines.push(\"if (MODULES.hasIndex(r) == false) then\")\nlines.push(\"exit(\"\"Module \"\" + r + \"\" cannot be found...\"\")\")\nlines.push(\"end if\")\nlines.push(\"module = MODULES[r]\")\nlines.push(\"return module(r)\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates module file...\")\nfile = c.File(h + \"/compiler/boilerplates/module.src\")\nlines = []\nlines.push(\"MODULES[\"\"$0\"\"] = function(r)\")\nlines.push(\"module = {}\")\nlines.push(\"\")\nlines.push(\"if (EXPORTED.hasIndex(r)) then\")\nlines.push(\"module = EXPORTED[r]\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"if (module.hasIndex(\"\"exports\"\") == false) then\")\nlines.push(\"$1\")\nlines.push(\"end if\")\nlines.push(\"\")\nlines.push(\"EXPORTED[r] = module\")\nlines.push(\"\")\nlines.push(\"return module.exports\")\nlines.push(\"end function\")\nfile.set_content(lines.join(\"\\n\"))\nprint(\"Write boilerplates main file...\")\nfile = c.File(h + \"/compiler/boilerplates/main.src\")\nlines = []\nlines.push(\"MAIN = function()\")\nlines.push(\"$0\")\nlines.push(\"end function\")\nlines.push(\"MAIN()\")\nfile.set_content(lines.join(\"\\n\"))\n\n",
        "ID": "c9e89b1a2ad0b89739c912a5d1802aa9",
        "refCount": 2
    },
    {
        "Content": "COMMAND_START=#\nSCRIPT_FOLDER=/home/$0/scripts\nTEMP_FOLDER=/home/$0/tmp\nCOMPILER_FOLDER=/home/$0/compiler\nBOILERPLATE_FOLDER=boilerplates/$0.src\nBIN_FOLDER=/usr/bin\nSCRIPT_EXTENSION=src\nDEBUG=false\nVERSION=0.1.1.0",
        "ID": "e9af1c996174d3487f12889219839511",
        "refCount": 1
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nARGV_OPERATOR = \"-\"\n\nConfig = {}\n\nConfig.load = function()\npath = (new String).constructor(\"$0/Config/compile.conf\")\npath = path.parse([home_dir]).toString()\nfile = get_shell.host_computer.File(path)\nif (file == null) then\n(new Error).constructor(\"No config in $0...\", [path]).throw()\nend if\ncontent = file.get_content\nlines = content.split(NEW_LINE_OPERATOR)\nmap = {}\n\nfor line in lines\ndef = line.split(\"=\")\nname = def.pull()\nvalue = def.pull()\nmap[name] = value\nend for\n\nself.map = map\n\nreturn map\nend function\n\nConfig.set = function(key, value)\nif (self.hasIndex(\"map\") and value != null) then\nself.map[key] = value\nend if\nreturn self\nend function\n\nConfig.get = function(key)\nif (self.hasIndex(\"map\")) then\nreturn self.map[key]\nend if\nreturn null\nend function\n\nConfig.getScriptFolder = function()\npath = (new String).constructor(Config.get(\"SCRIPT_FOLDER\"))\nuser = active_user\nreturn path.parse([user]).toString()\nend function\n\nConfig.getTempFolder = function()\npath = (new String).constructor(Config.get(\"TEMP_FOLDER\"))\nuser = active_user\nreturn path.parse([user]).toString()\nend function\n\nConfig.getCompilerFolder = function()\npath = (new String).constructor(Config.get(\"COMPILER_FOLDER\"))\nuser = active_user\nreturn path.parse([user]).toString()\nend function\n\nConfig.getExtension = function()\nreturn Config.get(\"SCRIPT_EXTENSION\")\nend function\n\nConfig.isDebugMode = function()\nvalue = Config.get(\"DEBUG\")\nif (typeof(value) == \"string\") then\nreturn value == \"true\"\nend if\nreturn value\nend function\n\nConfig.getBoilerplateFile = function(boilerplate)\npathHelper = new Path\npath = (new String).constructor(Config.get(\"BOILERPLATE_FOLDER\"))\nreturn pathHelper.join(Config.getCompilerFolder(), path.parse([boilerplate]).toString())\nend function\n\nConfig.getBinFolder = function()\nreturn Config.get(\"BIN_FOLDER\")\nend function\n\ndebug = function(msg)\nif (Config.isDebugMode()) then\nprint(msg)\nend if\nend function\n\nString = {}\n\nString.constructor = function(str)\nself.str = str\nreturn self\nend function\n\nString.parse = function(values)\nresult = self.str\nindex = 0\nmaxIndex = values.len\n\nwhile index < maxIndex\nresult = result.replace(\"$\"+index, values[index])\nindex = index + 1\nend while\n\nreturn (new String).constructor(result)\nend function\n\nString.startsWith = function(str)\nreturn self.str.indexOf(str) == 0\nend function\n\nString.substr = function(startIndex, endIndex)\nreturn (new String).constructor(slice(self.str, startIndex, endIndex))\nend function\n\nString.indexOf = function(str)\nreturn self.str.indexOf(str)\nend function\n\nString.replace = function(str, newStr)\nreturn (new String).constructor(self.str.replace(str, newStr))\nend function\n\nString.remove = function(str)\nreturn (new String).constructor(self.str.remove(str))\nend function\n\nString.toString = function()\nreturn self.str\nend function\n\nString.length = function()\nreturn self.str.len\nend function\n\nString.split = function(seperator)\nreturn self.str.split(seperator)\nend function\n\nString.trim = function(seperator)\nreturn (new String).constructor(self.str.trim())\nend function\n\nError = {}\n\nError.constructor = function(message, values)\nself.message = message\nif (values != null) then\nself.message = (new String.constructor(message)).parse(values).toString()\nend if\nreturn self\nend function\n\nError.throw = function()\nexit(\"<color=#ff0000>\" + self.message + \"</color>\")\nend function\n\nArgType = {}\n\nArgType.FLAG = \"FLAG\"\nArgType.VALUE = \"VALUE\"\n\nArg = {}\n\nArg.constructor = function(shortcut, command, type, description)\nself.shortcut = shortcut\nself.command = command\nself.type = type\nself.description = description\nreturn self\nend function\n\nArg.toString = function()\nstr = (new String).constructor(\"-$0 --$1 - <b>$2</b>\")\nreturn str.parse([self.shortcut, self.command, self.description]).toString()\nend function\n\nArgv = {}\n\nArgv.constructor = function(defs, help)\nself.args = params\nself.listed = {}\nself.unlisted = []\nself.defs = defs\nself.help = help\nreturn self\nend function\n\nArgv.parse = function()\nargs = self.args\ndefs = self.defs\nlisted = {}\nunlisted = []\nindex = 0\nmaxIndex = args.len\nfindDef = function(arg)\nfor def in defs\nif (ARGV_OPERATOR + ARGV_OPERATOR + def.command == arg or ARGV_OPERATOR + def.shortcut == arg) then\nreturn def\nend if\nend for\nreturn null\nend function\n\nwhile index < maxIndex\nitem = args[index].trim()\ndef = findDef(item)\nif (def == null) then\nunlisted.push(item)\nelse\nif (def.type == ArgType.VALUE) then\nindex = index + 1\nvalue = args[index]\nlisted[def.command] = value\nelse if (def.type == ArgType.FLAG) then\nlisted[def.command] = true\nend if\nend if\nindex = index + 1\nend while\n\nself.listed = listed\nself.unlisted = unlisted\n\nreturn self\nend function\n\nArgv.get = function(index = 0, mandatory = false)\nif self.unlisted.hasIndex(index) then\nreturn self.unlisted[index]\nend if\nif mandatory then\n(new Error).constructor(\"Error cannot find param[$0]$1$2$3\", [index, NEW_LINE_OPERATOR, NEW_LINE_OPERATOR, self.help]).throw()\nend if\nreturn null\nend function\n\nArgv.getWithKey = function(key)\nif self.listed.hasIndex(key) then\nreturn self.listed[key]\nend if\nreturn null\nend function\n\nMath = {}\n\nMath.random = function(min, max)\nreturn floor((rnd * max) + min)\nend function\n\nIdGenerator = {}\n\nIdGenerator.getChars = function()\nreturn \"QWERTZUIOPASDFGHJKLYXCVBNMqwertzuiopasdfghjklyxcvbnm1234567890\";\nend function\n\nIdGenerator.get = function()\nmath = new Math\nchars = self.getChars()\n\nresult = []\nindexA = 0\nmaxA = 4\n\nwhile indexA < maxA\nindexB = 0\nmaxB = 5\ncode = \"\"\n\nwhile indexB < maxB\ncode = code + chars[math.random(0, chars.len - 1)]\n\nindexB = indexB + 1\nend while\n\nresult.push(code)\n\nindexA = indexA + 1\nend while\n\nreturn result.join(\"\")\nend function\n\nPath = {}\n\nPath.resolve = function(a)\nparts = a.split(\"/\")\nresult = []\n\nfor part in parts\nif (part == \"..\") then\nresult.pop()\nelse if (part != \"\" and part != \".\") then\nresult.push(part)\nend if\nend for\n\nresolved = result.join(\"/\")\n\nif (a.indexOf(\"/\") == 0) then\nresolved = \"/\" + resolved\nend if\n\nreturn resolved\nend function\n\nPath.join = function(a, b)\nif (b.indexOf(\"/\") == 0) then\nb = b[1:]\nend if\nreturn Path.resolve([a, b].join(\"/\"))\nend function\n\nFS = {}\n\nFS.constructor = function(computer)\nself.computer = computer\nreturn self\nend function\n\nFS.createFile = function(path, name)\nself.computer.touch(path, name)\nreturn self.computer.File(Path.join(path, name))\nend function\n\nASTImportCommand = {}\n\nASTImportCommand.constructor = function(file)\nself.file = file\nreturn self\nend function\n\nASTCommand = {}\n\nASTCommand.constructor = function(line, str, key, action)\nself.line = line\nself.str = str\nself.key = key\nself.action = action\nreturn self\nend function\n\nASTRegistry = {}\n\nASTRegistry.import = ASTImportCommand\n\nAST = {}\n\nAST.constructor = function(computer, file)\nself.computer = computer\nself.file = file\nself.lines = []\nself.commands = []\nreturn self\nend function\n\nAST.analyze = function()\ndebug(\"Analyzing AST...\")\ncontent = self.file.get_content\ncommands = []\nlines = content.split(NEW_LINE_OPERATOR)\nindex = 0\n\nfor line in lines\nstr = (new String).constructor(line)\n\nif (str.startsWith(Config.get(\"COMMAND_START\"))) then\ncommand = str.substr(1, str.indexOf(\" \"))\nkey = command.toString()\n\nif (ASTRegistry[key] == null) then\n(new Error).constructor(\"Invalid command $0 on line $1\", [key, index]).throw()\nend if\n\naction = ASTRegistry[key]\nentry = (new ASTCommand).constructor(index, str, key, new action)\ncommands.push(entry)\nend if\n\nindex = index + 1\nend for\n\nself.lines = lines\nself.commands = commands\n\nreturn commands\nend function\n\nAST.transform = function(line, code)\nself.lines = self.lines[0:line] + [code] + self.lines[line + 1:]\n\nreturn self.lines\nend function\n\nAST.getCommands = function()\nreturn self.commands\nend function\n\nDependency = {}\n\nDependency.constructor = function(computer, file, ast)\npathHelper = new Path\n\nself.computer = computer\nself.target = file\nself.basePath = file.parent.path\nself.ast = ast\nself.dependencies = []\n\nif self.target == null then\n(new Error).constructor(\"Dependency $0 does not exist...\", [file.path]).throw()\nend if\n\nreturn self\nend function\n\nDependency.findDependencies = function()\ndebug(\"Finding dependencies...\")\npathHelper = new Path\ncommands = self.ast.getCommands()\nresult = []\n\nfor command in commands\nif (command.key == \"import\") then\npath = command.str.substr(command.str.indexOf(\"from\") + 4, command.str.indexOf(\";\")).toString()\n\nif (path == null) then\n(new Error).constructor(\"Invalid import on line $0 in $1...\", [command.line, self.target.path]).throw()\nend if\n\nfilePath = pathHelper.join(self.basePath, path.trim() + \".\" + Config.getExtension())\nfile = self.computer.File(filePath)\ndebug(\"Looking for file in \" + filePath + \"...\")\n\nif (file == null) then\n(new Error).constructor(\"Cannot find $0...\", [filePath]).throw()\nend if\n\ncommand.action.constructor(file)\n\nast = (new AST).constructor(self.computer, file)\nast.analyze()\n\ndependency = (new Dependency).constructor(self.computer, file, ast)\ndependency.findDependencies()\n\nresult.push(dependency)\nend if\nend for\n\nself.dependencies = result\n\nreturn result\nend function\n\nPreprocessor = {}\n\nPreprocessor.constructor = function(computer, dependency)\nself.computer = computer\nself.dependency = dependency\nreturn self\nend function\n\nPreprocessor.run = function()\ndebug(\"Run preprocessor...\")\npathHelper = new Path\nmainDependency = self.dependency\nmainModuleName = md5(mainDependency.target.path)\nheaderBoilerplate = self.computer.File(Config.getBoilerplateFile(\"header\")).get_content\nmoduleBoilerplate = self.computer.File(Config.getBoilerplateFile(\"module\")).get_content\nmainBoilerplate = self.computer.File(Config.getBoilerplateFile(\"main\")).get_content\nmodules = {}\niterator = function(item)\nmoduleName = md5(item.target.path)\n\nif (modules.hasIndex(moduleName)) then\nreturn\nend if\n\ncommands = item.ast.getCommands()\n\nfor command in commands\nif (command.key == \"import\") then\nimportIndex = command.str.indexOf(\"import\")\nfromIndex = command.str.indexOf(\"from\")\ndefVar = command.str.substr(importIndex + 6, fromIndex).trim().toString()\ndefId = md5(command.action.file.path)\ncode = (new String).constructor(\"$0 = __REQUIRE(\"\"$1\"\")\").parse([defVar, defId])\n\nitem.ast.transform(command.line, code.toString())\nend if\nend for\n\nif (moduleName != mainModuleName) then\ntransformedCode = item.ast.lines.join(NEW_LINE_OPERATOR)\nmoduleCode = (new String).constructor(moduleBoilerplate)\nmodules[moduleName] = moduleCode.parse([moduleName, transformedCode]).toString()\nend if\n\nfor dependency in item.dependencies\niterator(dependency)\nend for\nend function\n\niterator(mainDependency)\n\nprocessed = [headerBoilerplate]\n\nfor module in modules.values\nprocessed.push(module)\nend for\n\ntransformedCode = mainDependency.ast.lines.join(NEW_LINE_OPERATOR)\nmoduleCode = (new String).constructor(mainBoilerplate)\nprocessed.push(moduleCode.parse([transformedCode]).toString())\n\nreturn processed.join(NEW_LINE_OPERATOR + NEW_LINE_OPERATOR)\nend function\n\nCompiler = {}\n\nCompiler.constructor = function(computer, name)\nidGenerator = new IdGenerator\n\nself.buildId = idGenerator.get()\nself.name = name\nself.computer = computer\nself.target = computer.File(self.getFullScriptFilePath())\n\nreturn self\nend function\n\nCompiler.isTargetExisting = function()\nreturn self.target != null\nend function\n\nCompiler.getScriptFilePath = function()\nreturn self.name + \".\" + Config.getExtension()\nend function\n\nCompiler.getFullScriptFilePath = function()\npath = new Path\nreturn path.join(Config.getScriptFolder(), self.getScriptFilePath())\nend function\n\nCompiler.getFullTempFilePath = function()\npath = new Path\nreturn path.join(Config.getTempFolder(), self.getScriptFilePath())\nend function\n\nCompiler.preprocess = function()\ndebug(\"Start processing...\")\nfile = self.computer.File(self.getFullScriptFilePath())\nast = (new AST).constructor(self.computer, file)\nast.analyze()\ndependency = (new Dependency).constructor(self.computer, file, ast)\ndependency.findDependencies()\npreprocessor = (new Preprocessor).constructor(self.computer, dependency)\nreturn preprocessor.run()\nend function\n\nCompiler.compile = function(shell)\npathHelper = new Path\nfs = (new FS).constructor(self.computer)\nbuildPath = pathHelper.join(Config.getTempFolder(), self.buildId)\nbuildPathFull = pathHelper.join(buildPath, self.getScriptFilePath())\n\nself.computer.create_folder(Config.getTempFolder(), self.buildId)\n\nprint(\"Build id: \" + self.buildId)\n\nnewFile = fs.createFile(buildPath, self.getScriptFilePath())\n\nif newFile == null then\nexit(\"Unable to create file...\")\nend if\n\ncontent = self.preprocess()\n\nnewFile.set_content(content)\n\nprint(\"Building in \" + Config.getBinFolder() + \"...\")\n\nbuildReport = shell.build(buildPathFull, Config.getBinFolder())\n\ncompiledBuildPathFull = pathHelper.join(Config.getBinFolder(), self.name)\nif self.computer.File(compiledBuildPathFull) == null then\n(new Error).constructor(\"Built failed: $0\", [buildReport]).throw()\nend if\nend function\n\nmain = function(name)\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\ncompiler = (new Compiler).constructor(myComputer, name)\n\nif compiler.isTargetExisting == false then\n(new Error).constructor(\"Cannot find file.\").throw()\nend if\n\ncontent = compiler.compile(myShell)\nend function\n\nConfig.load()\n\nargDefinitions = []\n\nargDefinitions.push((new Arg).constructor(\"h\", \"help\", ArgType.FLAG, \"Print help\"))\nargDefinitions.push((new Arg).constructor(\"d\", \"debug\", ArgType.FLAG, \"Activate debug mode\"))\nargDefinitions.push((new Arg).constructor(\"cs\", \"command-start\", ArgType.VALUE, \"Command starting operator\"))\nargDefinitions.push((new Arg).constructor(\"s\", \"script-folder\", ArgType.VALUE, \"Script folder\"))\nargDefinitions.push((new Arg).constructor(\"t\", \"temp-folder\", ArgType.VALUE, \"Temporary folder\"))\nargDefinitions.push((new Arg).constructor(\"c\", \"compiler-folder\", ArgType.VALUE, \"Compiler folder\"))\nargDefinitions.push((new Arg).constructor(\"b\", \"bin-folder\", ArgType.VALUE, \"Bin folder\"))\nargDefinitions.push((new Arg).constructor(\"se\", \"script-extension\", ArgType.VALUE, \"Script extension\"))\n\nhelpBlock = []\n\nhelpBlock.push(\"Compiler CLI\")\nhelpBlock.push(\"Version: \" + Config.get(\"VERSION\"))\nhelpBlock.push(\"Example: <b>compile myscriptfile</b>\")\nhelpBlock.push(\"\")\n\nfor argDefinition in argDefinitions\nhelpBlock.push(argDefinition.toString())\nend for\n\nhelp = helpBlock.join(NEW_LINE_OPERATOR)\n\nargv = (new Argv).constructor(argDefinitions, help)\n\nargv.parse()\n\nif (argv.getWithKey(\"help\") == true) then\nexit(help)\nend if\n\nfor argDefinition in argDefinitions\nkey = argDefinition.command.upper.replace(\"-\", \"_\")\nvalue = argv.getWithKey(argDefinition.command)\nConfig.set(key, value)\nend for\n\ndebug(\"Start compiling...\")\nmain(argv.get(0, true))\nexit(\"Done compiling...\")",
        "ID": "fc65e1d8d68e4c55a0e39ddc10de8707",
        "refCount": 2
    },
    {
        "Content": "BACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\nMODULES = {}\nEXPORTED = {}\n\n__REQUIRE = function(r)\nif (MODULES.hasIndex(r) == false) then\nexit(\"Module \" + r + \" cannot be found...\")\nend if\nmodule = MODULES[r]\nreturn module(r)\nend function\n\nMODULES[\"e7271365ae5a540f5b8c0ab55f091a40\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nArgv = {}\n\nArgv.get = function(index = 0, mandatory = false, helpMessage = null)\n\tif params.hasIndex(index) then\n\t\treturn params[index]\n\tend if\n\tif mandatory then\n\t\tif helpMessage != null then\n\t\t\tprint(helpMessage)\n\t\tend if\n\t\texit(\"Error cannot find param[\" + index + \"]\")\n\tend if\n\treturn null\nend function\n\nmodule.exports = Argv\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\nMODULES[\"5e7627680949f489a3be68c92ae95798\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nFS = __REQUIRE(\"7860ea6ce8df4be770a03a25b405a3c5\")\n\nPasswordEntry = {}\n\nPasswordEntry.constructor = function(key, password)\n\tself.key = key\n\tself.password = password\n\t\n\treturn self\nend function\n\nPasswordEntry.toString = function()\n\treturn [self.key, self.password].join(\";\")\nend function\n\nPasswordEntry.createPasswordEntryFromColumn = function(columnString)\n\tparsed = columnString.split(\";\")\n\treturn self.constructor(parsed[0], parsed[1])\nend function\n\nPasswordFile = {}\n\nPasswordFile.getFilename = function()\n\treturn \"passwords\"\nend function\n\nPasswordFile.load = function()\n\tpasswordFileName = self.getFilename()\n\tpasswordFile = self.computer.File(self.fullPath)\n\t\n\tif passwordFile == null then\n\t\tfs = new FS\n\t\tpasswordFile = fs.createFile(computer, self.basePath, passwordFileName)\n\tend if\n\t\n\tself.file = passwordFile\n\t\n\treturn passwordFile\nend function\n\nPasswordFile.constructor = function(computer)\n\tuser = active_user\n\tdirectory = \"/home\"\n\tpasswordFileName = self.getFilename()\n\t\n\tself.computer = computer\n\tself.basePath = [directory, user].join(\"/\")\n\tself.fullPath = [directory, user, passwordFileName].join(\"/\")\n\t\n\tself.load()\n\t\n\treturn self\nend function\n\nPasswordFileManager = {}\n\nPasswordFileManager.PasswordFile = PasswordFile\nPasswordFileManager.PasswordEntry = PasswordEntry\n\nPasswordFileManager.constructor = function(computer)\n\tpasswordFile = new self.PasswordFile\n\tpasswordFile.constructor(computer)\n\tself.file = passwordFile.file\n\tself.passwordList = self.parsePasswordFile()\n\treturn self\nend function\n\nPasswordFileManager.parsePasswordFile = function()\n\tcontent = self.file.get_content\n\tlist = content.split(NEW_LINE_OPERATOR)\n\t\n\tresult = []\n\tindex = 0\n\tmaxIndex = list.len\n\t\n\twhile index < maxIndex\n\t\titem = list[index]\n\t\t\n\t\tif item != \"\" then\n\t\t\tnewItem = new self.PasswordEntry\n\t\t\tnewItem = newItem.createPasswordEntryFromColumn(item)\n\t\t\tresult.push(newItem)\n\t\tend if\n\t\t\n\t\tindex = index + 1\n\tend while\n\t\n\treturn result\nend function\n\nPasswordFileManager.findPasswordByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn item\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.findPasswordIndexByKey = function(key)\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tif item.key == key then\n\t\t\treturn index\n\t\tend if\n\t\tindex = index + 1\n\tend while\n\t\n\treturn null\nend function\n\nPasswordFileManager.setPasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tafter = slice(self.passwordList, 1, max)\n\t\tself.passwordList = [passwordEntry] + after\n\t\treturn [passwordEntry] + after\n\telse if (index == max - 1) then\n\t\tbefore = slice(self.passwordList, 0, max - 1)\n\t\tself.passwordList = before + [passwordEntry]\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + [passwordEntry] + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.removePasswordByKey = function(passwordEntry)\n\tindex = self.findPasswordIndexByKey(passwordEntry.key)\n\tmax = self.passwordList.len\n\t\n\tif index == 0 then\n\t\tself.passwordList = slice(self.passwordList, 1, max)\n\telse if (index == max - 1) then\n\t\tself.passwordList = slice(self.passwordList, 0, max - 1)\n\telse\n\t\tbefore = slice(self.passwordList, 0, index)\n\t\tafter = slice(self.passwordList, index + 1, max)\n\t\tself.passwordList = before + after\n\tend if\n\t\n\treturn self.passwordList\nend function\n\nPasswordFileManager.savePasswordFile = function()\n\tstringList = []\n\tindex = 0\n\tmaxIndex = self.passwordList.len\n\t\n\twhile index < maxIndex\n\t\titem = self.passwordList[index]\n\t\tstringList.push(item.toString())\n\t\tindex = index + 1\n\tend while\n\t\n\tcontent = stringList.join(NEW_LINE_OPERATOR)\n\tself.file.set_content(content)\nend function\n\nmodule.exports = PasswordFileManager\n\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\nMODULES[\"7860ea6ce8df4be770a03a25b405a3c5\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = __REQUIRE(\"a5785c68bb2ca5fb727dcaa733f45e28\")\n\nFS = {}\n\nFS.constructor = function(computer)\n\tself.computer = computer\n\treturn self\nend function\n\nFS.createFile = function(pathString, name)\n\tpath = new Path\n\tself.computer.touch(pathString, name)\n\treturn self.openFile(path.join(pathString, name))\nend function\n\nFS.openFile = function(pathString)\n\treturn self.computer.File(pathString)\nend function\n\nFS.doesFileExist = function(pathString)\n\tfile = self.openFile(pathString)\n\treturn file != null\nend function\n\nFS.getFilesInFolder = function(pathString)\n\tparent = self.openFile(pathString)\n\t\n\tif parent.is_folder then\n\t\treturn parent.get_folders + parent.get_files\n\tend if\n\n\treturn null\nend function\n\nFS.getTreeIterator = function(file, collection, nameFilter)\n\tif nameFilter == null or file.name.indexOf(nameFilter) != null then\n\t\tcollection.push(file)\n\tend if\n\t\n\tif file.is_folder then\n\t\tentries = file.get_folders + file.get_files\n\t\n\t\tfor entry in entries\n\t\t\tself.getTreeIterator(entry, collection, nameFilter)\n\t\tend for\n\tend if\n\n\treturn collection\nend function\n\nFS.getTree = function(pathString, nameFilter)\n\tfile = pathString\n\t\n\tif typeof(pathString) == \"string\" then\n\t\tfile = self.openFile(pathString)\n\t\tif file == null then\n\t\t\treturn null\n\t\tend if\n\tend if\n\n\treturn self.getTreeIterator(file, [], nameFilter)\nend function \n\nmodule.exports = FS\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\nMODULES[\"a5785c68bb2ca5fb727dcaa733f45e28\"] = function(r)\nmodule = {}\n\nif (EXPORTED.hasIndex(r)) then\nmodule = EXPORTED[r]\nend if\n\nif (module.hasIndex(\"exports\") == false) then\nPath = {}\n\nPath.join = function(path, name)\n\treturn [path, name].join(\"/\")\nend function\n\nmodule.exports = Path\n\nend if\n\nEXPORTED[r] = module\n\nreturn module.exports\nend function\n\nMAIN = function()\nArgv = __REQUIRE(\"e7271365ae5a540f5b8c0ab55f091a40\")\nPasswordFileManager = __REQUIRE(\"5e7627680949f489a3be68c92ae95798\")\n\nargv = new Argv\n\nlistIndex = to_int(argv.get(0, true))\n\nmyShell = get_shell\nmyComputer = myShell.host_computer\n\npasswordManager = new PasswordFileManager\n\npasswordManager.constructor(myComputer)\n\nexistingEntry = passwordManager.passwordList.hasIndex(listIndex)\n\nif existingEntry == null then\n\texit(\"Cannot find entry\")\nend if\n\nprint(\"Entry: \" + passwordManager.passwordList[listIndex].toString())\n\n\n\n\n\n\nend function\nMAIN()",
        "ID": "fc3febc01f0d4e720a40b63fe8985862",
        "refCount": 3
    },
    {
        "Content": "{\"contentLog\":[{\"action\":4,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 05:32\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 05:48\",\"puerto\":0,\"file\":\"/usr/bin/scp\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 07:01\",\"puerto\":0,\"file\":\"/usr/bin/test\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 15:51\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/2H4e2wjn9mo82x4YDWlI\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/zCn7Sfu1ad9XpjHfdlra\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/dVLnnULKqKlzzGwzM7JG\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/5mFCmFNStJjeiIrOR9IT\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/XGMY3rnCGyFhwHhvO69s\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/kIcPaH7ByYeMmD3hM4eC\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/BR6xEQWKwj9UQtVDwJkf\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/zqa4JbmHC9BFrdGgAWIp\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Gh6RYVMXnhFPDnn6eWtG\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Ax5wYxdVJjWqPONmtup4\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/BtqhxFWgvKDPu2Nryryo\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/yERIfvQRM9w5qpmgYHjZ\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/l7o9t24Jy4UWvWACwLW8\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/F8GbmJk6ElPrcgncrTdx\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/3lYz3MOMMtFWFl1xkyOG\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/A7FQysGODB2BhJTrgl5M\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/OKuizOJRvTRl5Bp6tLxJ\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/SQDWdmX7fVZ9nlZ3Mhts\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/CAXOXOwKhO8C8fGOTz4g\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/vLNM8T3SLjznbO5QgThr\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/BRKzNlQSt7b3cnnEc5PH\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/TkjX3sE8Y3Gy4qGIRL4G\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/SAeKtbTXuZQ335SuogT9\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Uozn8lZNSAhk9vR3HMmZ\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/ijwG2Cm9GjiNG4IsffLx\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/2UPrdJrTgqGaUTV3iZnp\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/wyU7MBpGekrVkg3szglO\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/bnqqEjEysi1EwCSI9DTH\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/hGs7723wAxB3ChcsYh4l\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Xnd4mw4CrxdLprwoFerA\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/vap1A8hxpobLKC41sjUz\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/7u7MITL1GDNmDy5lHxl2\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/xOc46YQGpa6zC8DJdAlU\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/gnuVA8UiMAam7GybyReb\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/RTKdH2rGufZZEdD6sNl8\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/DwbN9UiIFNzpj5Eau4IL\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/r2WcTzbXWbDCXtasH3fP\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/YVQIIzBUasNjKqrXqEYe\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/KFZNSAHDYqXdH78I13fo\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/IkyMMtR3QJAFpA2UJs67\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/JSvPJxwYwVeuNxXprh9j\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/ICSRHIRZZ2mH7hK64pOf\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/RlqfvdbnnLsasHn59l4O\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/kCGpuDpkeNg4uCdB4iHs\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:05\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/LGHvHGdk1V7ShQ6jt1Ua\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:37\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/RUCqdkRJswQqrKneUwXK\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"13-1-1990 16:37\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/test\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"14-1-1990 11:23\",\"puerto\":0,\"file\":\"/home/ayecue/scripts/mmm.src\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"14-1-1990 15:04\",\"puerto\":0,\"file\":\"/home/ayecue/scripts/mmm.src\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"14-1-1990 15:10\",\"puerto\":0,\"file\":\"/home/ayecue/scripts/mmm.src\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"14-1-1990 15:11\",\"puerto\":0,\"file\":\"/home/ayecue/scripts/mmm.src\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"14-1-1990 15:24\",\"puerto\":0,\"file\":\"/home/ayecue/scripts/mmm.src\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"14-1-1990 15:57\",\"puerto\":0,\"file\":\"/home/ayecue/scripts/mmm.src\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"14-1-1990 17:43\",\"puerto\":0,\"file\":\"/usr/bin/createscript\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"14-1-1990 18:29\",\"puerto\":0,\"file\":\"/home/ayecue/scripts/mmm.src\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"112.58.71.88\",\"fecha\":\"22-1-1990 03:31\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"112.58.71.88\",\"fecha\":\"22-1-1990 11:01\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"168.42.167.182\",\"playerNetID\":\"ce06cb61-8cf1-458f-adc8-a597358fd640\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"25-1-1990 03:21\",\"puerto\":0,\"file\":\"/usr/bin/testingmaps\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"31-1-1990 12:06\",\"puerto\":0,\"file\":\"/usr/bin/testclasses\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/p21ZweGuM53RqgoD2bPi\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/AVZNCzkNAeaRznQSHJ9A\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/rumho79bkdpKKvUDcwl5\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/xnC6XmusfB6sn9RfzMmN\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/z3hu2LxlkbNbuRNfA4Ck\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/MBAYj8eLlehVaXM1PnRW\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Zb3m8OTcpMesRI8IlCn4\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/mwQHIEDDdutCmYdsrYCo\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/3jlY9TLeCKOv9PAdvfk5\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/52OE4IcyrVdNQJWPljHR\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/ylmCNkCjOQbmsMdQihN2\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Ko88flckIW4UBgSDWcfD\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/xZarivvpfQaEKVxAy2jg\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/5doIZkw7Fq9cWDUD7rq1\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/6DTIM1bW3WwPZ8KOzeNm\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/XmVDWnWZHiDHqmlliwkF\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/3qRD9nhE58hrZpzUn2Zp\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/mlxXbSkHHipTxA74cPFS\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/O8AK2kA1Yd3hCIBPglNv\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/UqvVNal4saYhf3q2ireZ\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/W15sg3lfvbGRxqZkAb2J\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/sNxJ4E68ZfMslqFkGQRY\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/KDdNzndPHWuU9ZLDIsdn\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/fDdwwYxVPRnESDGNcCyZ\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/MvkRULdfIWasBFgZoA6D\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/RJ9DDt4v13Mx2uM1roXP\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/jIGIeDg7uOmaNiWPbz1s\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/NncGsmymbba9mvz5W1l9\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/m7JlRbCYzJE8kky1C9zd\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/VV3UH9eHR6V8VcvzjbiO\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/brKYCX4d5VUPc7AocYwI\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:19\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/oPcIqEbxoAq71ds2Zpx5\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/TnXjmFSNaGyBVMpfkA3L\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/zPRx5OKOXLeDozRlbTJF\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/mNPXMEawR8A5hwM5xpcj\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/5RRLxunmV1nd3hwIQlX2\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/imZVIizUUI7GLoKvXmo2\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/FyTDOuWQQK4EH3PZ8jAD\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/WlyG3aXYBfcPAwgvx3Fa\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/ztZbF58NMDnfgC1tQmLi\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/SkdCzy1bGCYZepjzd5W8\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/d54AnIrbpPv5phNb2yKe\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/RAAT3lAZgX1TnX5HvwzB\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/JRFTiNtcA2f3di4wxnKZ\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/7BPGLlZHxPQqF4DQ6Zzt\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/GB5vj8qJqet8Pqq238cn\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/LHWW1FhlC3zgYv1oeCiX\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/KnbLfEJveXU7YhS8V46r\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Kj5u6nfVo2NuqwurqlVb\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/63HWciCda2SiMREa3KCn\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/N4Fa5pu2PkifiIuNq4xB\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/rQxhhmIVN6pPVuNEggZD\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Wer3XiQKudP9u7CBPu4T\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/wPeDOBJQlrlcbiVQu2XO\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/mnmcvpdNAW3OyWy2QJy6\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/J9oE3VS8aCmJScGdYjMo\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/x2njaaWcbr9JIN1mHv2M\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/BgbnAs67vIiYmASNP2wL\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/XMPUCpPv4BVubQSURQz8\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/gT9h5hM6DejBXpT8tjra\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/eOEMxWtm9ZXPCrdJMrAg\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/PDawh8SG5DsCz5zzWp54\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Sp7IIuEm6viQunqJialc\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/nH4cr8fq8UHmiJepGrXP\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/6CLIganjrG8qmOT6gAdO\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/3a2nijeHC1WTJpmr6cI3\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/O67lOnQNDu5TmSHXerp7\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/IoXdF4AJLp92Ey96fOjk\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/jRRb56GTYzQeDAxpsXtF\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/glUsiEEZSYhXv1HRzujK\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/hZ6couh19MXYdeR87wJ3\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/4O3QnhgX5jRZdFupcYEW\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/VAZx8VjXbKURHbVuS663\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/1C6KCHjM5rSdNGuyEIWe\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/9XudaQnnmQBmBPAQFbNl\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/hJNYUegWKdrR4e3zbYhC\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/q2o5UCHHTzuGlLvk6DuO\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/CvuDzY54JfS3IEKvjrFy\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/FN6cUHXagApsciQdXCMv\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/MX8qYdUhQ9Qe9c461xUH\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/8YGZRpIoEgeXRqX2qzwr\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/OgpgPIsQfTcoHPbZZ3Vy\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/zifCuhNowWtXLsIYlp56\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/7U5733Z4sGvuPk8aQGOr\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/kRisoqJdWtVz7McNshed\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/pr6DG8SafzLtqwG4oYBw\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/dw2I2Kpl6p9Yxt3FUXBa\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Gg8zS1TzS1nLLQQOsnX7\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/BegTu8l6iQbF5vF7eV5Q\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/DTiTyhWxtxsJQqDcQ48D\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/OO7SRsVzvEgG3XyY5pXm\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/78qcBuDtpw7oBl2TUVQI\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Yz8wZVBhh21MoIHPjAvu\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/N15XZU1AwhFooFuqQ8jQ\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Punjau9JrkV5orkwadV9\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/zFF9gK1CpbPlrvB1EFyo\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/UphyYL9ZtZmBsjr5YnEL\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/hfhhofqxZmNV3b25urhV\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Lxmt7cUcLwiFAq3e4QAh\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/1F9gjrrbbiNmPhQ4vAlv\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/ugefLSSw4MWuL9tTxSbe\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/KL7yRkTtq8glKBPDxCVz\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/KE3Nu1uPA6PsVHtFjlpp\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/UjQ6xKH4mLLNnLSGMoDS\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 14:20\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/ssL1dyvTRHvIzNMSVzIk\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 17:30\",\"puerto\":0,\"file\":\"/usr/bin/testingclass\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 17:31\",\"puerto\":0,\"file\":\"/usr/bin/testingfunctions\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 17:33\",\"puerto\":0,\"file\":\"/usr/bin/testingmappings\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 17:34\",\"puerto\":0,\"file\":\"/usr/bin/testingmaps\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 17:35\",\"puerto\":0,\"file\":\"/usr/bin/testingstrings\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 18:35\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/5FW4vJfE3pFe67pide2T\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 18:35\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/HK8dIBzVVFGzm4YNpBRC\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 18:35\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/ZyArEXSon1o4fEefGNvM\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 20:21\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/kP5f3YzIR7uyb9FblSWE\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 20:21\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/mnp7Qcfy6AwsVGTEE3aX\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 20:21\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/byyrOMVaqcZ1eZt2p7fI\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 20:21\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/gxS3t5Vp4AcmphFZTZba\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-3-1990 21:34\",\"puerto\":0,\"file\":\"/usr/bin/getaccess\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 10:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/NRLPTpOKyDeTHrgEo19F\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 10:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/EvhJQGKc1MbrOEkseWb4\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 10:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/LCMXB86FcRpiRZq677iY\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 10:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/fSch3aBirZHM18aqgtYl\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 10:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/yVY7s8PQPsgNrmAIpywv\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 10:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/pNyhbPhTrQKwdnoK1bT4\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 10:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/qVB1qm5Wvrm4RzOCdfPw\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 11:46\",\"puerto\":0,\"file\":\"/home/ayecue/file.cap\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 14:50\",\"puerto\":0,\"file\":\"/usr/bin/getaccess\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 15:31\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/LTuOYDxgJ3JchuVDQ2G7\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 15:31\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/FgK9AVBIhFfDfsaCmGuG\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 15:31\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/TJy3FTFzP6XxNSFfvu86\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 15:31\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/bf9RHRIT6WVcXQ374BcZ\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 15:31\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/P27y32vwB7iLJaMMKjfP\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 15:31\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/6PpOoiMNLJyNx2v6jGPV\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 17:09\",\"puerto\":0,\"file\":\"/home/ayecue/file.cap\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 18:01\",\"puerto\":0,\"file\":\"/usr/bin/compile\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 18:02\",\"puerto\":0,\"file\":\"/usr/bin/compilev2\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 18:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Hgh8eTzypegDysP9KnAX\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 18:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/eNPIFPiBvrlEuJ4Jesgt\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 18:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/tgx2tLLvSHEbVknUnkGt\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 18:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/y6RgoiyqWU5NJX4ByEbZ\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 18:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/iFxPoJy5zsT8iF3iaUL7\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 18:45\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/i1xZXfuEbwVv4P7zA4ZL\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 19:56\",\"puerto\":0,\"file\":\"/usr/bin/getaccess\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 20:01\",\"puerto\":0,\"file\":\"/usr/bin/getaccess\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-3-1990 20:15\",\"puerto\":0,\"file\":\"/home/ayecue/compiler/file.cap\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"24-3-1990 17:16\",\"puerto\":0,\"file\":\"/home/ayecue/file.cap\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"24-3-1990 17:18\",\"puerto\":0,\"file\":\"/usr/bin/getaccess\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"24-3-1990 17:25\",\"puerto\":0,\"file\":\"/usr/bin/getaccess\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"24-3-1990 17:32\",\"puerto\":0,\"file\":\"/home/ayecue/file.cap\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"19-4-1990 20:34\",\"puerto\":0,\"file\":\"/home/ayecue/compiler/file.cap\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 17:00\",\"puerto\":0,\"file\":\"/home/ayecue/getaccess\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 22:19\",\"puerto\":0,\"file\":\"/usr/bin/getaccess\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:28\",\"puerto\":0,\"file\":\"/home/ayecue/compiler/file.cap\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:33\",\"puerto\":0,\"file\":\"/usr/bin/getaccess\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/vn5MW6mRqCcdl1uhegn5\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/yjUTGKTNJBBjQQPk6CRB\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/brawglRRsJRzTPoZk1Ay\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/2qvE8ZskjnlUaqIHUfNz\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/FWv9X1s1wRQZAYzVjoro\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/UCCvi64fEL9Twgu1dvkU\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/WMrH9gjvyRv6EiBXGtNs\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/EWHOeIuuGpB6PZ2pOrLT\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/xU1D1Gpv5vHwl7m9ACc2\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/ulaqX5FSH2NcjM5pikz9\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/wdIUatHNU4mURiXNoIny\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/fajbNMRcNJVwuKc4stnm\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/gnZXELlPZuQq2xCm5LjA\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:36\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/qr9nuBoxxqvTK9TnzVcU\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:37\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/j4j2H6oc668LvgNSnJvf\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"22-4-1990 23:37\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/l7Bfl6O3hzXouprucIoa\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-4-1990 16:35\",\"puerto\":0,\"file\":\"/usr/bin/compile\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-4-1990 16:36\",\"puerto\":0,\"file\":\"/usr/bin/getaccess\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"23-4-1990 16:42\",\"puerto\":0,\"file\":\"/home/ayecue/compiler/file.cap\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"24-4-1990 20:40\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/nvnnerKdp39GoOByzEOY\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"24-4-1990 20:40\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/vhZMaMcDA2MkjDn6OoSH\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"24-4-1990 20:40\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/NSnf4ih3737URNBmwTDk\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"24-4-1990 20:40\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/Vx1FZPLOKiDKQmjbhukn\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"24-4-1990 20:43\",\"puerto\":0,\"file\":\"/usr/bin/savepassword\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"24-4-1990 21:45\",\"puerto\":0,\"file\":\"/home/ayecue/scripts/library/password-manager\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"25-4-1990 03:50\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/PveH6wqslgw7zDXXlKFc\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"25-4-1990 03:50\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/xHs2rgzbx2E2xlmpLaKf\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"25-4-1990 03:50\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/kjMsUGcvtVZBY6T4SacJ\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"25-4-1990 03:50\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/5sm1spDvVxWI9oTRm9xG\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"25-4-1990 03:50\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/WL8PpE8HXLGVMGshWoj8\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"25-4-1990 03:50\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/9DmcNsoNZbLCsrIIQFxP\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"28-4-1990 19:24\",\"puerto\":0,\"file\":\"/usr/bin/installer\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"28-4-1990 20:41\",\"puerto\":0,\"file\":\"/usr/bin/getaccess\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"28-4-1990 21:37\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/mufqLj36NemCV3ZnwDy7\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"28-4-1990 21:37\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/eoPzQ2y5UtgbviIwoMek\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"28-4-1990 21:37\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/ldQs869lNLgbevjJBIMq\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"28-4-1990 21:37\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/68n4bWobxdHWyEGmouiT\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 00:06\",\"puerto\":0,\"file\":\"/home/ayecue/file.cap\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 07:33\",\"puerto\":0,\"file\":\"/usr/bin/savepassword\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 08:09\",\"puerto\":0,\"file\":\"/usr/bin/getpassword\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 08:26\",\"puerto\":0,\"file\":\"/usr/bin/removepassword\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 08:48\",\"puerto\":0,\"file\":\"/usr/bin/getpasswordbyindex\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:13\",\"puerto\":0,\"file\":\"/usr/bin/getpasswordall\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:43\",\"puerto\":0,\"file\":\"/usr/bin/prunefolder\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/2Wzbn1X9mmTwQWxxvZb6\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/BA7cEdRqo1j1oCi4wQT6\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/jo85obWkJrEekahjTycD\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/v4q9OD2frmLcW1HnDEFF\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/aCPZbGO7gmmkG1PvO8cC\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/6BGqAHwmC1tEuoaqyXA4\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/R48dQaiPkehFH1KFIl4o\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/cLsbCvAhHkEvb1KWNaMp\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/kKI3AJvgJBYQMsIxLAKF\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/M24QM3MBpHbzYXmtAkdT\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/QzN2BEVDlzlGYDPmBIeK\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 09:46\",\"puerto\":0,\"file\":\"/home/ayecue/tmp/1NZWovjZxsapuDF4eWsB\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 10:00\",\"puerto\":0,\"file\":\"/usr/bin/scan\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false},{\"action\":3,\"ip\":\"112.58.71.88\",\"fecha\":\"29-4-1990 16:19\",\"puerto\":0,\"file\":\"/usr/bin/getpasswordbyindex\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "4d90bfcbbf46ed32e3eeccad5db8db93",
        "refCount": 1
    },
    {
        "Content": "root:4fac9cbfeceeacdc4fe8be03c79527e8\n",
        "ID": "f859d097bdc3ecab28ab37d4a048e14c",
        "refCount": 1
    },
    {
        "Content": "root:xxxx\nkpl:xxxx",
        "ID": "26be2e84b99fbb73a7c73e28b2d843e6",
        "refCount": 1
    },
    {
        "Content": "Wifi access:\n----------\n\nCB:EF:EE:CC:49:3F\nNoiservi\nPassword: uventers",
        "ID": "ce1cb3c1267ca3a89f0f4ca36ec7d6f1",
        "refCount": 1
    },
    {
        "Content": "root:110450282d8e8466fab3f8555d7631a2\nErdamothr:379607936d36781ae4b9d188145148c5\nApuris:65f185ec6bd47af8f082f8196d0b4d24\nNerji:2bb646fe4d60c0d1353e0cdc0343491a\n",
        "ID": "8b3b524ae37df1aa849f154191d6e89e",
        "refCount": 1
    },
    {
        "Content": "Erdamothr@avent.net:555c6551237c7f257f5f024647171973",
        "ID": "3aa3261c36f882625bba87ce0765a24b",
        "refCount": 1
    },
    {
        "Content": "tJMshVnM:803ead698c4ab254352f64afce1cb972",
        "ID": "a547f5b0ce1737834b3e1ae19d2a9ac8",
        "refCount": 1
    },
    {
        "Content": "Apuris@centur.info:0eb3a1bb0111c036d7b5ffe008c5aebe",
        "ID": "d57824e4b246b26fd8594efff81f6885",
        "refCount": 1
    },
    {
        "Content": "TlqTz55o:12f97de861684a95495e15db8c6089a8",
        "ID": "5ee492e2e7814679e51ca65fed58bd74",
        "refCount": 1
    },
    {
        "Content": "Nerji@facebe.info:cd156f874c66dc970999278e61ac3b7c",
        "ID": "fc7f8e347554ae49af1f257257887421",
        "refCount": 1
    },
    {
        "Content": "vFE7SdRf:12ac2b34b13f38a68668c8313d60531a",
        "ID": "c9a19169a22fc875567c83a42693363e",
        "refCount": 1
    },
    {
        "Content": "<!DOCTYPE html>\n<style type='text/css'>\n\n  h1 { font-size: 40px; text-align: center}\n  body { font: 12px Helvetica, sans-serif; color: #333; margin:0; overflow-y:auto; height:100%; }\n  .btn {\n    background-color: #444444FF;\n    border: 1px solid #B2B2B2FF;\n    color: #C1C1C1FF;\n    padding: 8px 8px;\n    font-size: 18;    \n    width: 130px;\n  }\n  .btn-group button:hover {\n    background-color: #690000FF;\n  }\n\n  article { display: block; text-align: left; width: 600px; margin: 0 auto; } \n\n  html{\n    background-color: white;\n    height:100%;\n  }\n  .mainText{\n    text-align: center;\n    padding: 10px;\n  }\n\n  .logo{\n    text-align: right;    \n    position: absolute;\n    right: 10px;\n    font-size: 25px;\n    \n  }\n  img{\n    display: block;\n    margin: 0 auto;\n  }\n</style>\n\n</div>\n<div style=\"background-color:#A92222FF;color:white;padding:11px;\">\n  <div class=\"logo\">Worth</div>\n<div class=\"btn-group\">\n  <button type=\"button\" class=\"btn btn-primary\" id=\"Home\">Main</button>\n  <button type=\"button\" class=\"btn btn-primary\" id=\"RegisterMail\">Email services</button>\n  <button type=\"button\" class=\"btn btn-primary\">News</button>    \n  \n</div>\n\n</div>\n\n<article>\n    <div class=\"mainText\">    \n        <p>\nDo not have an email account? Do you live in the past?<br><br>\nLuckily at Worth, we offer you a reliable and secure mail service.<br>Register for free now!\n    </p>\n           <img src=\"email_alter.png\" width=\"85\" height=\"85\" align=\"center\">\n    </div> \n</article>\n",
        "ID": "4f7b4e97d6fce70e102eece084658b6c",
        "refCount": 1
    },
    {
        "Content": "worth.org",
        "ID": "9a84670d248bec7db52b58f7f629d2b1",
        "refCount": 1
    },
    {
        "Content": "<?xml version=\"1.0\" encoding=\"utf-16\"?>\n<ContentFichas xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>933862162</telefono>\n    <mailAddress>Merkler@holasterna.com</mailAddress>\n    <faceParts>Hombre/Base_c;Hombre/Ears_b;Hombre/Eyes_b;Hombre/Hair_a;Hombre/Nose_d;Hombre/Mouth_d;Hombre/Neck_d;Accesorios/earing2;Accesorios/piercing2;Accesorios/goat</faceParts>\n    <faceScales>0.9555514,0.9922295,0,0;0.9555514,1.139258,0,0;1.074797,0.9198112,0,0.30652;0.9555514,0.963625,0,0;0.7774619,0.8645005,0,-0.682833;0.8685611,0.9977252,0,-0.1445955;0.9555514,1,0,0;0.9555514,1.139258,-0.75,0;0.9555514,0.9922295,0,0;0.9555514,0.9922295,0,0</faceScales>\n    <nombreCompleto>Ade Merkler</nombreCompleto>\n    <edad>24</edad>\n    <horario>10:30 - 17:00</horario>\n    <idPersona>922be3a7-3eec-4913-a4a2-74a51a2ccc87</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>469524224</telefono>\n    <mailAddress>Erdamothr@avent.net</mailAddress>\n    <faceParts>Mujer/Base_b;Mujer/Ears_c;Mujer/Eyes_c;Mujer/Hair_b;Mujer/Nose_c;Mujer/Mouth_c;Mujer/Neck_b;Accesorios/piercing2</faceParts>\n    <faceScales>-0.9945138,0.963143,0,0;-0.9945138,1.176151,0,0;-0.9756142,0.9321768,0,0.523975;-0.9945138,0.9759588,0,0;-1.07333,0.9448584,0,-0.4532837;-0.7798712,0.8604947,0,-2.9685;-0.9945138,1,0,0;-0.9945138,0.963143,0,0</faceScales>\n    <nombreCompleto>Alysia Erdamothr</nombreCompleto>\n    <edad>44</edad>\n    <horario>09:30 - 16:00</horario>\n    <idPersona>2a03a174-3b13-471e-8df8-eaa089e8a9bf</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>957224928</telefono>\n    <mailAddress>Apuris@centur.info</mailAddress>\n    <faceParts>Mujer/Base_a;Mujer/Ears_c;Mujer/Eyes_b;Mujer/Hair_a;Mujer/Nose_c;Mujer/Mouth_b;Mujer/Neck_b</faceParts>\n    <faceScales>1.035807,0.9809403,0,0;1.035807,0.9537463,0,0;0.8591206,0.9717385,0,0.3410756;1.035807,0.9695893,0,0;0.9761539,1.065938,0,0.1892005;1.052764,0.9954476,0,-1.601632;1.035807,1,0,0</faceScales>\n    <nombreCompleto>Beverie Apuris</nombreCompleto>\n    <edad>67</edad>\n    <horario>07:15 - 13:45</horario>\n    <idPersona>68214bcf-d489-4e2c-beec-449f47dfccf1</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>871748882</telefono>\n    <mailAddress>Nerji@facebe.info</mailAddress>\n    <faceParts>Mujer/Base_a;Mujer/Ears_c;Mujer/Eyes_b;Mujer/Hair_a;Mujer/Nose_a;Mujer/Mouth_a;Mujer/Neck_a;Accesorios/piercing2;Accesorios/earing</faceParts>\n    <faceScales>-0.9436904,1.036565,0,0;-0.9436904,0.9499246,0,0;-0.9979382,0.8586333,0,-0.1779145;-0.9436904,0.9659944,0,0;-0.7622175,1.064649,0,-0.6125369;-0.8951827,0.8875659,0,-0.0165866;-0.9436904,1,0,0;-0.9436904,1.036565,0,0;-0.9436904,0.9499246,0.75,0</faceScales>\n    <nombreCompleto>Damara Nerji</nombreCompleto>\n    <edad>52</edad>\n    <horario>08:30 - 15:00</horario>\n    <idPersona>30cb9a95-affb-41c1-adac-05a8b59e4395</idPersona>\n    <incidencias />\n  </Ficha>\n</ContentFichas>",
        "ID": "b8e2489351dd7516fc7a08b546c23865",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"220.237.180.175\",\"fecha\":\"29-4-1990 21:41\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "d60b76ab5f55f057efcb303744e96067",
        "refCount": 1
    },
    {
        "Content": "root:5f6eb0809f31e88067e51bfd2bb0c50e\n",
        "ID": "6b4d746e670eeb5b558b167dd5fe1a04",
        "refCount": 1
    },
    {
        "Content": "root:de11fcbb52f27ff5e3af6291a7138db0\n",
        "ID": "3bfb79fca34791d20128df525fa9b23a",
        "refCount": 1
    },
    {
        "Content": "root:de11fcbb52f27ff5e3af6291a7138db0\nKristia:3c3ddf33e22db00b33961565865d1bac\nGarnered:a7cc8b1fa0f66e8adafcf130eb5ed732\nElyan:56ab5ccd1e7d671a666d65ba2212666f\n",
        "ID": "ed85d42e99060364bd4808e416e464d3",
        "refCount": 2
    },
    {
        "Content": "root:632bc4e9109504f2b81c361a09233f6b\nRanton:3bd923ee450d684a2b8cfea8b5d21d21\nAlentina:83cc8381c1d0a2dfe29d20559397686c\nAshingru:9be2ad2b77408de37e0777eb4269b751\n",
        "ID": "bdd757e3333407fbd9f71a7d2c91d7ea",
        "refCount": 1
    },
    {
        "Content": "Ranton@umetapp.com:8e0251b430f2ff2c22ac53628059012b",
        "ID": "ae5d1ef485e8cbbc7d1fafedeb9d7c85",
        "refCount": 1
    },
    {
        "Content": "ZccEtspU:354fffc6bd1a42f258882370308804d3",
        "ID": "4015f4977ddf77beb33663e264d118e5",
        "refCount": 1
    },
    {
        "Content": "Alentina@wallmer.com:afdef2c57b44d433ce5c35da2a66464d",
        "ID": "26bbe3303c6989f2e1f8d8c227b3bdea",
        "refCount": 1
    },
    {
        "Content": "b5qz5KQC:53fe9d17938b325356e4e77eeb8c13fd",
        "ID": "71c0d537ceb130a2ac5945fc6ec6d811",
        "refCount": 1
    },
    {
        "Content": "Ashingru@treenpoint.info:b8514b51e6e7fe360cbdae97a349280b",
        "ID": "cf8eeb88ff6171178b2a0e7f956a9dc1",
        "refCount": 1
    },
    {
        "Content": "3kaJBAqi:13c2fdf36badfdef432fbb14fac0ccad",
        "ID": "994fcf4a09cadb16b9b3b9dbdd14c709",
        "refCount": 1
    },
    {
        "Content": "<!DOCTYPE html>\n<style type='text/css'>\n\n  h1 { font-size: 40px; text-align: center}\n  body { font: 12px Helvetica, sans-serif; color: #333; margin:0; overflow-y:auto; height:100%; }\n  .btn {\n    background-color: #072C3F;\n    border: 1px solid #4B4B4B;\n    color: white;\n    padding: 8px 8px;\n    font-size: 18;\n    width: 130px; \n  }\n  .btn-group button:hover {\n    background-color: #137AACFF;\n  }\n\n  article { display: block; text-align: left; width: 600px; margin: 0 auto; }\n  html{\n    background-color: white;\n    height:100%;\n  }\n  .btn-group{\n    text-align: center;\n  }\n  .logo{\n    text-align: center;\n    padding: 10px;\n  }\n  img{\n    display: block;\n    margin: 0 auto;\n  }\n  </style>\n  <div style=\"background-color:#4A6470;color:white;padding:11px;\">\n    <font size=\"30\">Tonagcorp</font>\n  </div>\n  <div style=\"background-color:#00445A;color:white;padding:5px;\">\n    <div class=\"btn-group\">\n      <button type=\"button\" class=\"btn btn-primary\" id=\"Home\">Home</button>\n      <button type=\"button\" class=\"btn btn-primary\" id=\"RegisterBank\">Register</button>\n      <button type=\"button\" class=\"btn btn-primary\" id=\"LoginBank\">Login</button>\n    </div>\n  </div>\n  <article>\n    <div class=\"logo text-center\">\n      <p>\nDo you need a reliable bank to store your money?<br>\nIn Tonagcorp we have the solution.\n    </p>\n      <img src=\"bank.png\" width=\"120\" height=\"120\" align=\"center\">\n    </div>\n  </article>",
        "ID": "23f0afd5bbcfc758509ce472100f744c",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"220.237.180.175\",\"fecha\":\"29-4-1990 21:48\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "e16599d934543517caf9e43e2e681260",
        "refCount": 1
    },
    {
        "Content": "kpl@worth.org:xxxx",
        "ID": "a30e5b2aba5bc2f90165e04c3dc81b72",
        "refCount": 1
    },
    {
        "Content": "root:10f694389ffe9c2d72279ff582b957c7\nAdinauertu:e9bcbe6b76e31a163b92e73e67bc847d\nAlferri:ab334feeb31c05124cb73fa12571c2f6\n",
        "ID": "3b228ebf003854de85606be6e724f6cb",
        "refCount": 1
    },
    {
        "Content": "Adinauertu@syste.org:9cd2c4126a553129644362aed42285dd",
        "ID": "4dd6efedb80a0dab597efaf8eeab040a",
        "refCount": 1
    },
    {
        "Content": "n5Xv48Dn:57b13983d5a31024e5f0332c6708b291",
        "ID": "54a0d6f2538742c79bf8550f694dff65",
        "refCount": 1
    },
    {
        "Content": "Alferri@rectiva.com:f7407edad1ded2d8d1e634ed49a9698e",
        "ID": "75ae7c7bf95d0aa77657ea46cebb46a5",
        "refCount": 1
    },
    {
        "Content": "MaMU1nJT:68276e494f38f45194b1134a794d9caf",
        "ID": "a9290c821fbdf81d41dd1da19859df1d",
        "refCount": 1
    },
    {
        "Content": "10.0.23.6:3306",
        "ID": "546f6f1828ca99684ef4e47cbe4d2704",
        "refCount": 1
    },
    {
        "Content": "<?xml version=\"1.0\" encoding=\"utf-16\"?>\n<ContentFichas xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>188976325</telefono>\n    <mailAddress>Ipperi@illettel.info</mailAddress>\n    <faceParts>Mujer/Base_b;Mujer/Ears_a;Mujer/Eyes_b;Mujer/Hair_a;Mujer/Nose_c;Mujer/Mouth_c;Mujer/Neck_b;Accesorios/piercing;Accesorios/earing;Accesorios/scar</faceParts>\n    <faceScales>-0.9933549,1.075188,0,0;-0.9933549,1.192977,0,0;-0.9258037,0.941661,0,0.5656795;-0.9933549,0.9880123,0,0;-0.8744368,0.7866123,0,-0.2120183;-1.050076,0.9701878,0,-1.300963;-0.9933549,1,0,0;-0.9933549,1.075188,0,0;-0.9933549,1.192977,0.75,0;-0.9933549,1.075188,0,0</faceScales>\n    <nombreCompleto>Jessa Ipperi</nombreCompleto>\n    <edad>48</edad>\n    <horario>09:15 - 15:45</horario>\n    <idPersona>734ec2c1-8be5-4378-a4db-e97685871741</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>163884393</telefono>\n    <mailAddress>Adinauertu@syste.org</mailAddress>\n    <faceParts>Hombre/Base_c;Hombre/Ears_b;Hombre/Eyes_b;Hombre/Hair_a;Hombre/Nose_a;Hombre/Mouth_d;Hombre/Neck_c;Accesorios/beard1;Accesorios/glasses</faceParts>\n    <faceScales>1.008483,0.9679247,0,0;1.008483,1.160427,0,0;0.8762863,0.9860206,0,0.4654478;1.008483,0.9645571,0,0;0.8465558,0.7695111,0,-0.05977169;0.6532728,0.9400932,0,-3.74224;1.008483,1,0,0;1.008483,0.9679247,0,0;1.008483,0.9679247,0,0</faceScales>\n    <nombreCompleto>Herb Adinauertu</nombreCompleto>\n    <edad>54</edad>\n    <horario>10:30 - 17:00</horario>\n    <idPersona>a10b14ff-75cf-4d12-982e-0a30438cb83b</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>862951654</telefono>\n    <mailAddress>Alferri@rectiva.com</mailAddress>\n    <faceParts>Hombre/Base_b;Hombre/Ears_d;Hombre/Eyes_d;Hombre/Hair_a;Hombre/Nose_d;Hombre/Mouth_d;Hombre/Neck_d;Accesorios/beard2;Accesorios/goat</faceParts>\n    <faceScales>1.0022,1.094604,0,0;1.0022,1.157745,0,0;0.9365496,1.087501,0,-0.01051547;1.0022,0.9767292,0,0;1.069979,0.7774803,0,-0.3251224;0.7820134,0.9538404,0,0.1982628;1.0022,1,0,0;1.0022,1.094604,0,0;1.0022,1.094604,0,0</faceScales>\n    <nombreCompleto>Hilary Alferri</nombreCompleto>\n    <edad>33</edad>\n    <horario>06:00 - 12:30</horario>\n    <idPersona>7aa108ec-6c57-4a90-a90f-94d52ae6a5c4</idPersona>\n    <incidencias />\n  </Ficha>\n</ContentFichas>",
        "ID": "5835986c828e98e7541069bbd7ff0b2f",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"220.237.180.175\",\"fecha\":\"29-4-1990 22:29\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "a3f01b366f949870e37e1d8e289d42d3",
        "refCount": 1
    },
    {
        "Content": "root:de11fcbb52f27ff5e3af6291a7138db0\nLin-yanako:81aea594f2d90a2e84bd1393349c91ed\nDeback:2419c459e9ad2d94f4a5c887b3ca18cb\n",
        "ID": "dd9fcd19eababcda38b7f9818f743677",
        "refCount": 1
    },
    {
        "Content": "Lin-yanako@liberts.org:976c4e536f7b20707ad5547db0dd6a9c",
        "ID": "a834625b33fe1bff86c1a5bd073d0990",
        "refCount": 1
    },
    {
        "Content": "uQXlivwY:f31182a22bf0d3dd9629f406ec3b63c2",
        "ID": "07f7e7dfb7a2921e4b53674477163a5b",
        "refCount": 1
    },
    {
        "Content": "Deback@tronicorp.info:eff15904ad1ff50e1a71642704afd6f7",
        "ID": "4d477df779a8efcbba6bc5bbebff6a38",
        "refCount": 1
    },
    {
        "Content": "nCxWv2yq:49855715e6c405f61c88faefb14e5cf9",
        "ID": "e1562cb4a29b6090dfd615e760821908",
        "refCount": 1
    },
    {
        "Content": "root:de11fcbb52f27ff5e3af6291a7138db0\nGleyma:cb6268d4e99194f002aa7b953c56f456\nEstian:a19fbd0d34f29afc348e31f92396229d\nSenbergel:933543955f5d44d2949c2601b6af3d3d\n",
        "ID": "d5a04d000f66c2a4e4ca66ac13ee5b10",
        "refCount": 1
    },
    {
        "Content": "Gleyma@lergys.com:3726ad69673d5bd3250fd12a6597ff54",
        "ID": "39f6bde2659f528347a7c0570c25eb38",
        "refCount": 1
    },
    {
        "Content": "eUGUaWRA:da08b2a8b15cd8795867e77fed690150",
        "ID": "6de24edf68471a083d770be1a6cf03ab",
        "refCount": 1
    },
    {
        "Content": "Estian@devon.com:e2333d586332c78a84dc0f7153499b1c",
        "ID": "6075f89fb2d6cf57ae72f826828424bd",
        "refCount": 1
    },
    {
        "Content": "SAny7GHj:aed34b9f60ee115dfa7918b742336277",
        "ID": "aa94c2e91f63f2c47f8a3e6d03846a55",
        "refCount": 1
    },
    {
        "Content": "Senbergel@haeusettella.net:82233bce59652cf3cc0eb7a03f3109d1",
        "ID": "99746c28586f0ba4689a22d512710f8e",
        "refCount": 1
    },
    {
        "Content": "m59NkD95:aae54a99700ff60213fc5e89020ee41d",
        "ID": "83ea58c15490db614b5373a54ffcb178",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"220.237.180.175\",\"fecha\":\"29-4-1990 22:46\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true}]}",
        "ID": "2eb3cc75c8d965daa232d2a8d55e8a79",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"220.237.180.175\",\"fecha\":\"29-4-1990 22:46\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true},{\"action\":2,\"ip\":\"220.237.180.175\",\"fecha\":\"29-4-1990 22:46\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true}]}",
        "ID": "1c3a3e9ba8b7ae8f54b251a341b1b11d",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":4,\"ip\":\"220.237.180.175\",\"fecha\":\"29-4-1990 22:46\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"75.119.178.49\",\"playerNetID\":\"3f774d26-9a17-4ce2-aae4-7da5eb83862a\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "2994f9aa9cb7a58a6e08c0f980efb6b0",
        "refCount": 2
    },
    {
        "Content": "{\"contentLog\":[{\"action\":4,\"ip\":\"192.168.1.3\",\"fecha\":\"29-4-1990 22:46\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"75.119.178.49\",\"playerNetID\":\"3f774d26-9a17-4ce2-aae4-7da5eb83862a\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "276ef7e71ac7262697f9e687df99dea0",
        "refCount": 2
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"220.237.180.175\",\"fecha\":\"29-4-1990 22:46\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true},{\"action\":3,\"ip\":\"75.119.178.49\",\"fecha\":\"29-4-1990 23:47\",\"puerto\":0,\"file\":\"/root\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true},{\"action\":3,\"ip\":\"75.119.178.49\",\"fecha\":\"29-4-1990 23:48\",\"puerto\":0,\"file\":\"/home\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true}]}",
        "ID": "a4da308a42c95a60fef8e2747d0e7a90",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"220.237.180.175\",\"fecha\":\"29-4-1990 22:46\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true},{\"action\":1,\"ip\":\"75.119.178.49\",\"fecha\":\"30-4-1990 00:46\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true}]}",
        "ID": "4a04457f92b139d8c586be4d68d26857",
        "refCount": 1
    },
    {
        "Content": "root:ad0b30bdbe9aca058b40b348e5cfbb61\n",
        "ID": "a2f4df724d01d653af8466e4860562a6",
        "refCount": 1
    },
    {
        "Content": "root:xxxx\nac:xxxx",
        "ID": "c94d56ec74e98101fa60f8be940de710",
        "refCount": 1
    },
    {
        "Content": "Wifi access:\n----------\n\n03:AF:EF:F9:32:4E\nWifth_EUA2\nPassword: Ewporto",
        "ID": "f4378dcf835be255d2e6237255544f8f",
        "refCount": 1
    },
    {
        "Content": "root:e0353ab3cc6948fcbfe78dee0ff42a70\nOrnette:a6fec3edafa7b7916ea3356c43ae0305\nJuintek:07df1bd6470dcb147b1c2628d7cbc5c7\nOvictorman:80e90d6d7044b0c9886091685aa86c99\n",
        "ID": "cb540dacbb2128b89db07835373dab6e",
        "refCount": 1
    },
    {
        "Content": "Ornette@roviac/in.net:687b86c36ee57ae11b5f2de9d666529e",
        "ID": "8d3d339973954b29f8990add0a349116",
        "refCount": 1
    },
    {
        "Content": "Q46hXRLI:1b2e93225959e3722efed95e1731b764",
        "ID": "3e4e4eb29d45cc48ba9313e927d0be2e",
        "refCount": 1
    },
    {
        "Content": "Juintek@bioporthro.net:dbfce57d878a60b32397c92e694abe3c",
        "ID": "8f81882c2625945fc5a98c76ce50d102",
        "refCount": 1
    },
    {
        "Content": "qLIKFScR:c090fdfabf79bc85feddf669ba12bd7c",
        "ID": "2701e2a284d2434b5f82bbf49ad0ec73",
        "refCount": 1
    },
    {
        "Content": "Ovictorman@aelsmark.info:04b19ebc02e0b5a18a7fd1a9ebe43765",
        "ID": "bf7e27ac10ea0f8ed5babfa1df41db2a",
        "refCount": 1
    },
    {
        "Content": "dV0hb6Ds:1cd77452aee4f04d25f33297db6efc18",
        "ID": "eb7254acdaa5d9a1dc5fb26a1ce6a22f",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 06:19\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "0a863c4cb30e2f5c335997e9b969d523",
        "refCount": 1
    },
    {
        "Content": "root:182bfb98276d94e3d183b492ce6fdd60\nIstoyersh:1cd66cb5f3df74d2aa647a5c5b90e6f3\nHiroyend:b64326869f5e454a0a4bd50309233c37\n",
        "ID": "71deba9428380134e9b10bc67cc624eb",
        "refCount": 1
    },
    {
        "Content": "Istoyersh@emprogredited.com:510b867bd0bd0b4e70ea99f1722e1a20",
        "ID": "b580895a4f3b3f9b960f2d3368883a15",
        "refCount": 1
    },
    {
        "Content": "KdwLKu1t:79b7cdcd14db14e9cb498f1793817d69",
        "ID": "bd3984ea458256b662617e8d9c3b0212",
        "refCount": 1
    },
    {
        "Content": "Hiroyend@leadw.com:fba0c05dd2c62488818d2c0718f7aab1",
        "ID": "b967a7505e9902bc6424d00541342741",
        "refCount": 1
    },
    {
        "Content": "xKO4wamO:5751080e757147aca63653966d870a9c",
        "ID": "e6d9a2ac9688fa9fb5e02197d32ba215",
        "refCount": 1
    },
    {
        "Content": "dollyw.org",
        "ID": "821ed5c21affb79d72c8e2a2d69f9f63",
        "refCount": 1
    },
    {
        "Content": "<!DOCTYPE html>\n<style type='text/css'>\n\n  h1 { font-size: 40px; text-align: center}\n  body { font: 12px Helvetica, sans-serif; color: #333; margin:0; overflow-y:auto; height:100%; }\n  .btn {\n    background-color: #444444FF;\n    border: 1px solid #B2B2B2FF;\n    color: #C1C1C1FF;\n    padding: 8px 8px;\n    font-size: 18;    \n    width: 130px;\n  }\n  .btn-group button:hover {\n    background-color: #690000FF;\n  }\n\n  article { display: block; text-align: left; width: 600px; margin: 0 auto; } \n\n  html{\n    background-color: white;\n    height:100%;\n  }\n  .mainText{\n    text-align: center;\n    padding: 10px;\n  }\n\n  .logo{\n    text-align: right;    \n    position: absolute;\n    right: 10px;\n    font-size: 25px;\n    \n  }\n  img{\n    display: block;\n    margin: 0 auto;\n  }\n</style>\n\n</div>\n<div style=\"background-color:#A92222FF;color:white;padding:11px;\">\n  <div class=\"logo\">Dollyw</div>\n<div class=\"btn-group\">\n  <button type=\"button\" class=\"btn btn-primary\" id=\"Home\">Main</button>\n  <button type=\"button\" class=\"btn btn-primary\" id=\"RegisterMail\">Email services</button>\n  <button type=\"button\" class=\"btn btn-primary\">News</button>    \n  \n</div>\n\n</div>\n\n<article>\n    <div class=\"mainText\">    \n        <p>\nWelcome, we are Dollyw, a company that offers services through the network.<br><br>\n\nWe currently have a mail service available, it's totally free.<br>\nRegister now!<br><br>\n    </p>\n           <img src=\"email_alter.png\" width=\"85\" height=\"85\" align=\"center\">\n    </div> \n</article>\n",
        "ID": "a67c418cfff3e57c12a072c305d420f5",
        "refCount": 1
    },
    {
        "Content": "root:bc92c95bfe7b15607eac90330de98f61\nWilmon:8996b8d405bbf2419f8055986f7a58e7\nRawlerson:869e0fd6d7adf96f8824a981c9b3faf8\n",
        "ID": "481286f3bade011b60d660bec4dea7b4",
        "refCount": 1
    },
    {
        "Content": "Wilmon@nashlandi.net:2aebc617c8fe5bcbba0ee2cb678c6c7c",
        "ID": "f38f854a43ca425679bbc22480381763",
        "refCount": 1
    },
    {
        "Content": "Xc4C9Fd1:9b951a71fbeafda0d69d950514479424",
        "ID": "567f83f3ae562a067874a7733778786a",
        "refCount": 1
    },
    {
        "Content": "Rawlerson@thklinsin.com:1cd77452aee4f04d25f33297db6efc18",
        "ID": "dc70a7e669e6247164ecdaffdab355c4",
        "refCount": 1
    },
    {
        "Content": "7TX2mmK5:93e54d87a831dc07305378d862b6cd9f",
        "ID": "49ccd17e9a60ecc06d2e20a34bb907b0",
        "refCount": 1
    },
    {
        "Content": "192.168.0.3:3306",
        "ID": "b25a9ef2582dbd91ad29fc8f56e0d729",
        "refCount": 1
    },
    {
        "Content": "udencomptoinc.net",
        "ID": "9adb86a520dac99a6dceb3eb86a193e1",
        "refCount": 1
    },
    {
        "Content": "<!DOCTYPE html>\n<style type='text/css'>\n\n  h1 { font-size: 40px; text-align: center}\n  body { font: 12px Helvetica, sans-serif; color: #333; margin:0; overflow-y:auto; height:100%; }\n  .btn {\n    background-color: #444444FF;\n    border: 1px solid #B2B2B2FF;\n    color: #C1C1C1FF;\n    padding: 8px 8px;\n    font-size: 18;    \n    width: 130px;\n  }\n  .btn-group button:hover {\n    background-color: #690000FF;\n  }\n\n  article { display: block; text-align: left; width: 600px; margin: 0 auto; } \n\n  html{\n    background-color: white;\n    height:100%;\n  }\n  .mainText{\n    text-align: center;\n    padding: 10px;\n  }\n\n  .logo{\n    text-align: right;    \n    position: absolute;\n    right: 10px;\n    font-size: 25px;\n    \n  }\n  img{\n    display: block;\n    margin: 0 auto;\n  }\n</style>\n\n</div>\n<div style=\"background-color:#A92222FF;color:white;padding:11px;\">\n  <div class=\"logo\">Udencomptoinc</div>\n<div class=\"btn-group\">\n  <button type=\"button\" class=\"btn btn-primary\" id=\"Home\">Main</button>\n  <button type=\"button\" class=\"btn btn-primary\" id=\"RegisterMail\">Email services</button>\n  <button type=\"button\" class=\"btn btn-primary\">News</button>    \n  \n</div>\n\n</div>\n\n<article>\n    <div class=\"mainText\">    \n        <p>\nWelcome, we are Udencomptoinc, a company that offers services through the network.<br><br>\n\nWe currently have a mail service available, it's totally free.<br>\nRegister now!<br><br>\n    </p>\n           <img src=\"email_alter.png\" width=\"85\" height=\"85\" align=\"center\">\n    </div> \n</article>\n",
        "ID": "58a017e5a573f7ec9e3144e0bcd606e8",
        "refCount": 1
    },
    {
        "Content": "<?xml version=\"1.0\" encoding=\"utf-16\"?>\n<ContentFichas xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>389314815</telefono>\n    <mailAddress>Malmit@ncorpe.net</mailAddress>\n    <faceParts>Mujer/Base_c;Mujer/Ears_c;Mujer/Eyes_b;Mujer/Hair_c;Mujer/Nose_c;Mujer/Mouth_b;Mujer/Neck_a;Accesorios/scar;Accesorios/earing</faceParts>\n    <faceScales>1.037473,1.053384,0,0;1.037473,1.139309,0,0;0.9595989,0.8886222,0,-0.6497669;1.037473,0.9763197,0,0;0.8792107,0.8672867,0,-0.06097745;0.9929949,0.8719503,0,-5.072036;1.037473,1,0,0;1.037473,1.053384,0,0;1.037473,1.139309,0.75,0</faceScales>\n    <nombreCompleto>Maureen Malmit</nombreCompleto>\n    <edad>46</edad>\n    <horario>09:00 - 15:30</horario>\n    <idPersona>191cf493-15e7-4876-8ecd-260c2371adb5</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>232577563</telefono>\n    <mailAddress>Wilmon@nashlandi.net</mailAddress>\n    <faceParts>Hombre/Base_d;Hombre/Ears_c;Hombre/Eyes_d;Hombre/Hair_d;Hombre/Nose_b;Hombre/Mouth_d;Hombre/Neck_c;Accesorios/moustache;Accesorios/goat</faceParts>\n    <faceScales>-0.9138444,1.067951,0,0;-0.9138444,0.9702611,0,0;-0.801633,1.099688,0,0.5861224;-0.9138444,0.9842307,0,0;-1.032427,0.7996878,0,0.2396219;-0.7848939,0.9610694,0,-4.908738;-0.9138444,1,0,0;-0.9138444,1.067951,0,-4.467638;-0.9138444,1.067951,0,0</faceScales>\n    <nombreCompleto>Rossie Wilmon</nombreCompleto>\n    <edad>26</edad>\n    <horario>07:45 - 14:15</horario>\n    <idPersona>2cb72cb7-04a1-4bc5-ac32-310346b2bf6e</idPersona>\n    <incidencias />\n  </Ficha>\n  <Ficha xsi:type=\"FichaEmpleados\">\n    <telefono>826977983</telefono>\n    <mailAddress>Rawlerson@thklinsin.com</mailAddress>\n    <faceParts>Hombre/Base_c;Hombre/Ears_a;Hombre/Eyes_d;Hombre/Hair_d;Hombre/Nose_a;Hombre/Mouth_a;Hombre/Neck_a;Accesorios/moustache</faceParts>\n    <faceScales>1.038418,1.007415,0,0;1.038418,1.16376,0,0;0.9481179,0.8988557,0,0.05725924;1.038418,0.9763253,0,0;0.9567765,0.8442062,0,0.101445;0.9198098,0.9284716,0,-4.299994;1.038418,1,0,0;1.038418,1.007415,0,-3.742422</faceScales>\n    <nombreCompleto>Bruce Rawlerson</nombreCompleto>\n    <edad>29</edad>\n    <horario>09:15 - 15:45</horario>\n    <idPersona>77f83ab1-9e60-46f2-8110-3e46a9f0a40b</idPersona>\n    <incidencias />\n  </Ficha>\n</ContentFichas>",
        "ID": "6da8120511e5e22fa64955ed8125ed97",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 06:28\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "ac49f135a36efcaae0aa992336e40d04",
        "refCount": 1
    },
    {
        "Content": "root:325d213d72b89fd29cc0421fdcfffbac\n",
        "ID": "0d8d7ea8f1e061452a5206289f587e89",
        "refCount": 1
    },
    {
        "Content": "root:755e9d64d53f52bab83f30a752e5324a\n",
        "ID": "06e6c711804b67755d0899c8a6cae224",
        "refCount": 1
    },
    {
        "Content": "root:755e9d64d53f52bab83f30a752e5324a\nAtiong:82233bce59652cf3cc0eb7a03f3109d1\nAronbarte:1c2ae0025fa207d6fbccbad479bb06f9\nErkins:b1c42240e75d97085ed6cbfff79a1527\n",
        "ID": "6cf0c0b3bc09e50bedd3fd10cc74461a",
        "refCount": 1
    },
    {
        "Content": "Ationg@travelectraven.com:b2d9339b27419282452ce39b81d86b36",
        "ID": "becb63c6edf2785dc3648187291038d0",
        "refCount": 1
    },
    {
        "Content": "7BtlDKoC:ae40e7cbff1b398cd76a5e641dd888b9",
        "ID": "fc08ac2defdc233e56b89008b8effef7",
        "refCount": 1
    },
    {
        "Content": "Aronbarte@heinz.net:4a357e43fba47afd6d96c6f6524ade53",
        "ID": "64dd8d252252c8acbcd4dd4508057363",
        "refCount": 2
    },
    {
        "Content": "JeSODgcg:7d54f512a4cf021110225249c2cb63b1",
        "ID": "56e27ff33b90f2b76ff0e463659078bc",
        "refCount": 2
    },
    {
        "Content": "Erkins@shackw.info:1085b68ef7a2d084cbc4ef79dd3af8c1",
        "ID": "8f3500f80a58e0feaa913a525d40e392",
        "refCount": 1
    },
    {
        "Content": "sUXeSj7f:1b9674360085cbef9d63181d982beda9",
        "ID": "3ee47e487fbe81259c1fb12910c2bf47",
        "refCount": 1
    },
    {
        "Content": "root:c6ca08ec26bb9ae886a2d83088d68a14\nRlanetton:bd6ff38313a72a885b88a764f4b640d9\nGadb:34e83eb3343e03931e1a4013fa756728\n",
        "ID": "0b42966da195b516457c5d355a121642",
        "refCount": 1
    },
    {
        "Content": "Rlanetton@lennium.net:460e926a82572ff6a6c29523b814c9ca",
        "ID": "29df76ec7c979fc7bb7788866fa4b858",
        "refCount": 1
    },
    {
        "Content": "SQ4FccO3:ac575e3eecf0fa410518c2d3a2e7209f",
        "ID": "854588d6c8e7d7a6a2b5a083b43ddd95",
        "refCount": 1
    },
    {
        "Content": "Gadb@carley-da.info:76d11e44260191381aa94c526f734b2e",
        "ID": "1b5ce286a1a1db1f8f5d4581606dd422",
        "refCount": 1
    },
    {
        "Content": "GT5h2oft:562aac6d92e917785b4e9927edc62359",
        "ID": "7b6ae9c0c2a933e10a81c6a9dc4e0991",
        "refCount": 1
    },
    {
        "Content": "<!DOCTYPE html>\n<style type='text/css'>\n\n  h1 { font-size: 40px; text-align: center}\n  body { font: 12px Helvetica, sans-serif; color: #333; margin:0; overflow-y:auto; height:100%; }\n  .btn {\n    background-color: #072C3F;\n    border: 1px solid #4B4B4B;\n    color: white;\n    padding: 8px 8px;\n    font-size: 18;\n    width: 130px; \n  }\n  .btn-group button:hover {\n    background-color: #137AACFF;\n  }\n\n  article { display: block; text-align: left; width: 600px; margin: 0 auto; }\n  html{\n    background-color: white;\n    height:100%;\n  }\n  .btn-group{\n    text-align: center;\n  }\n  .logo{\n    text-align: center;\n    padding: 10px;\n  }\n  img{\n    display: block;\n    margin: 0 auto;\n  }\n  </style>\n  <div style=\"background-color:#4A6470;color:white;padding:11px;\">\n    <font size=\"30\">Metald</font>\n  </div>\n  <div style=\"background-color:#00445A;color:white;padding:5px;\">\n    <div class=\"btn-group\">\n      <button type=\"button\" class=\"btn btn-primary\" id=\"Home\">Home</button>\n      <button type=\"button\" class=\"btn btn-primary\" id=\"RegisterBank\">Register</button>\n      <button type=\"button\" class=\"btn btn-primary\" id=\"LoginBank\">Login</button>\n    </div>\n  </div>\n  <article>\n    <div class=\"logo text-center\">\n      <p>\nAt Metald we know how important it is to know that your savings are in safe hands. Open an account now and you will have access to one of the safest banking services in the world.\n    </p>\n      <img src=\"bank.png\" width=\"120\" height=\"120\" align=\"center\">\n    </div>\n  </article>",
        "ID": "7ab875e6e17efa4385c4ebfd0e7bdda6",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 06:31\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "eb91121b79395f6ebb483daf25d8e0a8",
        "refCount": 1
    },
    {
        "Content": "ac@udencomptoinc.net:xxxx",
        "ID": "8d241637172a1f05aa2fb73f4a6bc40a",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 07:06\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true}]}",
        "ID": "276e24d9011c2b57f2a1a56ba9e61ea7",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 07:06\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true},{\"action\":2,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 07:06\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true}]}",
        "ID": "4309015e275ad849da75f4addcf36592",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":4,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 07:06\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"139.45.15.5\",\"playerNetID\":\"89bf24d4-fd3d-4fd3-8afb-9816082c33a9\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "5b93a0062adfdc2e12e38e39285ab2f3",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":4,\"ip\":\"192.168.1.2\",\"fecha\":\"30-4-1990 07:06\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"139.45.15.5\",\"playerNetID\":\"89bf24d4-fd3d-4fd3-8afb-9816082c33a9\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "7f1831056a03cc12cf4b38acd6b6696b",
        "refCount": 1
    },
    {
        "Content": "root:325d213d72b89fd29cc0421fdcfffbac\nArsonic:99aa52c9dfd36c0f9f62f12a5f6c7ab9\nSalzellig:7af145d29aae1b1eba52723a0678fa3f\nUpinellgre:d3bf0dd1a8a5770f8d7e898877d3285f\n",
        "ID": "9be435bfd5f3570f687a63f52ef8940d",
        "refCount": 1
    },
    {
        "Content": "Arsonic@gtoneerex.com:a05300a907d02181fe0a510ab6d39c2b",
        "ID": "8043b24aeb98387bd7dfaf41ebe00361",
        "refCount": 1
    },
    {
        "Content": "dtjoLwda:4f5cc32aa87e09f601a902ba07bda7eb",
        "ID": "d89ecddb28797cdd2eccc886f13ff057",
        "refCount": 1
    },
    {
        "Content": "Salzellig@berlylesor.org:7f11b15655b2342b01a2db7edb7961cd",
        "ID": "42f9dc8f554ca91916311902606f2371",
        "refCount": 1
    },
    {
        "Content": "aYMAuZwr:6e8f4ddb347af3442833c41e0f7dcd5d",
        "ID": "20442c3418d111968035c7522710d4f9",
        "refCount": 1
    },
    {
        "Content": "Upinellgre@genti.com:eeaba7c0c0cd90d3286ae34bf3131fc1",
        "ID": "ada1f346561aaf4dd3d846777df202be",
        "refCount": 1
    },
    {
        "Content": "f3zvx7Zt:de19cdf2b715bbf762fa4f6696ee7f4b",
        "ID": "98423fcc7ac80df3e53668b44430d79b",
        "refCount": 1
    },
    {
        "Content": "<!DOCTYPE html>\n<style type='text/css'>\n\nbody { font: 12px Helvetica, sans-serif; margin:0; overflow-y:auto; height:100%; }\n\nhtml{\n\tbackground-color: #131c23;\n    height:100%;\n    margin:0; overflow-y:auto;\n}\n\n.hackshop { \n    text-align: center;    \n    padding: 100px;\n    padding-top: 25px;\n}\n\n.btn {\n    background-color: #151515;\n    border: 1px solid #2b4f4f;\n    color: white;\n    padding: 8px 8px;\n    text-align: center;\n    text-decoration: none;\n    display: inline-block;\n    font: 18;\n    width: 130px;\n}\n\n.btn-group{\n  padding-top: 4px;\n}\n\n.btn-sel{\n    background-color: #2b2b2b;\n}\n.btn-group button:hover {\n    background-color: #2b2b2b;\n}\n</style>\n<div class=\"btn-group\" style=\"text-align: center;\">\n  <button type=\"button\" class=\"btn btn-primary btn-sel\" id=\"Main\">Main</button>\n  <button type=\"button\" class=\"btn btn-primary\" id=\"HackShopTools\">Tools</button>\n  <button type=\"button\" class=\"btn btn-primary\" id=\"HackShopExploits\">Exploits</button>\n  <button type=\"button\" class=\"btn btn-primary\" id=\"Jobs\">Jobs</button>  \n</div>\n  \n  <div class=\"hackshop\">\n    <img src=\"gecko.png\" width=\"80\" height=\"80\" align=\"center\">\n    <p style=\"font-size:18px;\">HackShop</p>    \n    <p>Welcome to my personal store. Buy what you want, I will not ask questions.<br><br>Notice: If any of the users report this site to the police I will be forced to make public the list of all the users of this site.</p>\n  </div>\n",
        "ID": "e8b172d85e2cc8998eeb4ca30958b59c",
        "refCount": 1
    },
    {
        "Content": "//command scanlib\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"scanlib_usage\"))\nmetaxploit = include_lib(\"/lib/metaxploit.so\")\nif not metaxploit then exit(\"Error: Missing metaxploit library\")\nlibFile = get_shell.host_computer.File(params[0])\nif not libFile then exit(\"can't find library: \" + params[0])\nprint(\"Scanning memory address...\")\nmetaLib = metaxploit.load(libFile.path)\nlistMem = metaxploit.scan(metaLib)\nindex = 1\nfor itemMem in listMem\n\tprint(index +\": [\" + itemMem + \"]\")\n\tindex = index + 1\nend for\nif listMem.len == 0 then exit(\"Scan completed: No issues detected.\")\n\nprint(\"Scan completed: detected issues in \" + listMem.len + \" memory zones.\")\noption = \"\"\ninputOk = false\nwhile( not inputOk )\n\toption = user_input(\"Select memory index: \").to_int\n\tif typeof(option) != \"number\" or (option < 1 or option > listMem.len) then\n\t\tprint(\"Invalid input. Type a valid number\")\n\telse \n\t\tinputOk = true\n\tend if\nend while\nprint(\"Scanning for vulnerabilities at memory zone: \" + listMem[option - 1])\nprint(metaxploit.scan_address(metaLib, listMem[option - 1]))",
        "ID": "339de03d8da37b718aa8e8ba5d18ad34",
        "refCount": 1
    },
    {
        "Content": "//command: scanrouter\nif params.len != 1 or params[0] == \"-h\" or params[0] == \"--help\" then exit(command_info(\"scanrouter_usage\"))\nipAddress = params[0]\n\nrouter = get_router( ipAddress )\nif router == null then exit(\"scanrouter: ip address not found\")\nprint(\"Connecting to router at address: \" + ipAddress + \"\\nScanning kernel library...\")\nversion = router.kernel_version\nif not version then\n\tprint(\"Warning: kernel_router.so not found\")\nelse \n\tprint(\"kernel_router.so : v\" + version)\nend if\n\nfirewall_rules = router.firewall_rules\nif typeof(firewall_rules) == \"string\" then exit(firewall_rules)\nprint(\"\\nScanning firewall rules...\")\nif firewall_rules.len == 0 then exit(\"No rules found.\")\ninfo = \"ACTION PORT SOURCE_IP DESTINATION_IP\"\nfor rules in firewall_rules\n\tinfo = info + \"\\n\" + rules\nend for\nprint(format_columns(info) + \"\\n\")\n",
        "ID": "72f2ee8d5f41c7b11d7d40db58aa83e2",
        "refCount": 1
    },
    {
        "Content": "//sniffer\nif params.len == 1 and (params[0] == \"-h\" or params[0] == \"--help\" or params[0] != \"-save\") then exit(command_info(\"sniffer_usage\"))\nmetaxploit = include_lib(\"/lib/metaxploit.so\")\nif not metaxploit then\n\tmetaxploit = include_lib(current_path + \"/metaxploit.so\")\nend if\nif not metaxploit then exit(\"Error: Can't find metaxploit library in the /lib path or the current folder\")\nprint(\"Starting listen...\\nWaiting to incoming data.\")\noutput = metaxploit.sniffer(params.len == 1)\nif not output then exit(\"Unknown error: can't start to listening\")\nprint(output)\n",
        "ID": "eb992b9e1ab2bb0544900d7f1f8504e7",
        "refCount": 1
    },
    {
        "Content": "//rshell_interface\nmetaxploit = include_lib(\"/lib/metaxploit.so\")\nif not metaxploit then\n\tmetaxploit = include_lib(current_path + \"/metaxploit.so\")\nend if\nif not metaxploit then exit(\"Error: Can't find metaxploit library in the /lib path or the current folder\")\nprint(\"Listening for upcoming connections...\")\n\nshells = []\nwhile shells.len == 0\t\n\tshells = metaxploit.rshell_server\n\tif(typeof(shells) == \"string\") then exit(shells)\t\n\tif(shells.len == 0) then wait(2)\nend while\n\noption = 0\nwhile typeof(option) != \"number\" or (option < 1 or option > shells.len)\n\tprint(shells.len + \" shell(s) connected!\\n<b>Select a shell to start a terminal:</b>\")\n\tfor i in range(0, shells.len - 1)\n\t\tprint(\"\\n<b>Shell (\" + (i + 1) + \")</b>\\nPublic IP: \" + shells[i].host_computer.public_ip + \"\\nLocal IP: \" + shells[i].host_computer.local_ip)\n\tend for\n\tprint(\"-----------\")\n\toption = user_input(\"Select shell>\").to_int\nend while\nprint(\"Starting shell #\" + option)\nshells[option - 1].start_terminal",
        "ID": "01a83cb06cfc7a39f5b340dd4a1f794b",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 08:27\",\"puerto\":80,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "0aaf771407228b03f8b0c37bb5c7d58b",
        "refCount": 1
    },
    {
        "Content": "<?xml version=\"1.0\" encoding=\"utf-16\"?>\n<Missions xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n  <nextPreIdMission>19</nextPreIdMission>\n  <Mission dia=\"4\" mes=\"5\" minRep=\"1\">\n    <missionType>PoliceRecord</missionType>\n    <title>MISSION_POLICE_TITLE</title>\n    <content>MISSION_POLICE_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_POLICE_CHANGES\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>0</preMissionID>\n  </Mission>\n  <Mission dia=\"4\" mes=\"5\" minRep=\"1\">\n    <missionType>PoliceRecord</missionType>\n    <title>MISSION_POLICE_TITLE</title>\n    <content>MISSION_POLICE_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_POLICE_CHANGES\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>1</preMissionID>\n  </Mission>\n  <Mission dia=\"2\" mes=\"5\" minRep=\"1\">\n    <missionType>PoliceRecord</missionType>\n    <title>MISSION_POLICE_TITLE</title>\n    <content>MISSION_POLICE_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_POLICE_CHANGES\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>2</preMissionID>\n  </Mission>\n  <Mission dia=\"5\" mes=\"5\" minRep=\"1\">\n    <missionType>PoliceRecord</missionType>\n    <title>MISSION_POLICE_TITLE</title>\n    <content>MISSION_POLICE_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_POLICE_REMOVE\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>3</preMissionID>\n  </Mission>\n  <Mission dia=\"2\" mes=\"5\" minRep=\"0\">\n    <missionType>PoliceRecord</missionType>\n    <title>MISSION_POLICE_TITLE</title>\n    <content>MISSION_POLICE_CONTENT</content>\n    <Details minRep=\"0\" type=\"MISSION_POLICE_REMOVE\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>4</preMissionID>\n  </Mission>\n  <Mission dia=\"2\" mes=\"5\" minRep=\"1\">\n    <missionType>AcademicRecord</missionType>\n    <title>MISSION_ACADEMIC_TITLE</title>\n    <content>MISSION_ACADEMIC_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_ACADEMIC_CHANGES\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>5</preMissionID>\n  </Mission>\n  <Mission dia=\"6\" mes=\"5\" minRep=\"1\">\n    <missionType>Credentials</missionType>\n    <title>MISSION_CREDENTIALS_TITLE</title>\n    <content>MISSION_CREDENTIALS_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_ANY_USER\">\n      <Condition>MISSION_NO_CHANGES_PREFERRED</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>6</preMissionID>\n  </Mission>\n  <Mission dia=\"3\" mes=\"5\" minRep=\"1\">\n    <missionType>AcademicRecord</missionType>\n    <title>MISSION_ACADEMIC_TITLE</title>\n    <content>MISSION_ACADEMIC_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_ACADEMIC_CHANGES\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>7</preMissionID>\n  </Mission>\n  <Mission dia=\"2\" mes=\"5\" minRep=\"1\">\n    <missionType>DestroyComputer</missionType>\n    <title>MISSION_DESTROY_PC_TITLE</title>\n    <content>MISSION_DESTROY_PC_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_DESTROY_PC\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>8</preMissionID>\n  </Mission>\n  <Mission dia=\"7\" mes=\"5\" minRep=\"1\">\n    <missionType>DestroyComputer</missionType>\n    <title>MISSION_DESTROY_PC_TITLE</title>\n    <content>MISSION_DESTROY_PC_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_DESTROY_PC\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>9</preMissionID>\n  </Mission>\n  <Mission dia=\"7\" mes=\"5\" minRep=\"1\">\n    <missionType>PoliceRecord</missionType>\n    <title>MISSION_POLICE_TITLE</title>\n    <content>MISSION_POLICE_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_POLICE_ADD_CHARGE\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>10</preMissionID>\n  </Mission>\n  <Mission dia=\"6\" mes=\"5\" minRep=\"1\">\n    <missionType>PoliceRecord</missionType>\n    <title>MISSION_POLICE_TITLE</title>\n    <content>MISSION_POLICE_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_POLICE_ADD_CHARGE\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>11</preMissionID>\n  </Mission>\n  <Mission dia=\"3\" mes=\"5\" minRep=\"0\">\n    <missionType>PoliceRecord</missionType>\n    <title>MISSION_POLICE_TITLE</title>\n    <content>MISSION_POLICE_CONTENT</content>\n    <Details minRep=\"0\" type=\"MISSION_POLICE_REMOVE\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>12</preMissionID>\n  </Mission>\n  <Mission dia=\"2\" mes=\"5\" minRep=\"1\">\n    <missionType>Credentials</missionType>\n    <title>MISSION_CREDENTIALS_TITLE</title>\n    <content>MISSION_CREDENTIALS_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_ANY_USER\">\n      <Condition>MISSION_NO_CHANGES_PREFERRED</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>13</preMissionID>\n  </Mission>\n  <Mission dia=\"5\" mes=\"5\" minRep=\"0\">\n    <missionType>Credentials</missionType>\n    <title>MISSION_CREDENTIALS_TITLE</title>\n    <content>MISSION_CREDENTIALS_CONTENT</content>\n    <Details minRep=\"0\" type=\"MISSION_ANY_USER\">\n      <Condition>MISSION_NO_CHANGES_PREFERRED</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>14</preMissionID>\n  </Mission>\n  <Mission dia=\"6\" mes=\"5\" minRep=\"0\">\n    <missionType>Credentials</missionType>\n    <title>MISSION_CREDENTIALS_TITLE</title>\n    <content>MISSION_CREDENTIALS_CONTENT</content>\n    <Details minRep=\"0\" type=\"MISSION_SPECIFIC_USER\">\n      <Condition>MISSION_NO_CHANGES</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>15</preMissionID>\n  </Mission>\n  <Mission dia=\"6\" mes=\"5\" minRep=\"0\">\n    <missionType>PoliceRecord</missionType>\n    <title>MISSION_POLICE_TITLE</title>\n    <content>MISSION_POLICE_CONTENT</content>\n    <Details minRep=\"0\" type=\"MISSION_POLICE_REMOVE_CHARGE\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>16</preMissionID>\n  </Mission>\n  <Mission dia=\"2\" mes=\"5\" minRep=\"1\">\n    <missionType>DestroyComputer</missionType>\n    <title>MISSION_DESTROY_PC_TITLE</title>\n    <content>MISSION_DESTROY_PC_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_DESTROY_PC\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>17</preMissionID>\n  </Mission>\n  <Mission dia=\"7\" mes=\"5\" minRep=\"1\">\n    <missionType>AcademicRecord</missionType>\n    <title>MISSION_ACADEMIC_TITLE</title>\n    <content>MISSION_ACADEMIC_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_ACADEMIC_CHANGES\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>18</preMissionID>\n  </Mission>\n  <Mission dia=\"4\" mes=\"5\" minRep=\"1\">\n    <missionType>PoliceRecord</missionType>\n    <title>MISSION_POLICE_TITLE</title>\n    <content>MISSION_POLICE_CONTENT</content>\n    <Details minRep=\"1\" type=\"MISSION_POLICE_REMOVE\">\n      <Condition>NONE</Condition>\n      <computerID>0</computerID>\n    </Details>\n    <reward>0</reward>\n    <playerOwnerID />\n    <preMissionID>19</preMissionID>\n  </Mission>\n</Missions>",
        "ID": "112798c29d779cad4e1d524d20e90df8",
        "refCount": 1
    },
    {
        "Content": "{\"listaZonaMem\":{\"0x1B3BE180\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"deltaddgetc\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3,1,0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/home\",\"user\":\"root\",\"numRegisterUsers\":1,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"ercolor_global\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/home\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"strue\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x1B3BE180\",\"timesPatched\":0,\"hide\":false},\"0x4F97811C\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[1,2,0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/root\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"flush_siz\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"emouscompositionleventilcl\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x4F97811C\",\"timesPatched\":0,\"hide\":true},\"0x360366AB\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"howbuttontil\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,3],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/sys\",\"user\":\"root\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"eteffectse\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x360366AB\",\"timesPatched\":0,\"hide\":true},\"0xBAA6768\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0,1,2],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/boot\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"transforedpointln\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/home\",\"user\":\"root\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"cethisibledquotecalsmax_s\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":false,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0xBAA6768\",\"timesPatched\":0,\"hide\":true},\"0x2F7BB222\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"outover\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"ast_eob_leng\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,3],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"text\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":false,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x2F7BB222\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":9}",
        "ID": "fade8d87a51ee0c61514bfe11739b0e4",
        "refCount": 3
    },
    {
        "Content": "{\"listaZonaMem\":{\"0x449ED6B7\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0,3,1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/lib\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"_fresul\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":12,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[2,0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/sys\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":3,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"lusb\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[5,1],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"hemeimatictionx\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3,5],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/sys\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"graphic\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[5],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/sys\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"aximizelite\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x449ED6B7\",\"timesPatched\":0,\"hide\":false},\"0x4E1CC26B\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3,0],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/lib\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":3,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"oundostareturnalconnewima\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"bl_treethemec\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[2,1],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/root\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"ttextpositionarye\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/boot\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"tation\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x4E1CC26B\",\"timesPatched\":0,\"hide\":false},\"0x1E194624\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"iewportt\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3,1],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/home\",\"user\":\"root\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"allbackpush_bl\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[0,0,9]}},{\"typeVulner\":0,\"requiredActions\":[3,0],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/boot\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"treenovea\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":13,\"metaxploitVersion\":{\"version\":[0,0,9]}}],\"address\":\"0x1E194624\",\"timesPatched\":0,\"hide\":false},\"0x3D733B6B\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[2],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"undonenum\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1,2,5],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr/bin\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":1,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"edistatic_lendpointli\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[5,1,2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/lib\",\"user\":\"normal_user\",\"numRegisterUsers\":3,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"etdeflatect\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":0,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":1,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"sultfu\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2,5],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/etc\",\"user\":\"normal_user\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"positia\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x3D733B6B\",\"timesPatched\":0,\"hide\":true},\"0x21BCEE1\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr/bin\",\"user\":\"normal_user\",\"numRegisterUsers\":2,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"onfont\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0,5,3],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/sys\",\"user\":\"guest\",\"numRegisterUsers\":2,\"numPortForward\":1,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"edutilcloselengthsstackaddundown\",\"details\":\"loop in array\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x21BCEE1\",\"timesPatched\":0,\"hide\":true},\"0x730F3592\":{\"vulnerabs\":[{\"typeVulner\":0,\"requiredActions\":[],\"helperHackResult\":{\"hackResult\":1,\"randomPath\":\"/usr/bin\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"chai\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[0],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/bin\",\"user\":\"guest\",\"numRegisterUsers\":3,\"numPortForward\":3,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"lancesbuild_tre\",\"details\":\"string copy in\",\"reqLibVersion\":\"1.0.0\",\"isRemote\":true,\"requiredLib\":11,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[3],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/bin\",\"user\":\"root\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":3,\"vecesUsado\":0},\"unsecValue\":\"facter\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[1],\"helperHackResult\":{\"hackResult\":2,\"randomPath\":\"/usr\",\"user\":\"normal_user\",\"numRegisterUsers\":1,\"numPortForward\":2,\"numConnGateway\":2,\"vecesUsado\":0},\"unsecValue\":\"ead\",\"details\":\"string copy in\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}},{\"typeVulner\":0,\"requiredActions\":[2],\"helperHackResult\":{\"hackResult\":3,\"randomPath\":\"/usr\",\"user\":\"guest\",\"numRegisterUsers\":4,\"numPortForward\":2,\"numConnGateway\":1,\"vecesUsado\":0},\"unsecValue\":\"atethistemd\",\"details\":\"loop in array\",\"reqLibVersion\":null,\"isRemote\":true,\"requiredLib\":0,\"metaxploitVersion\":{\"version\":[1,0,0]}}],\"address\":\"0x730F3592\",\"timesPatched\":0,\"hide\":true}},\"version\":{\"version\":[1,0,0]},\"idLib\":7}",
        "ID": "8aa61af6dc101e1af3d9e697f7bac14e",
        "refCount": 1
    },
    {
        "Content": "metaxploit = include_lib(\"/lib/metaxploit.so\")\nif (metaxploit == null) then metaxploit = include_lib(current_path + \"/metaxploit.so\")\nif (metaxploit == null) then exit(\"Metaxploit missing...\")\n\nmetaxploit.rshell_client(params[0], 1222, \"x\")\n",
        "ID": "7d5485fbda24cde6ce58223e1d7d6578",
        "refCount": 3
    },
    {
        "Content": "root:xxxx\nAtiong:82233bce59652cf3cc0eb7a03f3109d1\nAronbarte:1c2ae0025fa207d6fbccbad479bb06f9\nErkins:b1c42240e75d97085ed6cbfff79a1527\n",
        "ID": "44b1cefdd5cca43ec754d6325714a26e",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":4,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 07:06\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"139.45.15.5\",\"playerNetID\":\"89bf24d4-fd3d-4fd3-8afb-9816082c33a9\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 09:36\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"139.45.15.5\",\"playerNetID\":\"89bf24d4-fd3d-4fd3-8afb-9816082c33a9\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "2b32c62f72d78108cebcdea91e6f85c3",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":4,\"ip\":\"192.168.1.2\",\"fecha\":\"30-4-1990 07:06\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"139.45.15.5\",\"playerNetID\":\"89bf24d4-fd3d-4fd3-8afb-9816082c33a9\",\"buscado\":false,\"tutorial\":false},{\"action\":4,\"ip\":\"192.168.1.2\",\"fecha\":\"30-4-1990 09:36\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"139.45.15.5\",\"playerNetID\":\"89bf24d4-fd3d-4fd3-8afb-9816082c33a9\",\"buscado\":false,\"tutorial\":false}]}",
        "ID": "f30af3b59ad428369611e8fece5ab065",
        "refCount": 1
    },
    {
        "Content": "{\"contentLog\":[{\"action\":0,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 07:06\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true},{\"action\":0,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 09:36\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true},{\"action\":2,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 09:36\",\"puerto\":22,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true},{\"action\":1,\"ip\":\"139.45.15.5\",\"fecha\":\"30-4-1990 09:37\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true},{\"action\":1,\"ip\":\"80.18.172.8\",\"fecha\":\"30-4-1990 09:38\",\"puerto\":0,\"file\":\"\",\"bounceIp\":\"\",\"playerNetID\":\"\",\"buscado\":false,\"tutorial\":true}]}",
        "ID": "050dde14a8bc7431f13531840c997993",
        "refCount": 1
    },
    {
        "Content": "metaxploit = include_lib(\"/lib/metaxploit.so\")\nif (metaxploit == null) then metaxploit = include_lib(current_path + \"/metaxploit.so\")\nif (metaxploit == null) then exit(\"Metaxploit missing...\")\n\nprint(metaxploit.rshell_server())\n\n",
        "ID": "aec20a64641b6b291bdd6e4de6a35cfa",
        "refCount": 1
    },
    {
        "Content": "metaxploit = include_lib(\"/lib/metaxploit.so\")\nif (metaxploit == null) then metaxploit = include_lib(current_path + \"/metaxploit.so\")\nif (metaxploit == null) then exit(\"Metaxploit missing...\")\n\nshells = metaxploit.rshell_server()\n\nfor shell in shells\n\tcomputer = shell.host_computer\n\t\n\tprint(computer.public_ip)\nend for\n\n",
        "ID": "f0dca7fb42f4835c4da142de19c7eb4a",
        "refCount": 2
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDefaultParser.TYPES = {}\nDefaultParser.TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DefaultParser.TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFeatureParser.TYPES = {}\nFeatureParser.TYPES.ENVAR = \"envar\"\nFeatureParser.TYPES.INCLUDE = \"include\"\nFeatureParser.TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FeatureParser.TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\nlineNumber = 0\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\n\tlineNumber = lineNumber + 1\nend for\n\nprint(lines)\nprint(tokens)\n",
        "ID": "8ca6052668ac23865ec61235ff6a0887",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDefaultParser = {}\nDefaultParser.TYPES = {}\nDefaultParser.TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DefaultParser.TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFeatureParser.TYPES = {}\nFeatureParser.TYPES.ENVAR = \"envar\"\nFeatureParser.TYPES.INCLUDE = \"include\"\nFeatureParser.TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FeatureParser.TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\nlineNumber = 0\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\n\tlineNumber = lineNumber + 1\nend for\n\nprint(lines)\nprint(tokens)\n",
        "ID": "a89b35717887ae3b4deb2f4a49f6a077",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\nlineNumber = 0\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\n\tlineNumber = lineNumber + 1\nend for\n\nprint(lines)\nprint(tokens)\n",
        "ID": "e40abaf4a871598a9818f66aa008c98f",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\nlineNumber = 0\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\n\tlineNumber = lineNumber + 1\nend for\n\nprint(lines)\nprint(tokens)\n",
        "ID": "847ea82c0459b264565aed026a36543a",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\n",
        "ID": "5701c95d7ca65eac7e1c478791814222",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\tprint(\"test\")\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\n",
        "ID": "4d638494363c5a433bedacbc401b5cea",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\tprint(token)\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\n",
        "ID": "0bf69be0f1507026222d6bb2fffa3754",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\n\treturn tokens\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\n",
        "ID": "e641b95589d9a8f15472cabd0cd3a75c",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\n\treturn tokens\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\nprint(tokens[0].meta.value)\n",
        "ID": "70980f52dd56ab0e8e25e92fc1c4170e",
        "refCount": 1
    },
    {
        "Content": "my = #envar test;\n#import test from duuude;\n",
        "ID": "03795c77424b3ff99772d6ff0014c2ba",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tprint(parsedCommand)\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\n\treturn tokens\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\nprint(tokens[0].meta.value)\n",
        "ID": "99eed04c11423c7d296c659e30645524",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tprint(line)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tprint(parsedCommand)\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\n\treturn tokens\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\nprint(tokens[0].meta.value)\n",
        "ID": "1eb66784726ccd2a7f8b83d3f4d8441e",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tprint(line)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tprint(parsedCommand)\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tprint((\"-\" * 10) + \"iteration\")\n\t\tprint(char)\n\t\tprint(buffer)\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\n\treturn tokens\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\nprint(tokens[0].meta.value)\n",
        "ID": "b1146ee740cd9b550afbfad868c8f802",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\tprint((\"-\" * 10) + \"declaration\")\n\tprint(\"line=\" + line)\n\tprint(\"from=\" + from)\n\tprint(\"varName=\" + varName)\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tprint((\"-\" * 10) + \"feature\")\n\tprint(\"line=\" + line)\n\tprint(\"from=\" + from)\n\tprint(\"to=\" + to)\n\tprint(\"type=\" + type)\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tprint((\"-\" * 10) + \"iteration\")\n\t\tprint(char)\n\t\tprint(buffer)\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\n\treturn tokens\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\nprint(tokens[0].meta.value)\n",
        "ID": "072646ba944d7b7f3a921bf10e0e1cdf",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\tprint((\"-\" * 10) + \"declaration\")\n\tprint(\"line=\" + line)\n\tprint(\"from=\" + from)\n\tprint(\"varName=\" + varName)\n\tprint(\"affectedString=\" + affectedString)\n\t\n\twhile index < length\n\t\tchar = affectedString[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = AST.TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tprint((\"-\" * 10) + \"feature\")\n\tprint(\"line=\" + line)\n\tprint(\"from=\" + from)\n\tprint(\"to=\" + to)\n\tprint(\"type=\" + type)\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tprint((\"-\" * 10) + \"iteration\")\n\t\tprint(char)\n\t\tprint(buffer)\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\n\treturn tokens\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\nprint(tokens[0].meta.value)\n",
        "ID": "5e3b8771f049c95a513f48c95a0883be",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\tprint((\"-\" * 10) + \"declaration\")\n\tprint(\"line=\" + line)\n\tprint(\"from=\" + from)\n\tprint(\"varName=\" + varName)\n\tprint(\"affectedString=\" + affectedString)\n\t\n\twhile index < length\n\t\tchar = affectedString[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = NTPRTR_TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tprint((\"-\" * 10) + \"feature\")\n\tprint(\"line=\" + line)\n\tprint(\"from=\" + from)\n\tprint(\"to=\" + to)\n\tprint(\"type=\" + type)\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tprint((\"-\" * 10) + \"iteration\")\n\t\tprint(char)\n\t\tprint(buffer)\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\n\treturn tokens\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\nprint(tokens[0].meta.value)\n",
        "ID": "65f67a67feccb69985aec2f3d570af9d",
        "refCount": 1
    },
    {
        "Content": "Token = {}\n\nToken.constructor = function(type, line, from, to, meta)\n\tself.type = type\n\tself.line = line\n\tself.from = from\n\tself.to = to\n\tself.meta = meta\n\treturn self\nend function\n\nDEFAULT_TYPES = {}\nDEFAULT_TYPES.DECLARATION = \"declaration\"\n\nDeclarationParser = function(line, from, varName)\n\tdefaultTypes = DEFAULT_TYPES\n\taffectedString = line[from + 1:]\n\tindex = 0\n\tlength = affectedString.len\n\tbuffer = \"\"\n\tmeta = { \"varName\": varName.trim }\n\t\n\tprint((\"-\" * 10) + \"declaration\")\n\tprint(\"line=\" + line)\n\tprint(\"from=\" + from)\n\tprint(\"varName=\" + varName)\n\tprint(\"affectedString=\" + affectedString)\n\t\n\twhile index < length\n\t\tchar = affectedString[index]\n\t\tif (char == NTPRTR_TOKENS.CURLY_BRACKET_END or char == NTPRTR_TOKENS.COMMA) then break\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\t\n\ttoken = (new Token).constructor(defaultTypes.DECLARATION, line, from, from + index, meta)\n\tmeta.value = Tokenizer(buffer.trim, token)\n\t\n\treturn token\nend function\n\nFEATURE_TYPES = {}\nFEATURE_TYPES.ENVAR = \"envar\"\nFEATURE_TYPES.INCLUDE = \"include\"\nFEATURE_TYPES.IMPORT = \"import\"\n\nFeatureParser = function(line, from)\n\tfeatureEnd = NTPRTR_TOKENS.FEATURE_END\n\tfeatureTypes = FEATURE_TYPES\n\tto = line.indexOf(featureEnd, from)\n\tparsedCommand = line[from + 1: to].split(\" \")\n\ttype = parsedCommand[0]\n\t\n\tprint((\"-\" * 10) + \"feature\")\n\tprint(\"line=\" + line)\n\tprint(\"from=\" + from)\n\tprint(\"to=\" + to)\n\tprint(\"type=\" + type)\n\t\n\tif (type == featureTypes.ENVAR) then\n\t\tenvarKey = parsedCommand[1]\n\t\tmeta = { \"key\": envarKey }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.ENVAR, line, from, to, meta)\n\telse if (type == featureTypes.INCLUDE) then\n\t\tpath = parsedCommand[1]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid include $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.INCLUDE, line, from, to, meta)\n\telse if (type == featureTypes.IMPORT) then\n\t\tvarName = parsedCommand[1]\n\t\tpath = parsedCommand[3]\n\t\t\n\t\tif (path == null) then\n\t\t\t(new Error).constructor(\"Invalid import $0...\", [line]).throw()\n\t\tend if\n\t\t\n\t\tmeta = { \"path\": path, \"varName\": varName }\n\t\t\n\t\treturn (new Token).constructor(featureTypes.IMPORT, line, from, to, meta)\n\tend if\n\t\n\treturn null\nend function\n\nNTPRTR_TOKENS = {}\nNTPRTR_TOKENS.DECLARATION = \"=\"\nNTPRTR_TOKENS.STRING = char(34)\nNTPRTR_TOKENS.IF = \"if\"\nNTPRTR_TOKENS.IF_ELSE = \"else if\"\nNTPRTR_TOKENS.ELSE = \"else\"\nNTPRTR_TOKENS.END_IF = \"end if\"\nNTPRTR_TOKENS.FOR = \"for\"\nNTPRTR_TOKENS.END_FOR = \"end for\"\nNTPRTR_TOKENS.WHILE = \"while\"\nNTPRTR_TOKENS.END_WHILE = \"end while\"\nNTPRTR_TOKENS.FUNCTION = \"function\"\nNTPRTR_TOKENS.END_FUNCTION = \"end function\"\nNTPRTR_TOKENS.FEATURE_START = \"#\"\nNTPRTR_TOKENS.FEATURE_END = \";\"\nNTPRTR_TOKENS.COMMA = \",\"\nNTPRTR_TOKENS.CURLY_BRACKET_START = \"(\"\nNTPRTR_TOKENS.CURLY_BRACKET_END = \")\"\nNTPRTR_TOKENS.WHITESPACE = \" \"\n\nTokenizer = function(line, parent)\n\ttokens = []\n\tindex = 0\n\tlength = line.len\n\tbuffer = \"\"\n\t\n\twhile index < length\n\t\tchar = line[index]\n\t\t\n\t\tprint((\"-\" * 10) + \"iteration\")\n\t\tprint(char)\n\t\tprint(buffer)\n\t\t\n\t\tif (char == NTPRTR_TOKENS.DECLARATION and line[index + 1] != NTPRTR_TOKENS.DECLARATION) then\n\t\t\ttoken = DeclarationParser(line, index, buffer)\n\t\t\tbuffer = \"\"\n\t\t\tindex = token.to\n\t\t\ttokens.push(token)\n\t\telse if (char == NTPRTR_TOKENS.FEATURE_START) then\n\t\t\ttoken = FeatureParser(line, index)\n\t\t\t\n\t\t\tif (token != null) then\n\t\t\t\tbuffer = \"\"\n\t\t\t\tindex = token.to\n\t\t\t\ttokens.push(token)\n\t\t\tend if\n\t\tend if\n\t\t\n\t\tbuffer = buffer + char\n\t\tindex = index + 1\n\tend while\n\n\treturn tokens\nend function\n\nBACKSLASH_CODE = 92\nNEW_LINE_OPERATOR = char(BACKSLASH_CODE) + \"n\"\n\nfile = get_shell.host_computer.File(parent_path(program_path) + \"/test.src\")\ncontent = file.get_content\ntokens = []\nlines = content.split(NEW_LINE_OPERATOR)\n\nfor line in lines\n\tentries = Tokenizer(line)\n\tif (entries != null) then tokens = tokens + entries\nend for\n\nprint(lines)\nprint(tokens)\nprint(tokens[0].meta.value)\n",
        "ID": "e0fcf3cfdaa5e5fa3c52daf017629ad5",
        "refCount": 2
    },
    {
        "Content": "test = get_shell\n\nprint(typeof(test))\n",
        "ID": "07124d75cacdb4134e65adc455b682cb",
        "refCount": 1
    }
]